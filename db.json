{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/background.png","path":"images/background.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/touxiang.png","path":"images/touxiang.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/tubiao.png","path":"images/tubiao.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/click.js","path":"js/click.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/style.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1681193389821},{"_id":"source/_posts/如何阅读一本书.md","hash":"1322d81f7a0a36274bb7fbb2371b5dd201394910","modified":1681193389822},{"_id":"source/about/index.md","hash":"bab90c2691cd6e5b5f423963783a6ec4faa369d4","modified":1681193389822},{"_id":"source/categories/index.md","hash":"f317250ffdce9e739211b0705b08972115e7a016","modified":1681193389822},{"_id":"source/read/index.md","hash":"6c1deba4027444ac9f94845e33f1ae309a343527","modified":1681193389823},{"_id":"source/schedule/index.md","hash":"7188f722bf8e3c090c3688e16cd18f925d1d8e0d","modified":1681193389823},{"_id":"source/tags/index.md","hash":"62343be057a3a43ea368b03fcf07cbc4c85f2862","modified":1681193389823},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1681193389851},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1681193389851},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1681193389852},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1681193389856},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1681193389857},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1681193389856},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1681193389857},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1681193389857},{"_id":"themes/next/_config.yml","hash":"cec3b0f519e0a929f09d995ae1b88d506026c285","modified":1681201074268},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1681193389858},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1681193389865},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1681193389893},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1681193389852},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1681193389852},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1681193389854},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1681193389854},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1681193389855},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1681193389855},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1681193389855},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1681193389855},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1681193389855},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1681193389856},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1681193389856},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1681193389858},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1681193389859},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1681193389859},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1681193389859},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1681193389860},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1681193389860},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1681193389860},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1681193389860},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1681193389861},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1681193389865},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1681193389866},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1681193389866},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1681193389866},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1681193389866},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1681193389867},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1681193389867},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1681193389867},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1681193389867},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1681193389868},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1681193389868},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1681193389868},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1681193389868},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1681193389869},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1681193389870},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1681193389870},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1681193389870},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1681193389870},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1681193389871},{"_id":"themes/next/languages/zh-CN.yml","hash":"ae5bd475eff141f9aea13cb0f8ae55f246d021dd","modified":1681197741783},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1681193389871},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1681193389871},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1681193389899},{"_id":"themes/next/layout/_layout.swig","hash":"7f9a3a7274f8d0d422c68800a0a1b6f5aba513b4","modified":1681193389872},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1681193389891},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1681193389892},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1681193389892},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1681193389892},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1681193389893},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1681193389892},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1681193389853},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1681193389853},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1681193389853},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1681193389854},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1681193389861},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1681193389861},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1681193389862},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1681193389862},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1681193389862},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1681193389863},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1681193389863},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1681193389863},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1681193389864},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1681193389864},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1681193389864},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1681193389864},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1681193389865},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1681193389893},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1681193389897},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1681193389897},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1681193389897},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1681193389898},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1681193389898},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1681193389898},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1681193389899},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1681193389899},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1681193389899},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1681193389900},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1681193389900},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1681193389900},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1681193389900},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1681193389901},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1681193389901},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1681193389901},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1681193389901},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1681193389902},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1681193389902},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1681193389872},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1681193389872},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1681193389872},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1681193389873},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1681193389873},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1681193389876},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1681193389876},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1681193389879},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1681193389880},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1681193389880},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1681193389881},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1681193389882},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1681193389882},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1681193389884},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1681193389886},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1681193389887},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1681193389888},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1681193389902},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1681193389941},{"_id":"themes/next/source/css/main.styl","hash":"81d0e6ed4e3fe016f2b6f38039e9a9bda0ce67e0","modified":1681193391151},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1681193391151},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1681193391152},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1681193391152},{"_id":"themes/next/source/images/background.png","hash":"e552d157ce511e03b996a002901c454b9dd70e9f","modified":1681193391153},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1681193391153},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1681193391153},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1681193391154},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1681193391154},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1681193391154},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1681193391154},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1681193391155},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1681193391155},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1681193391155},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1681193391155},{"_id":"themes/next/source/images/touxiang.png","hash":"9e42049151fc2efdc38b2d84df5f10a10b2771f1","modified":1681193391156},{"_id":"themes/next/source/images/tubiao.png","hash":"9e42049151fc2efdc38b2d84df5f10a10b2771f1","modified":1681193391156},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1681193391156},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1681193391157},{"_id":"themes/next/source/js/click.js","hash":"6583037545c7edc355f76f29b3393e250b150032","modified":1681193391157},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1681193391157},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1681193391158},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1681193391158},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1681193391159},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1681193391159},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1681193389894},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1681193389894},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1681193389894},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1681193389895},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1681193389895},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1681193389895},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1681193389895},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1681193389896},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1681193389896},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1681193389896},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1681193389897},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1681193389873},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1681193389874},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1681193389874},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1681193389875},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1681193389875},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1681193389875},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1681193389875},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1681193389876},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1681193389876},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1681193389877},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1681193389877},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1681193389877},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1681193389878},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1681193389878},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1681193389878},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1681193389878},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1681193389879},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1681193389879},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1681193389880},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1681193389881},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1681193389881},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1681193389881},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1681193389882},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1681193389883},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1681193389883},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1681193389883},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1681193389884},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1681193389884},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1681193389884},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1681193389885},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1681193389885},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1681193389885},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1681193389886},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1681193389886},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1681193389886},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1681193389887},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1681193389887},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1681193389887},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1681193389888},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1681193389888},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1681193389888},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1681193389889},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1681193389889},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1681193389890},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1681193389890},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1681193389890},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1681193389891},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1681193389891},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1681193391149},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1681193391149},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1681193391150},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1681193391150},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1681193391150},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1681193391158},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1681193391158},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1681193391162},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1681193391162},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1681193389903},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1681193389903},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1681193389903},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1681193389910},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1681193389931},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1681193389931},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1681193389935},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1681193389935},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1681193389936},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1681193389938},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1681193389938},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1681193389938},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1681193389939},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1681193389941},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1681193391144},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1681193391144},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1681193391144},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1681193391145},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1681193391145},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1681193391145},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1681193391146},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1681193391146},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1681193391146},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1681193391147},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1681193391147},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1681193391147},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1681193391147},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1681193391148},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1681193391148},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1681193391148},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1681193391149},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1681193391149},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1681193391161},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1681193391160},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1681193389904},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1681193389904},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1681193389905},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1681193389905},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1681193389906},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1681193389910},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1681193389910},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1681193389921},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1681193389921},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1681193389921},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1681193389906},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1681193389907},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1681193389907},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1681193389907},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1681193389908},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1681193389908},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1681193389908},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1681193389908},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1681193389909},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1681193389909},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1681193389909},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1681193389909},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1681193389909},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1681193389922},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1681193389922},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1681193389922},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1681193389930},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1681193389930},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1681193389930},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1681193389923},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1681193389930},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1681193389932},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1681193389932},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1681193389932},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1681193389933},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1681193389933},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1681193389933},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1681193389934},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1681193389934},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1681193389934},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1681193389935},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1681193389936},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1681193389937},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1681193389937},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1681193389938},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1681193389939},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1681193389939},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1681193389940},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1681193389940},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1681193389940},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1681193389941},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1681193389941},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1681193391160},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1681193391162},{"_id":"public/about/index.html","hash":"6a634ddb2bf451982dc93865c89393d9dd6851c6","modified":1681479078937},{"_id":"public/categories/index.html","hash":"22d3a0d250232faec63846f89cb80066e3926c28","modified":1681480505920},{"_id":"public/read/index.html","hash":"d0454f90fa88b6c1efc4634a6492f1619f8f3411","modified":1681480505920},{"_id":"public/schedule/index.html","hash":"7c20c9e9f7ede3b1da6ed1c02e4e5002895b8c78","modified":1681479078937},{"_id":"public/tags/index.html","hash":"767abbe5814b2129ce0f432ef72d9e10a929697d","modified":1681479078937},{"_id":"public/categories/阅读/index.html","hash":"c251e7a4603181f027e839f4b8bdfb6d42ea8d67","modified":1681479078937},{"_id":"public/index.html","hash":"9280f685c093fa5fe1fa021464cfff080dea50de","modified":1681480505920},{"_id":"public/archives/index.html","hash":"1c63aef62503a82ee850858a143a5e78787a9df2","modified":1681480505920},{"_id":"public/archives/2021/index.html","hash":"f91b540a2c4751ea2b82909f2697a698f3307a88","modified":1681479078937},{"_id":"public/archives/2021/01/index.html","hash":"46ad1406fc20f33a853d8551359cecae849fab88","modified":1681479078937},{"_id":"public/tags/读书/index.html","hash":"42e1b538bbf6364389bf5ee517937b7373998b56","modified":1681479078937},{"_id":"public/2021/01/07/如何阅读一本书/index.html","hash":"0ed36226a5ce4064e3d88fb8096d15e0dfc4fcb1","modified":1681479078937},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1681193511708},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1681193511708},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1681193511708},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1681193511708},{"_id":"public/images/background.png","hash":"e552d157ce511e03b996a002901c454b9dd70e9f","modified":1681193511708},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1681193511708},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1681193511708},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1681193511708},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1681193511708},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1681193511708},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1681193511708},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1681193511708},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1681193511708},{"_id":"public/images/touxiang.png","hash":"9e42049151fc2efdc38b2d84df5f10a10b2771f1","modified":1681193511708},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1681193511708},{"_id":"public/images/tubiao.png","hash":"9e42049151fc2efdc38b2d84df5f10a10b2771f1","modified":1681193511708},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1681193511708},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1681193511708},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1681193511708},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1681193511708},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1681193511708},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1681193511708},{"_id":"public/js/click.js","hash":"effa770d8085f7e7fb903de217ce521dff163780","modified":1681193511708},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1681193511708},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1681193511708},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1681193511708},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1681193511708},{"_id":"public/css/main.css","hash":"311d2a7be0945b603b3fe1388d84824224e07b57","modified":1681193511708},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1681193511708},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1681193511708},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1681193511708},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1681193511708},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1681193511708},{"_id":"source/_posts/hexo环境重新快速搭建.md","hash":"1e303685c540e66dbf56754b082b5b67ff85ae58","modified":1681201442734},{"_id":"source/notes/index.md","hash":"4e63c0004d401925a13a25e020297743a33efdd6","modified":1681197603467},{"_id":"public/notes/index.html","hash":"46d4750f023ec8af422ebc4b1f9885aebf1cc227","modified":1681480505920},{"_id":"public/archives/2023/index.html","hash":"6f3d199a670bb211f72be9158992872ac2be5bbd","modified":1681480505920},{"_id":"public/archives/2023/04/index.html","hash":"d517dae7155b08ff71c0826ccb88a6d5687a1b1b","modified":1681480505920},{"_id":"public/categories/笔记/index.html","hash":"de1ee62bb4c21f1b96e0bfafcc859fef0986905c","modified":1681480505920},{"_id":"public/2023/04/11/hexo环境重新快速搭建/index.html","hash":"beae375d3b01c2bb1244b76dca0aca7f7cfdfbfa","modified":1681479078937},{"_id":"source/_posts/next主题美化.md","hash":"571443d28a15dbf0f704a28e2f89623ed8fde8d0","modified":1681361073135},{"_id":"public/archives/2022/index.html","hash":"ce09477c3e1b25d554453debe77e654a42c8f0c3","modified":1681479078937},{"_id":"public/archives/2022/03/index.html","hash":"cb02d949fc0ffe22a7c3f22434778f567f7a85ea","modified":1681479078937},{"_id":"public/2022/03/16/next主题美化/index.html","hash":"2e8ea330afe6fe6d656bc7b1182ffbc9f41446bb","modified":1681479078937},{"_id":"source/_posts/1-V4l2.md","hash":"b15cb356ba91454478ea560087884a84369aad4f","modified":1681359704991},{"_id":"source/_posts/1-V4l2/1.png","hash":"7d081222831c25ce1f093010421eb7fad6a470bc","modified":1655189774771},{"_id":"source/_posts/1-V4l2/2.png","hash":"4b664a253ed1ec9ca0baf6ebe128a35e5d120f39","modified":1655189795137},{"_id":"source/_posts/1-V4l2/3.png","hash":"9cea1e6173ad4e51a5f9700d930a52a4a8e88be4","modified":1655189805527},{"_id":"public/2023/04/13/1-V4l2/index.html","hash":"f791d4341a046fb69b3219337f544225646ebdb4","modified":1681479078937},{"_id":"public/2023/04/13/1-V4l2/1.png","hash":"7d081222831c25ce1f093010421eb7fad6a470bc","modified":1681358511666},{"_id":"public/2023/04/13/1-V4l2/2.png","hash":"4b664a253ed1ec9ca0baf6ebe128a35e5d120f39","modified":1681358511666},{"_id":"public/2023/04/13/1-V4l2/3.png","hash":"9cea1e6173ad4e51a5f9700d930a52a4a8e88be4","modified":1681358511666},{"_id":"public/tags/嵌入式/index.html","hash":"e91bf64b9ee533ecd3a9462617e4a3253a0000d6","modified":1681480505920},{"_id":"source/_posts/2-YUV&RGB.md","hash":"a038e0b278d484df22c53c7473dfe0ac0e771684","modified":1681361958240},{"_id":"source/_posts/2-YUV&RGB/1.png","hash":"31d002f1f9fb6547d3b48d27786f01e5a6e7a581","modified":1657179042889},{"_id":"source/_posts/2-YUV&RGB/2.png","hash":"25da046078227ab61205a1ff7824ae3667cb81d7","modified":1657179424733},{"_id":"source/_posts/2-YUV&RGB/3.png","hash":"527c17e0510d9eccc70e98b7e01c1452f77bbb04","modified":1657180633199},{"_id":"source/_posts/2-YUV&RGB/4.png","hash":"5992b4bc13cad0eb6f148d7cd223817a08012829","modified":1657182513091},{"_id":"source/_posts/2-YUV&RGB/5.png","hash":"63785e376e9dce761d2d855b87d7274406fde26f","modified":1657182709143},{"_id":"source/_posts/2-YUV&RGB/6.png","hash":"f480e5ce17b7210767c21e26949cabeccdcb323a","modified":1657182659790},{"_id":"source/_posts/2-YUV&RGB/7.png","hash":"6215501ffb8e15b8f41bea8733087c4c15b57364","modified":1657182818753},{"_id":"source/_posts/2-YUV&RGB/8.png","hash":"1f836f5fbdc8018608732cb8776a7f33f88c3cd8","modified":1657183247567},{"_id":"source/_posts/2-YUV&RGB/12.jpg","hash":"eaa5e6a9e023844e1f839ae9a186ff56c2eb257f","modified":1657183892781},{"_id":"source/_posts/2-YUV&RGB/11.jpg","hash":"7c7f835a02e65f225dc3e51e6e61e5f0deec9daa","modified":1657183851269},{"_id":"source/_posts/2-YUV&RGB/9.jpg","hash":"84762bb8291da7a68f51ba332c374d97cdd88aa3","modified":1657183713762},{"_id":"source/_posts/2-YUV&RGB/10.jpg","hash":"3ccc1b817c5ee3c62a3b7a984b2ef5514341ee2a","modified":1657183762078},{"_id":"public/2023/04/13/2-YUV&RGB/index.html","hash":"6432bbeea5e4f6334bda5e137195afe2ecfcd7b1","modified":1681479078937},{"_id":"public/2023/04/13/2-YUV&RGB/1.png","hash":"31d002f1f9fb6547d3b48d27786f01e5a6e7a581","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/2.png","hash":"25da046078227ab61205a1ff7824ae3667cb81d7","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/3.png","hash":"527c17e0510d9eccc70e98b7e01c1452f77bbb04","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/4.png","hash":"5992b4bc13cad0eb6f148d7cd223817a08012829","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/5.png","hash":"63785e376e9dce761d2d855b87d7274406fde26f","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/6.png","hash":"f480e5ce17b7210767c21e26949cabeccdcb323a","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/8.png","hash":"1f836f5fbdc8018608732cb8776a7f33f88c3cd8","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/7.png","hash":"6215501ffb8e15b8f41bea8733087c4c15b57364","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/12.jpg","hash":"eaa5e6a9e023844e1f839ae9a186ff56c2eb257f","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/11.jpg","hash":"7c7f835a02e65f225dc3e51e6e61e5f0deec9daa","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/9.jpg","hash":"84762bb8291da7a68f51ba332c374d97cdd88aa3","modified":1681361869441},{"_id":"public/2023/04/13/2-YUV&RGB/10.jpg","hash":"3ccc1b817c5ee3c62a3b7a984b2ef5514341ee2a","modified":1681361869441},{"_id":"source/_posts/G2D.md","hash":"5335d3e5164af4c1356456640b6a17b717cb4db0","modified":1681467611322},{"_id":"source/_posts/G2D/1.png","hash":"d11a923c66c917e61581951f3d3954410d18a740","modified":1655859024736},{"_id":"public/2023/04/14/G2D/index.html","hash":"c3083a5cfb8b5cfa77b0e0aca6f85f6716a42f6b","modified":1681478064457},{"_id":"public/2023/04/14/G2D/1.png","hash":"d11a923c66c917e61581951f3d3954410d18a740","modified":1681467116879},{"_id":"source/_posts/FBO.md","hash":"8e4d690a8def382c4dc1f95cc03c26dc7d57ab43","modified":1681478191202},{"_id":"source/_posts/FBO/25.png","hash":"f60d4e4a3c8107fd08daebed9cd01ae54417a2f4","modified":1670501273648},{"_id":"public/tags/嵌入式-OpenGL/index.html","hash":"ea778cd04cfa09bedeb5ad85d96b7b3d2eaf95c0","modified":1681478198364},{"_id":"public/2023/04/14/FBO/index.html","hash":"4e6e8f6a49f273ed9744e276549a25a55257cbae","modified":1681478198364},{"_id":"public/2023/04/14/FBO/25.png","hash":"f60d4e4a3c8107fd08daebed9cd01ae54417a2f4","modified":1681478064457},{"_id":"source/_posts/3-G2D/1.png","hash":"d11a923c66c917e61581951f3d3954410d18a740","modified":1655859024736},{"_id":"source/_posts/4-FBO/25.png","hash":"f60d4e4a3c8107fd08daebed9cd01ae54417a2f4","modified":1670501273648},{"_id":"source/_posts/3-G2D.md","hash":"5335d3e5164af4c1356456640b6a17b717cb4db0","modified":1681467611322},{"_id":"source/_posts/4-FBO.md","hash":"2af37b5829be047224d1d8bb84ab990787250bb5","modified":1681478929276},{"_id":"public/tags/OpenGL/index.html","hash":"1d87d7708bd947bfcb0147e65a308159698b0cd3","modified":1681480505920},{"_id":"public/2023/04/14/4-FBO/index.html","hash":"0c16b930ee1e5b86a81294c59806d5c999e071e6","modified":1681479418670},{"_id":"public/2023/04/14/3-G2D/index.html","hash":"1b7216f9baf2e0f9963bee02577cc2c131ff438d","modified":1681480505920},{"_id":"public/2023/04/14/4-FBO/25.png","hash":"f60d4e4a3c8107fd08daebed9cd01ae54417a2f4","modified":1681478350524},{"_id":"public/2023/04/14/3-G2D/1.png","hash":"d11a923c66c917e61581951f3d3954410d18a740","modified":1681478350524},{"_id":"source/_posts/4-1-OpenGL.md","hash":"de3869886069951ed3a6b5a2e8c191315b893df4","modified":1681479056997},{"_id":"source/_posts/GLSL着色器语言.md","hash":"8e5ccd0df2c2cb5f06818ae94801ac4f3125072a","modified":1663724996484},{"_id":"source/_posts/OpenGL ES 2.0 API.md","hash":"bd146b1f074b1399b8d72c3e1bdded8ede0204b9","modified":1661394938830},{"_id":"source/_posts/OpenGL常用API函数.md","hash":"bcb86b884cd8b29341514e38b2edcc008ce00736","modified":1671505715410},{"_id":"source/_posts/4-2-OpenGL ES.md","hash":"c4fbe7c87e429bf53c3f84b835de69c386250cf5","modified":1681479532972},{"_id":"source/_posts/OpenGL矩阵运算-GLM库的使用.md","hash":"215c4a95aeb70fa641d205a163b9b56f666a88e2","modified":1658288576379},{"_id":"source/_posts/VBO与VAO.md","hash":"b5c947d60e5f5f809c00cacfd73fa49d88bc7eda","modified":1663725417291},{"_id":"source/_posts/4-1-OpenGL/15.png","hash":"babf606fa221981b0369767924fc8ee1c7662a1f","modified":1656310907678},{"_id":"source/_posts/4-1-OpenGL/4.png","hash":"cabbe9cdeff374bc270142983f64e6f9d401a056","modified":1656050082269},{"_id":"source/_posts/4-1-OpenGL/5.png","hash":"39a25da7bf9522cbd19129a88692f04bcf04e67d","modified":1656050142421},{"_id":"source/_posts/4-1-OpenGL/6.png","hash":"2ec30213a8df56dd40b2e980c9b448a251d59bfb","modified":1656050209668},{"_id":"source/_posts/4-1-OpenGL/1.png","hash":"d412c6902c35bdb95925307c1e27d3778bc3ba63","modified":1656047166481},{"_id":"source/_posts/4-1-OpenGL/2.png","hash":"1e03f0b3ebf03de878ed6276a7d7d506557de47d","modified":1656049908962},{"_id":"source/_posts/4-1-OpenGL/9.jpg","hash":"75210212518242e6c925c3ae27e7c876646d97c0","modified":1661414150327},{"_id":"source/_posts/4-1-OpenGL/3.png","hash":"f3087b2088dfda0ab82bb2e3bf113997a63a4b3e","modified":1656049976882},{"_id":"source/_posts/4-1-OpenGL/7.png","hash":"2a150c7567ebc78902beeee2c76f7c1a4349d6b2","modified":1656050305087},{"_id":"public/archives/page/2/index.html","hash":"2df4033d3bf8d90c1e2104b109cc56af89868ca9","modified":1681479078937},{"_id":"public/archives/2023/page/2/index.html","hash":"8a5598e19f47e6c2f563362b4ae2c719824926d8","modified":1681479078937},{"_id":"public/archives/2023/04/page/2/index.html","hash":"cddbeb9fed5762fb001a9df743bfefbd2b272e39","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/index.html","hash":"663dda8e9683ebcf7fefcfa20458d07ff0ccd6ae","modified":1681480505920},{"_id":"public/2023/04/14/GLSL着色器语言/index.html","hash":"8747bc60cd6f4105e386452f70e73522a05fe90d","modified":1681479078937},{"_id":"public/2023/04/14/OpenGL ES 2.0 API/index.html","hash":"f9efef2825bf04ed4f4a0ad3004b137b4982d655","modified":1681479078937},{"_id":"public/2023/04/14/VBO与VAO/index.html","hash":"de3bf8be5a8b0e8566ac09b672d2545ed09ab1bd","modified":1681479078937},{"_id":"public/2023/04/14/OpenGL矩阵运算-GLM库的使用/index.html","hash":"d7a1f8ee05270b61117b06f889fda5e1f54f940b","modified":1681479078937},{"_id":"public/2023/04/14/OpenGL常用API函数/index.html","hash":"c4c67d79ea9658b0038e13f8e563bb080d31644d","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/index.html","hash":"fa1856552b7f3a6c24586b0377dcb0a8b01e0658","modified":1681480236741},{"_id":"public/page/2/index.html","hash":"a6c259dd590ff08211ae3d1e2b9593915dcf1012","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/15.png","hash":"babf606fa221981b0369767924fc8ee1c7662a1f","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/4.png","hash":"cabbe9cdeff374bc270142983f64e6f9d401a056","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/5.png","hash":"39a25da7bf9522cbd19129a88692f04bcf04e67d","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/6.png","hash":"2ec30213a8df56dd40b2e980c9b448a251d59bfb","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/1.png","hash":"d412c6902c35bdb95925307c1e27d3778bc3ba63","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/2.png","hash":"1e03f0b3ebf03de878ed6276a7d7d506557de47d","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/9.jpg","hash":"75210212518242e6c925c3ae27e7c876646d97c0","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/3.png","hash":"f3087b2088dfda0ab82bb2e3bf113997a63a4b3e","modified":1681479078937},{"_id":"public/2023/04/14/4-1-OpenGL/7.png","hash":"2a150c7567ebc78902beeee2c76f7c1a4349d6b2","modified":1681479078937},{"_id":"source/_posts/4-2-OpenGL ES/11.jpg","hash":"52bebb0a3a79eb8c6afad9bbe095561979a1d71b","modified":1661414444583},{"_id":"source/_posts/4-2-OpenGL ES/12.jpg","hash":"6460f5f342202df48d1d900f3e617aee7ecce3e1","modified":1656294121506},{"_id":"source/_posts/4-2-OpenGL ES/14.webp","hash":"4467c996bdd79e66f9d2deff0ed071808b3fb953","modified":1656294480324},{"_id":"source/_posts/4-2-OpenGL ES/18.webp","hash":"c1ae8b6a417a854321f4d3a305c2645206d25408","modified":1657165206271},{"_id":"source/_posts/4-2-OpenGL ES/10.jpg","hash":"e974e56d4827af977d33d38717db29fc395ea4fc","modified":1661414227989},{"_id":"source/_posts/4-2-OpenGL ES/9.jpg","hash":"75210212518242e6c925c3ae27e7c876646d97c0","modified":1661414150327},{"_id":"source/_posts/4-2-OpenGL ES/13.jpg","hash":"e57caf28d17a20bd69ba79b71aef79b8b39f19fb","modified":1656294363464},{"_id":"source/_posts/4-2-OpenGL ES/20.jpg","hash":"bb7a09b508de3df26067748ed3104193dedb7a62","modified":1657176653044},{"_id":"source/_posts/4-2-OpenGL ES/8.png","hash":"ede4a957639de4b121a67c4a6f0b1d4522bdcd12","modified":1656060872377},{"_id":"source/_posts/4-2-OpenGL ES/16.jpg","hash":"24ee210bb77b898d1c8c530ddc20287bc62332a4","modified":1656397907598},{"_id":"source/_posts/4-2-OpenGL ES/19.jpg","hash":"4622c5a29b942658fa2f9fe4944c2efdd03f73e5","modified":1657176402771},{"_id":"source/_posts/4-2-OpenGL ES/17坐标系.png","hash":"b895a44c9937ac2c19d99eb6c488a8020cfe4bcf","modified":1657157147486},{"_id":"public/2023/04/14/4-2-OpenGL ES/12.jpg","hash":"6460f5f342202df48d1d900f3e617aee7ecce3e1","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/11.jpg","hash":"52bebb0a3a79eb8c6afad9bbe095561979a1d71b","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/14.webp","hash":"4467c996bdd79e66f9d2deff0ed071808b3fb953","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/18.webp","hash":"c1ae8b6a417a854321f4d3a305c2645206d25408","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/9.jpg","hash":"75210212518242e6c925c3ae27e7c876646d97c0","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/10.jpg","hash":"e974e56d4827af977d33d38717db29fc395ea4fc","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/8.png","hash":"ede4a957639de4b121a67c4a6f0b1d4522bdcd12","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/13.jpg","hash":"e57caf28d17a20bd69ba79b71aef79b8b39f19fb","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/20.jpg","hash":"bb7a09b508de3df26067748ed3104193dedb7a62","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/16.jpg","hash":"24ee210bb77b898d1c8c530ddc20287bc62332a4","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/19.jpg","hash":"4622c5a29b942658fa2f9fe4944c2efdd03f73e5","modified":1681479418670},{"_id":"public/2023/04/14/4-2-OpenGL ES/17坐标系.png","hash":"b895a44c9937ac2c19d99eb6c488a8020cfe4bcf","modified":1681479418670},{"_id":"source/_posts/4-5-FBO/25.png","hash":"f60d4e4a3c8107fd08daebed9cd01ae54417a2f4","modified":1670501273648},{"_id":"source/_posts/4-3-OpenGL常用API函数.md","hash":"ccd02b6cb0b2574c28ca530656b3c8ecb33d6a06","modified":1681479888005},{"_id":"source/_posts/4-4-OpenGL ES 2.0 API.md","hash":"ad4b712a2c842ec956fd4a92d5ed999103455b76","modified":1681479995740},{"_id":"source/_posts/4-5-FBO.md","hash":"f319517291b07e47d8bab0693cede10c3d5cc22b","modified":1681480145863},{"_id":"source/_posts/4-6-VBO与VAO.md","hash":"1e988f4138d057c8a458f91e1a3c9d0fae34a0cb","modified":1681480255765},{"_id":"source/_posts/4-7-GLSL着色器语言.md","hash":"475a47cc95ca9a68535acab16e41996c077bb32e","modified":1681480419662},{"_id":"source/_posts/4-8-OpenGL矩阵运算-GLM库的使用.md","hash":"9d4671964b634ebff15076715a023ccaea823ca0","modified":1681480494331},{"_id":"public/2023/04/14/4-3-OpenGL常用API函数/index.html","hash":"5cefede50e3276f9b55bbfc8d58280fbc982303f","modified":1681480236741},{"_id":"public/2023/04/14/4-7-GLSL着色器语言/index.html","hash":"6170b5734c67568f2ee706839fb3d8317e06ef70","modified":1681480505920},{"_id":"public/2023/04/14/4-4-OpenGL ES 2.0 API/index.html","hash":"ce1365f184a543eb34d19ed80c202c08d8dcafb2","modified":1681480505920},{"_id":"public/2023/04/14/4-6-VBO与VAO/index.html","hash":"48cf68d5dcf341d673f858c971ec64b8ef1df5a1","modified":1681480505920},{"_id":"public/2023/04/14/4-8-OpenGL矩阵运算-GLM库的使用/index.html","hash":"63af418d0b9e94e8045d180e980769306f124352","modified":1681480505920},{"_id":"public/2023/04/14/4-5-FBO/index.html","hash":"4eed3955ba7b7b2d6a355be2aaf691d21e8bb7c8","modified":1681480505920},{"_id":"public/2023/04/14/4-5-FBO/25.png","hash":"f60d4e4a3c8107fd08daebed9cd01ae54417a2f4","modified":1681479852434},{"_id":"source/_posts/4-6-VBO与VAO/22.png","hash":"4939b0ec0e7eb9254a67be91697041277d7383f5","modified":1661414096929},{"_id":"source/_posts/4-6-VBO与VAO/23.jpg","hash":"089239c21d984dadaaa6428a76f1c9bdca363bc6","modified":1663725380240},{"_id":"source/_posts/4-6-VBO与VAO/24.png","hash":"444a1b356876decf29e21f742e5d9b63cae2eac2","modified":1661825873725},{"_id":"public/categories/笔记/page/2/index.html","hash":"e3399d7471f71fd3e786d09e21d35e6d2abc4bda","modified":1681480505920},{"_id":"public/2023/04/14/4-6-VBO与VAO/22.png","hash":"4939b0ec0e7eb9254a67be91697041277d7383f5","modified":1681480236741},{"_id":"public/2023/04/14/4-6-VBO与VAO/24.png","hash":"444a1b356876decf29e21f742e5d9b63cae2eac2","modified":1681480236741},{"_id":"public/2023/04/14/4-6-VBO与VAO/23.jpg","hash":"089239c21d984dadaaa6428a76f1c9bdca363bc6","modified":1681480236741},{"_id":"source/_posts/4-7-GLSL着色器语言/21.webp","hash":"4aae9b8db2bdbc50793a06c9272b8324ae017872","modified":1661334674731},{"_id":"public/tags/嵌入式/page/2/index.html","hash":"3fc73ee1174847a940aa16e71f3274c42fdccc17","modified":1681480505920},{"_id":"public/2023/04/14/4-7-GLSL着色器语言/21.webp","hash":"4aae9b8db2bdbc50793a06c9272b8324ae017872","modified":1681480505920}],"Category":[{"name":"阅读","_id":"clgbv7k4s00038cobeihkgvvw"},{"name":"笔记","_id":"clgbycqcr0002s8ob1ym92rhv"}],"Data":[{"_id":"style","data":""}],"Page":[{"title":"About","date":"2021-01-03T10:06:11.000Z","type":"关于","comments":0,"_content":"欢迎来到这里  \n\n关于博客\n=\n</br>　　用来记录自己的学习和成长  \n\n关于我\n=\n</br>　　还没想好怎么介绍自己哈哈哈","source":"about/index.md","raw":"---\ntitle: About\ndate: 2021-01-03 18:06:11\ntype: \"关于\"\ncomments: false\n---\n欢迎来到这里  \n\n关于博客\n=\n</br>　　用来记录自己的学习和成长  \n\n关于我\n=\n</br>　　还没想好怎么介绍自己哈哈哈","updated":"2023-04-11T06:09:49.822Z","path":"about/index.html","layout":"page","_id":"clgbv7k4m00008cob6wsr45oe","content":"<p>欢迎来到这里  </p>\n<h1 id=\"关于博客\"><a href=\"#关于博客\" class=\"headerlink\" title=\"关于博客\"></a>关于博客</h1><p></br>　　用来记录自己的学习和成长  </p>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p></br>　　还没想好怎么介绍自己哈哈哈</p>\n","site":{"data":{"style":""}},"length":38,"excerpt":"","more":"<p>欢迎来到这里  </p>\n<h1 id=\"关于博客\"><a href=\"#关于博客\" class=\"headerlink\" title=\"关于博客\"></a>关于博客</h1><p></br>　　用来记录自己的学习和成长  </p>\n<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p></br>　　还没想好怎么介绍自己哈哈哈</p>\n"},{"title":"分类","date":"2021-01-03T10:05:36.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-01-03 18:05:36\ntype: \"categories\"\ncomments: false\n---\n","updated":"2023-04-11T06:09:49.822Z","path":"categories/index.html","layout":"page","_id":"clgbv7k4r00028cob0erbbgir","content":"","site":{"data":{"style":""}},"length":0,"excerpt":"","more":""},{"title":"阅读","date":"2021-01-08T08:04:21.000Z","type":"categories","comments":0,"_content":"","source":"read/index.md","raw":"---\ntitle: 阅读\ndate: 2021-01-08 16:04:21\ntype: \"categories\"\ncomments: false\n---\n","updated":"2023-04-11T06:09:49.823Z","path":"read/index.html","layout":"page","_id":"clgbv7k4v00058cob1x7zeyb5","content":"","site":{"data":{"style":""}},"length":0,"excerpt":"","more":""},{"title":"时间轴","date":"2021-01-03T10:07:00.000Z","type":"schedule","comments":0,"_content":"","source":"schedule/index.md","raw":"---\ntitle: 时间轴\ndate: 2021-01-03 18:07:00\ntype: \"schedule\"\ncomments: false\n---\n","updated":"2023-04-11T06:09:49.823Z","path":"schedule/index.html","layout":"page","_id":"clgbv7k4v00068cob0hgva1rp","content":"","site":{"data":{"style":""}},"length":0,"excerpt":"","more":""},{"title":"标签","date":"2021-01-03T10:06:02.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-01-03 18:06:02\ntype: \"tags\"\ncomments: false\n---\n","updated":"2023-04-11T06:09:49.823Z","path":"tags/index.html","layout":"page","_id":"clgbv7k4w00078cobb3oo48u9","content":"","site":{"data":{"style":""}},"length":0,"excerpt":"","more":""},{"title":"笔记","date":"2023-04-11T07:19:21.000Z","type":"categories","comments":0,"_content":"","source":"notes/index.md","raw":"---\ntitle: 笔记\ndate: 2023-04-11 15:19:21\ntype: \"categories\"\ncomments: false\n---\n","updated":"2023-04-11T07:20:03.467Z","path":"notes/index.html","layout":"page","_id":"clgbycqcl0000s8obguha2kz5","content":"","site":{"data":{"style":""}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"如何阅读一本书？","date":"2021-01-07T07:59:11.000Z","comments":0,"description":null,"_content":"\n# 第一篇：阅读的层次：\n\n## 第一章：阅读的活力与艺术\n\n这本书最主要的目的：让我们懂得如何让书本来教导我们。如果我们打算继续学习与发现\n\n<!--more-->\n\n## 第二章：阅读的层次\n\n四种层次的阅读，种类样样不同，而层次却是再高的层次也包含了较低层次的特性。\n\n第一层次的阅读：基础阅读（elementary reading）---如何认出一页中的一个个字，PS：该层次阅读所问的问题是:“这个句子在说什么？”\n\n第二层次的阅读：检视阅读（inspectional reading）（也叫略读或预读）---特点在强调时间，在一定时间内，抓出一本书的重点，通常很短，总是过短难以掌握一本书的所以重点，但是我们的目标是从表面去观察这本书，学习到光是书的表象所教给你的一切，这笔交易通常是很划得来的。PS该层次要问的问题是:“这本书在谈什么？”“这本书的架构如何？”“这本书包含哪些部分？”  \n\n第三层次的阅读：分析阅读（analytical reading）（也就是全盘阅读。完整阅读或优质阅读）----更复杂、更系统化，重点在于分析阅读中，读者一定会对自己所读的东西提出许多有系统的问题。抓住一本书，直到这本书成为他自己为之。  \n\n第四层次的阅读：主题阅读（syntopical reading ）（也叫比较阅读）----最复杂最系统化的阅读，要求非常多。主题阅读时，会读很多书而不是一本书，并列举这些书之间相关之处，提出一个所有的书都谈到的主题，并且涉及的远不止此，借助所阅读的书籍，主题阅读者要能够构架出一个可能在哪一本书里都没提过的主题分析。因此是最主动也最花力气的一种阅读。\n\n## 第三章：阅读的第一个层次：基础阅读\n\n不同的基础阅读教学法：ABC教学法、发音法、视觉法、\n\n较新的比较重要的阅读教学法：折中教学法、个别阅读教学法、语言经验教学法，除此之外，初期教学字母，全神贯注教学法、外国语言学校教法、看说、看与说、看到就说、、、\n\n**学习阅读的阶段：**\n\n- 第一阶段：“阅读准备阶段”-----身体、智力、语言方面的准备以及个人的准备（包括与其他孩子一起学习的能力，保持注意力和服从等）\n- 第二阶段：认字---学习读一些简单的读物  \n- 第三阶段：快速建立字汇的能力---字汇的增长及对课文的运用\n- 第四阶段：精炼与增进前面所学的技巧 \n\n只有当一个孩子精通基础阅读的四个阶段，才准备好往更高层次的阅读迈进，只有当能自己阅读时，才能够自己开始学习。也只有这样才能变成一个真正的阅读者。\n\n更高的层次的阅读与高等教育----对于矫正阅读指导并不算指导，它只是把学生带到一个他在小学毕业的时候所该具备的阅读能力的程度。\n\n阅读与民主教育的理念-----无限制的受教育机会是一个社会能提供给人民最有价值的服务，只有当一个人的自我期许，能力与需要受限制时，教育机会才会收到限制。\n\n## 第四章：阅读的第二个层次：检视阅读\n\n\n检视阅读的两种方法（可以同时运用两种步骤）： \n\n### 检视阅读一：有系统的略读或粗读\n\n\n如何去做的一些建议：\n\n1. 先看书名页，然后有序先看序  \n2. 研究目录页  \n3. 如果书中有索引，也要检阅一下 \n4. \n   如果是本新书，不妨读一下出版者的介绍  \n5. 从你对一本书的目录很概略，甚至有些模糊的印象中，开始挑几个看来跟主题息息相关的篇章来看  \n6. 最后一步，把书打开，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多，用这个方法吧全书翻过一遍。以及书最后结尾的两三页。\n\n### 检视阅读二：粗浅的阅读\n\n 一个很重要又很有帮助的阅读规则：头一次面对一本难读的书的时候，从头到尾先读一遍，碰到不懂的地方不要停下来查询或思考，只注意你能理解的部分，不要为一些没法立即了解的东西而停顿，继续读下去，略过那些不懂的部分。很快你会看到你看的懂得地方，集中精神在这部分，继续读下去，将全书读完。避免自己被一个看不懂的章节注解评论或参考资料困住。  \n\n阅读的速度------理想上来说，不只是要能读得快，还要能用不同的速度来阅读，要知道什么时候用什么样的速度是恰当的。\n\n逗留与倒推-----矫正阅读速度可以利用双手训练自己的眼睛：将大拇指与食指、中指合并在一起，用这个“指针”顺着一行一行的字移动下去，速度要比你眼睛感觉的还要快一点。强迫自己的眼睛跟着手部的运动移动。继续练习增快手的动作，等到你发觉以前，你的速度已经可以比以前快两三倍了。\n理解力的问题----一个读者要能够正确地回答许多更进一步的问题，才表示能有更高一层的理解力。分析阅读，是想要理解（了解）一本书的基本条件。\n\n检视阅读的摘要----以上内容概括\n\n## 第五章：如何做一个自我要求的读者\n\n 在阅读时想要保持清醒或昏昏入睡，主要看你的阅读目标是什么。--------如果你的阅读目标是获得利益，不论是心灵或精神上的成长，你就得保持清醒。也就意味着阅读时要尽可能地保持主动，还要做一番努力。（主动阅读）  \n\n\n**主动阅读的基础：一个阅读者要提出的四个基本问题（这是阅读的基本规则）**\n\n1. 整体来说，这本书到底在谈些什么？\n2. \n   作者细部说了什么，怎么说的？一定要想办法找到主要得想法、声明与论点。这些组合成作者想要传达带的特殊讯息。  \n3. 这本书说的有道理么？是全部有道理，还是部分有道理？-----必须要在回答前两个问题之后才能回答，否则是不行的，在判断这本书是否有道理之前必须先了解这本书在说些什么才行  \n4. 这本书跟你有什么关系？-----如果这本书给了你一些讯息，一定要问问这些资讯有什么意义？为何作者会认为知道这些事很重要？你真的有必要去了解么？如果不只是提供了资讯，还启发了你，更有必要找到其他相关的、更深的含义或建议，以获得启示。  \n\n任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题（然后尽你可能地找出答案）\n\n\n**如何让一本书真正的属于自己**-------书成为你的一部分和你成为书的一部分是同一件事，就是要去写下来。\n\n\n**那么为什么阅读时在书上做笔记是不可或缺的事？**\n\n1. 那会让你保持清醒  \n2. 阅读，如果是主动的，那就是一种思考，而思考倾向于用语言表达出来，不管是讲还是写的，一个人如果说他知道自己在想些什么，但是说不出来。那通常是他自己并不知道自己在想些什么  \n3. 将你的感想写下来，能帮助你记住作者的思想    \n\n\n**阅读一本书应该像与作者之间的对话，那么就需要在这个双相沟通的过程中提问题，向自己提问题，也要向老师提问题。**\n\n在书上做笔记就是在表达跟作者之间相同或相异的观点。那么做笔记呢？有以下几个方法：  \n\n1. 画底线  \n2. 在画底线处的栏外再加画一道线  \n3. 在空白处做星号或其他符号----注意只用来强调书中十来个最重要的声明或段落即可  \n4. 在空白处编号-----帮助记录作者的某个论点发展的一连串的重要陈述  \n5. 在空白处记下其他页码----强调作者书中其他部分同样或相关的要点、或与此处观点不同的地方，便于将散步全书的想法统一集中起来。  \n6. 将关键字或句子圈起来  \n7. 在书页的空白处做笔记--------可以是问题，也可以是讲复杂的论点进行简化说明。  \n\n\n**三种做笔记的方法-------用那种完全依你阅读的层次而定** \n\n1. 结构笔记-----要记的重点是全书的架构，而不是内容，至少不是细节，比如检视阅读中回答的问题：\n   - 第一，这是什么样的一本书？  \n   - 第二，整本书在谈的是什么？  \n   - 第三，作者是借着怎样的整体架构来发展他的观点或者去陈述他对这个主题的理解。   \n2. 概念笔记----当做分析阅读时，关于这本书准确性与意义的问题，就要提出自己的答案了，那么此时的笔记不再跟结构有关而是概念，这些概念是作者的观点，而当你读得越深越广时，便也会出现你自己的观点了。  \n3. 辩证笔记-------从好多本书中摘要，用单独的一张纸来记载，再用上概念的结构--就一个单一主题，将所有相关的陈述和疑问顺序而列。\n\n\n**培养阅读的习惯：**\n\n要养成习惯，除了不断地运作练习别无他法。也就是常说的从实际去做中学习到如何去做的道理。\n\n 所谓艺术或技巧，只属于哪个能养成习惯，并且能依照规则来运作的人。对于规则是否了解得够清楚，是能不能拥有技巧的关键。\n\n由许多规则中养成一个习惯：\n\n每一个分开来的步骤都需要你全神贯注地去做。在你分别练习过这些分开来的步骤以后，你不但能放下你的注意力，很有效地将每一个步骤做好，还能将所有的动作结合起来，表现出一个整体的顺畅动作。--------这是学习一种复杂技巧的基本知识。\n\n规则的多样化，意味着要养成一个习惯的复杂度，而非表示要形成许多个不同的习惯。在到达一个程度时，每个分开的动作自然会压缩、连结起来，变成一个完整的动作。当所有相关动作都能相当自然地做出来时，你就养成做这件事的习惯了。","source":"_posts/如何阅读一本书.md","raw":"---\ntitle: 如何阅读一本书？\ndate: 2021-01-07 15:59:11\ncategories: 阅读\ntags: \n  - 读书\ncomments: false\ndescription: \n\n---\n\n# 第一篇：阅读的层次：\n\n## 第一章：阅读的活力与艺术\n\n这本书最主要的目的：让我们懂得如何让书本来教导我们。如果我们打算继续学习与发现\n\n<!--more-->\n\n## 第二章：阅读的层次\n\n四种层次的阅读，种类样样不同，而层次却是再高的层次也包含了较低层次的特性。\n\n第一层次的阅读：基础阅读（elementary reading）---如何认出一页中的一个个字，PS：该层次阅读所问的问题是:“这个句子在说什么？”\n\n第二层次的阅读：检视阅读（inspectional reading）（也叫略读或预读）---特点在强调时间，在一定时间内，抓出一本书的重点，通常很短，总是过短难以掌握一本书的所以重点，但是我们的目标是从表面去观察这本书，学习到光是书的表象所教给你的一切，这笔交易通常是很划得来的。PS该层次要问的问题是:“这本书在谈什么？”“这本书的架构如何？”“这本书包含哪些部分？”  \n\n第三层次的阅读：分析阅读（analytical reading）（也就是全盘阅读。完整阅读或优质阅读）----更复杂、更系统化，重点在于分析阅读中，读者一定会对自己所读的东西提出许多有系统的问题。抓住一本书，直到这本书成为他自己为之。  \n\n第四层次的阅读：主题阅读（syntopical reading ）（也叫比较阅读）----最复杂最系统化的阅读，要求非常多。主题阅读时，会读很多书而不是一本书，并列举这些书之间相关之处，提出一个所有的书都谈到的主题，并且涉及的远不止此，借助所阅读的书籍，主题阅读者要能够构架出一个可能在哪一本书里都没提过的主题分析。因此是最主动也最花力气的一种阅读。\n\n## 第三章：阅读的第一个层次：基础阅读\n\n不同的基础阅读教学法：ABC教学法、发音法、视觉法、\n\n较新的比较重要的阅读教学法：折中教学法、个别阅读教学法、语言经验教学法，除此之外，初期教学字母，全神贯注教学法、外国语言学校教法、看说、看与说、看到就说、、、\n\n**学习阅读的阶段：**\n\n- 第一阶段：“阅读准备阶段”-----身体、智力、语言方面的准备以及个人的准备（包括与其他孩子一起学习的能力，保持注意力和服从等）\n- 第二阶段：认字---学习读一些简单的读物  \n- 第三阶段：快速建立字汇的能力---字汇的增长及对课文的运用\n- 第四阶段：精炼与增进前面所学的技巧 \n\n只有当一个孩子精通基础阅读的四个阶段，才准备好往更高层次的阅读迈进，只有当能自己阅读时，才能够自己开始学习。也只有这样才能变成一个真正的阅读者。\n\n更高的层次的阅读与高等教育----对于矫正阅读指导并不算指导，它只是把学生带到一个他在小学毕业的时候所该具备的阅读能力的程度。\n\n阅读与民主教育的理念-----无限制的受教育机会是一个社会能提供给人民最有价值的服务，只有当一个人的自我期许，能力与需要受限制时，教育机会才会收到限制。\n\n## 第四章：阅读的第二个层次：检视阅读\n\n\n检视阅读的两种方法（可以同时运用两种步骤）： \n\n### 检视阅读一：有系统的略读或粗读\n\n\n如何去做的一些建议：\n\n1. 先看书名页，然后有序先看序  \n2. 研究目录页  \n3. 如果书中有索引，也要检阅一下 \n4. \n   如果是本新书，不妨读一下出版者的介绍  \n5. 从你对一本书的目录很概略，甚至有些模糊的印象中，开始挑几个看来跟主题息息相关的篇章来看  \n6. 最后一步，把书打开，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多，用这个方法吧全书翻过一遍。以及书最后结尾的两三页。\n\n### 检视阅读二：粗浅的阅读\n\n 一个很重要又很有帮助的阅读规则：头一次面对一本难读的书的时候，从头到尾先读一遍，碰到不懂的地方不要停下来查询或思考，只注意你能理解的部分，不要为一些没法立即了解的东西而停顿，继续读下去，略过那些不懂的部分。很快你会看到你看的懂得地方，集中精神在这部分，继续读下去，将全书读完。避免自己被一个看不懂的章节注解评论或参考资料困住。  \n\n阅读的速度------理想上来说，不只是要能读得快，还要能用不同的速度来阅读，要知道什么时候用什么样的速度是恰当的。\n\n逗留与倒推-----矫正阅读速度可以利用双手训练自己的眼睛：将大拇指与食指、中指合并在一起，用这个“指针”顺着一行一行的字移动下去，速度要比你眼睛感觉的还要快一点。强迫自己的眼睛跟着手部的运动移动。继续练习增快手的动作，等到你发觉以前，你的速度已经可以比以前快两三倍了。\n理解力的问题----一个读者要能够正确地回答许多更进一步的问题，才表示能有更高一层的理解力。分析阅读，是想要理解（了解）一本书的基本条件。\n\n检视阅读的摘要----以上内容概括\n\n## 第五章：如何做一个自我要求的读者\n\n 在阅读时想要保持清醒或昏昏入睡，主要看你的阅读目标是什么。--------如果你的阅读目标是获得利益，不论是心灵或精神上的成长，你就得保持清醒。也就意味着阅读时要尽可能地保持主动，还要做一番努力。（主动阅读）  \n\n\n**主动阅读的基础：一个阅读者要提出的四个基本问题（这是阅读的基本规则）**\n\n1. 整体来说，这本书到底在谈些什么？\n2. \n   作者细部说了什么，怎么说的？一定要想办法找到主要得想法、声明与论点。这些组合成作者想要传达带的特殊讯息。  \n3. 这本书说的有道理么？是全部有道理，还是部分有道理？-----必须要在回答前两个问题之后才能回答，否则是不行的，在判断这本书是否有道理之前必须先了解这本书在说些什么才行  \n4. 这本书跟你有什么关系？-----如果这本书给了你一些讯息，一定要问问这些资讯有什么意义？为何作者会认为知道这些事很重要？你真的有必要去了解么？如果不只是提供了资讯，还启发了你，更有必要找到其他相关的、更深的含义或建议，以获得启示。  \n\n任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题（然后尽你可能地找出答案）\n\n\n**如何让一本书真正的属于自己**-------书成为你的一部分和你成为书的一部分是同一件事，就是要去写下来。\n\n\n**那么为什么阅读时在书上做笔记是不可或缺的事？**\n\n1. 那会让你保持清醒  \n2. 阅读，如果是主动的，那就是一种思考，而思考倾向于用语言表达出来，不管是讲还是写的，一个人如果说他知道自己在想些什么，但是说不出来。那通常是他自己并不知道自己在想些什么  \n3. 将你的感想写下来，能帮助你记住作者的思想    \n\n\n**阅读一本书应该像与作者之间的对话，那么就需要在这个双相沟通的过程中提问题，向自己提问题，也要向老师提问题。**\n\n在书上做笔记就是在表达跟作者之间相同或相异的观点。那么做笔记呢？有以下几个方法：  \n\n1. 画底线  \n2. 在画底线处的栏外再加画一道线  \n3. 在空白处做星号或其他符号----注意只用来强调书中十来个最重要的声明或段落即可  \n4. 在空白处编号-----帮助记录作者的某个论点发展的一连串的重要陈述  \n5. 在空白处记下其他页码----强调作者书中其他部分同样或相关的要点、或与此处观点不同的地方，便于将散步全书的想法统一集中起来。  \n6. 将关键字或句子圈起来  \n7. 在书页的空白处做笔记--------可以是问题，也可以是讲复杂的论点进行简化说明。  \n\n\n**三种做笔记的方法-------用那种完全依你阅读的层次而定** \n\n1. 结构笔记-----要记的重点是全书的架构，而不是内容，至少不是细节，比如检视阅读中回答的问题：\n   - 第一，这是什么样的一本书？  \n   - 第二，整本书在谈的是什么？  \n   - 第三，作者是借着怎样的整体架构来发展他的观点或者去陈述他对这个主题的理解。   \n2. 概念笔记----当做分析阅读时，关于这本书准确性与意义的问题，就要提出自己的答案了，那么此时的笔记不再跟结构有关而是概念，这些概念是作者的观点，而当你读得越深越广时，便也会出现你自己的观点了。  \n3. 辩证笔记-------从好多本书中摘要，用单独的一张纸来记载，再用上概念的结构--就一个单一主题，将所有相关的陈述和疑问顺序而列。\n\n\n**培养阅读的习惯：**\n\n要养成习惯，除了不断地运作练习别无他法。也就是常说的从实际去做中学习到如何去做的道理。\n\n 所谓艺术或技巧，只属于哪个能养成习惯，并且能依照规则来运作的人。对于规则是否了解得够清楚，是能不能拥有技巧的关键。\n\n由许多规则中养成一个习惯：\n\n每一个分开来的步骤都需要你全神贯注地去做。在你分别练习过这些分开来的步骤以后，你不但能放下你的注意力，很有效地将每一个步骤做好，还能将所有的动作结合起来，表现出一个整体的顺畅动作。--------这是学习一种复杂技巧的基本知识。\n\n规则的多样化，意味着要养成一个习惯的复杂度，而非表示要形成许多个不同的习惯。在到达一个程度时，每个分开的动作自然会压缩、连结起来，变成一个完整的动作。当所有相关动作都能相当自然地做出来时，你就养成做这件事的习惯了。","slug":"如何阅读一本书","published":1,"updated":"2023-04-11T06:09:49.822Z","layout":"post","photos":[],"link":"","_id":"clgbv7k4o00018cob88lof603","content":"<h1 id=\"第一篇：阅读的层次：\"><a href=\"#第一篇：阅读的层次：\" class=\"headerlink\" title=\"第一篇：阅读的层次：\"></a>第一篇：阅读的层次：</h1><h2 id=\"第一章：阅读的活力与艺术\"><a href=\"#第一章：阅读的活力与艺术\" class=\"headerlink\" title=\"第一章：阅读的活力与艺术\"></a>第一章：阅读的活力与艺术</h2><p>这本书最主要的目的：让我们懂得如何让书本来教导我们。如果我们打算继续学习与发现</p>\n<span id=\"more\"></span>\n\n<h2 id=\"第二章：阅读的层次\"><a href=\"#第二章：阅读的层次\" class=\"headerlink\" title=\"第二章：阅读的层次\"></a>第二章：阅读的层次</h2><p>四种层次的阅读，种类样样不同，而层次却是再高的层次也包含了较低层次的特性。</p>\n<p>第一层次的阅读：基础阅读（elementary reading）—如何认出一页中的一个个字，PS：该层次阅读所问的问题是:“这个句子在说什么？”</p>\n<p>第二层次的阅读：检视阅读（inspectional reading）（也叫略读或预读）—特点在强调时间，在一定时间内，抓出一本书的重点，通常很短，总是过短难以掌握一本书的所以重点，但是我们的目标是从表面去观察这本书，学习到光是书的表象所教给你的一切，这笔交易通常是很划得来的。PS该层次要问的问题是:“这本书在谈什么？”“这本书的架构如何？”“这本书包含哪些部分？”  </p>\n<p>第三层次的阅读：分析阅读（analytical reading）（也就是全盘阅读。完整阅读或优质阅读）—-更复杂、更系统化，重点在于分析阅读中，读者一定会对自己所读的东西提出许多有系统的问题。抓住一本书，直到这本书成为他自己为之。  </p>\n<p>第四层次的阅读：主题阅读（syntopical reading ）（也叫比较阅读）—-最复杂最系统化的阅读，要求非常多。主题阅读时，会读很多书而不是一本书，并列举这些书之间相关之处，提出一个所有的书都谈到的主题，并且涉及的远不止此，借助所阅读的书籍，主题阅读者要能够构架出一个可能在哪一本书里都没提过的主题分析。因此是最主动也最花力气的一种阅读。</p>\n<h2 id=\"第三章：阅读的第一个层次：基础阅读\"><a href=\"#第三章：阅读的第一个层次：基础阅读\" class=\"headerlink\" title=\"第三章：阅读的第一个层次：基础阅读\"></a>第三章：阅读的第一个层次：基础阅读</h2><p>不同的基础阅读教学法：ABC教学法、发音法、视觉法、</p>\n<p>较新的比较重要的阅读教学法：折中教学法、个别阅读教学法、语言经验教学法，除此之外，初期教学字母，全神贯注教学法、外国语言学校教法、看说、看与说、看到就说、、、</p>\n<p><strong>学习阅读的阶段：</strong></p>\n<ul>\n<li>第一阶段：“阅读准备阶段”—–身体、智力、语言方面的准备以及个人的准备（包括与其他孩子一起学习的能力，保持注意力和服从等）</li>\n<li>第二阶段：认字—学习读一些简单的读物  </li>\n<li>第三阶段：快速建立字汇的能力—字汇的增长及对课文的运用</li>\n<li>第四阶段：精炼与增进前面所学的技巧</li>\n</ul>\n<p>只有当一个孩子精通基础阅读的四个阶段，才准备好往更高层次的阅读迈进，只有当能自己阅读时，才能够自己开始学习。也只有这样才能变成一个真正的阅读者。</p>\n<p>更高的层次的阅读与高等教育—-对于矫正阅读指导并不算指导，它只是把学生带到一个他在小学毕业的时候所该具备的阅读能力的程度。</p>\n<p>阅读与民主教育的理念—–无限制的受教育机会是一个社会能提供给人民最有价值的服务，只有当一个人的自我期许，能力与需要受限制时，教育机会才会收到限制。</p>\n<h2 id=\"第四章：阅读的第二个层次：检视阅读\"><a href=\"#第四章：阅读的第二个层次：检视阅读\" class=\"headerlink\" title=\"第四章：阅读的第二个层次：检视阅读\"></a>第四章：阅读的第二个层次：检视阅读</h2><p>检视阅读的两种方法（可以同时运用两种步骤）： </p>\n<h3 id=\"检视阅读一：有系统的略读或粗读\"><a href=\"#检视阅读一：有系统的略读或粗读\" class=\"headerlink\" title=\"检视阅读一：有系统的略读或粗读\"></a>检视阅读一：有系统的略读或粗读</h3><p>如何去做的一些建议：</p>\n<ol>\n<li>先看书名页，然后有序先看序  </li>\n<li>研究目录页  </li>\n<li>如果书中有索引，也要检阅一下 </li>\n<li>如果是本新书，不妨读一下出版者的介绍  </li>\n<li>从你对一本书的目录很概略，甚至有些模糊的印象中，开始挑几个看来跟主题息息相关的篇章来看  </li>\n<li>最后一步，把书打开，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多，用这个方法吧全书翻过一遍。以及书最后结尾的两三页。</li>\n</ol>\n<h3 id=\"检视阅读二：粗浅的阅读\"><a href=\"#检视阅读二：粗浅的阅读\" class=\"headerlink\" title=\"检视阅读二：粗浅的阅读\"></a>检视阅读二：粗浅的阅读</h3><p> 一个很重要又很有帮助的阅读规则：头一次面对一本难读的书的时候，从头到尾先读一遍，碰到不懂的地方不要停下来查询或思考，只注意你能理解的部分，不要为一些没法立即了解的东西而停顿，继续读下去，略过那些不懂的部分。很快你会看到你看的懂得地方，集中精神在这部分，继续读下去，将全书读完。避免自己被一个看不懂的章节注解评论或参考资料困住。  </p>\n<p>阅读的速度——理想上来说，不只是要能读得快，还要能用不同的速度来阅读，要知道什么时候用什么样的速度是恰当的。</p>\n<p>逗留与倒推—–矫正阅读速度可以利用双手训练自己的眼睛：将大拇指与食指、中指合并在一起，用这个“指针”顺着一行一行的字移动下去，速度要比你眼睛感觉的还要快一点。强迫自己的眼睛跟着手部的运动移动。继续练习增快手的动作，等到你发觉以前，你的速度已经可以比以前快两三倍了。<br>理解力的问题—-一个读者要能够正确地回答许多更进一步的问题，才表示能有更高一层的理解力。分析阅读，是想要理解（了解）一本书的基本条件。</p>\n<p>检视阅读的摘要—-以上内容概括</p>\n<h2 id=\"第五章：如何做一个自我要求的读者\"><a href=\"#第五章：如何做一个自我要求的读者\" class=\"headerlink\" title=\"第五章：如何做一个自我要求的读者\"></a>第五章：如何做一个自我要求的读者</h2><p> 在阅读时想要保持清醒或昏昏入睡，主要看你的阅读目标是什么。——–如果你的阅读目标是获得利益，不论是心灵或精神上的成长，你就得保持清醒。也就意味着阅读时要尽可能地保持主动，还要做一番努力。（主动阅读）  </p>\n<p><strong>主动阅读的基础：一个阅读者要提出的四个基本问题（这是阅读的基本规则）</strong></p>\n<ol>\n<li>整体来说，这本书到底在谈些什么？</li>\n<li>作者细部说了什么，怎么说的？一定要想办法找到主要得想法、声明与论点。这些组合成作者想要传达带的特殊讯息。  </li>\n<li>这本书说的有道理么？是全部有道理，还是部分有道理？—–必须要在回答前两个问题之后才能回答，否则是不行的，在判断这本书是否有道理之前必须先了解这本书在说些什么才行  </li>\n<li>这本书跟你有什么关系？—–如果这本书给了你一些讯息，一定要问问这些资讯有什么意义？为何作者会认为知道这些事很重要？你真的有必要去了解么？如果不只是提供了资讯，还启发了你，更有必要找到其他相关的、更深的含义或建议，以获得启示。</li>\n</ol>\n<p>任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题（然后尽你可能地找出答案）</p>\n<p><strong>如何让一本书真正的属于自己</strong>——-书成为你的一部分和你成为书的一部分是同一件事，就是要去写下来。</p>\n<p><strong>那么为什么阅读时在书上做笔记是不可或缺的事？</strong></p>\n<ol>\n<li>那会让你保持清醒  </li>\n<li>阅读，如果是主动的，那就是一种思考，而思考倾向于用语言表达出来，不管是讲还是写的，一个人如果说他知道自己在想些什么，但是说不出来。那通常是他自己并不知道自己在想些什么  </li>\n<li>将你的感想写下来，能帮助你记住作者的思想</li>\n</ol>\n<p><strong>阅读一本书应该像与作者之间的对话，那么就需要在这个双相沟通的过程中提问题，向自己提问题，也要向老师提问题。</strong></p>\n<p>在书上做笔记就是在表达跟作者之间相同或相异的观点。那么做笔记呢？有以下几个方法：  </p>\n<ol>\n<li>画底线  </li>\n<li>在画底线处的栏外再加画一道线  </li>\n<li>在空白处做星号或其他符号—-注意只用来强调书中十来个最重要的声明或段落即可  </li>\n<li>在空白处编号—–帮助记录作者的某个论点发展的一连串的重要陈述  </li>\n<li>在空白处记下其他页码—-强调作者书中其他部分同样或相关的要点、或与此处观点不同的地方，便于将散步全书的想法统一集中起来。  </li>\n<li>将关键字或句子圈起来  </li>\n<li>在书页的空白处做笔记——–可以是问题，也可以是讲复杂的论点进行简化说明。</li>\n</ol>\n<p><strong>三种做笔记的方法——-用那种完全依你阅读的层次而定</strong> </p>\n<ol>\n<li>结构笔记—–要记的重点是全书的架构，而不是内容，至少不是细节，比如检视阅读中回答的问题：<ul>\n<li>第一，这是什么样的一本书？  </li>\n<li>第二，整本书在谈的是什么？  </li>\n<li>第三，作者是借着怎样的整体架构来发展他的观点或者去陈述他对这个主题的理解。</li>\n</ul>\n</li>\n<li>概念笔记—-当做分析阅读时，关于这本书准确性与意义的问题，就要提出自己的答案了，那么此时的笔记不再跟结构有关而是概念，这些概念是作者的观点，而当你读得越深越广时，便也会出现你自己的观点了。  </li>\n<li>辩证笔记——-从好多本书中摘要，用单独的一张纸来记载，再用上概念的结构–就一个单一主题，将所有相关的陈述和疑问顺序而列。</li>\n</ol>\n<p><strong>培养阅读的习惯：</strong></p>\n<p>要养成习惯，除了不断地运作练习别无他法。也就是常说的从实际去做中学习到如何去做的道理。</p>\n<p> 所谓艺术或技巧，只属于哪个能养成习惯，并且能依照规则来运作的人。对于规则是否了解得够清楚，是能不能拥有技巧的关键。</p>\n<p>由许多规则中养成一个习惯：</p>\n<p>每一个分开来的步骤都需要你全神贯注地去做。在你分别练习过这些分开来的步骤以后，你不但能放下你的注意力，很有效地将每一个步骤做好，还能将所有的动作结合起来，表现出一个整体的顺畅动作。——–这是学习一种复杂技巧的基本知识。</p>\n<p>规则的多样化，意味着要养成一个习惯的复杂度，而非表示要形成许多个不同的习惯。在到达一个程度时，每个分开的动作自然会压缩、连结起来，变成一个完整的动作。当所有相关动作都能相当自然地做出来时，你就养成做这件事的习惯了。</p>\n","site":{"data":{"style":""}},"length":3302,"excerpt":"<h1 id=\"第一篇：阅读的层次：\"><a href=\"#第一篇：阅读的层次：\" class=\"headerlink\" title=\"第一篇：阅读的层次：\"></a>第一篇：阅读的层次：</h1><h2 id=\"第一章：阅读的活力与艺术\"><a href=\"#第一章：阅读的活力与艺术\" class=\"headerlink\" title=\"第一章：阅读的活力与艺术\"></a>第一章：阅读的活力与艺术</h2><p>这本书最主要的目的：让我们懂得如何让书本来教导我们。如果我们打算继续学习与发现</p>","more":"<h2 id=\"第二章：阅读的层次\"><a href=\"#第二章：阅读的层次\" class=\"headerlink\" title=\"第二章：阅读的层次\"></a>第二章：阅读的层次</h2><p>四种层次的阅读，种类样样不同，而层次却是再高的层次也包含了较低层次的特性。</p>\n<p>第一层次的阅读：基础阅读（elementary reading）—如何认出一页中的一个个字，PS：该层次阅读所问的问题是:“这个句子在说什么？”</p>\n<p>第二层次的阅读：检视阅读（inspectional reading）（也叫略读或预读）—特点在强调时间，在一定时间内，抓出一本书的重点，通常很短，总是过短难以掌握一本书的所以重点，但是我们的目标是从表面去观察这本书，学习到光是书的表象所教给你的一切，这笔交易通常是很划得来的。PS该层次要问的问题是:“这本书在谈什么？”“这本书的架构如何？”“这本书包含哪些部分？”  </p>\n<p>第三层次的阅读：分析阅读（analytical reading）（也就是全盘阅读。完整阅读或优质阅读）—-更复杂、更系统化，重点在于分析阅读中，读者一定会对自己所读的东西提出许多有系统的问题。抓住一本书，直到这本书成为他自己为之。  </p>\n<p>第四层次的阅读：主题阅读（syntopical reading ）（也叫比较阅读）—-最复杂最系统化的阅读，要求非常多。主题阅读时，会读很多书而不是一本书，并列举这些书之间相关之处，提出一个所有的书都谈到的主题，并且涉及的远不止此，借助所阅读的书籍，主题阅读者要能够构架出一个可能在哪一本书里都没提过的主题分析。因此是最主动也最花力气的一种阅读。</p>\n<h2 id=\"第三章：阅读的第一个层次：基础阅读\"><a href=\"#第三章：阅读的第一个层次：基础阅读\" class=\"headerlink\" title=\"第三章：阅读的第一个层次：基础阅读\"></a>第三章：阅读的第一个层次：基础阅读</h2><p>不同的基础阅读教学法：ABC教学法、发音法、视觉法、</p>\n<p>较新的比较重要的阅读教学法：折中教学法、个别阅读教学法、语言经验教学法，除此之外，初期教学字母，全神贯注教学法、外国语言学校教法、看说、看与说、看到就说、、、</p>\n<p><strong>学习阅读的阶段：</strong></p>\n<ul>\n<li>第一阶段：“阅读准备阶段”—–身体、智力、语言方面的准备以及个人的准备（包括与其他孩子一起学习的能力，保持注意力和服从等）</li>\n<li>第二阶段：认字—学习读一些简单的读物  </li>\n<li>第三阶段：快速建立字汇的能力—字汇的增长及对课文的运用</li>\n<li>第四阶段：精炼与增进前面所学的技巧</li>\n</ul>\n<p>只有当一个孩子精通基础阅读的四个阶段，才准备好往更高层次的阅读迈进，只有当能自己阅读时，才能够自己开始学习。也只有这样才能变成一个真正的阅读者。</p>\n<p>更高的层次的阅读与高等教育—-对于矫正阅读指导并不算指导，它只是把学生带到一个他在小学毕业的时候所该具备的阅读能力的程度。</p>\n<p>阅读与民主教育的理念—–无限制的受教育机会是一个社会能提供给人民最有价值的服务，只有当一个人的自我期许，能力与需要受限制时，教育机会才会收到限制。</p>\n<h2 id=\"第四章：阅读的第二个层次：检视阅读\"><a href=\"#第四章：阅读的第二个层次：检视阅读\" class=\"headerlink\" title=\"第四章：阅读的第二个层次：检视阅读\"></a>第四章：阅读的第二个层次：检视阅读</h2><p>检视阅读的两种方法（可以同时运用两种步骤）： </p>\n<h3 id=\"检视阅读一：有系统的略读或粗读\"><a href=\"#检视阅读一：有系统的略读或粗读\" class=\"headerlink\" title=\"检视阅读一：有系统的略读或粗读\"></a>检视阅读一：有系统的略读或粗读</h3><p>如何去做的一些建议：</p>\n<ol>\n<li>先看书名页，然后有序先看序  </li>\n<li>研究目录页  </li>\n<li>如果书中有索引，也要检阅一下 </li>\n<li>如果是本新书，不妨读一下出版者的介绍  </li>\n<li>从你对一本书的目录很概略，甚至有些模糊的印象中，开始挑几个看来跟主题息息相关的篇章来看  </li>\n<li>最后一步，把书打开，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多，用这个方法吧全书翻过一遍。以及书最后结尾的两三页。</li>\n</ol>\n<h3 id=\"检视阅读二：粗浅的阅读\"><a href=\"#检视阅读二：粗浅的阅读\" class=\"headerlink\" title=\"检视阅读二：粗浅的阅读\"></a>检视阅读二：粗浅的阅读</h3><p> 一个很重要又很有帮助的阅读规则：头一次面对一本难读的书的时候，从头到尾先读一遍，碰到不懂的地方不要停下来查询或思考，只注意你能理解的部分，不要为一些没法立即了解的东西而停顿，继续读下去，略过那些不懂的部分。很快你会看到你看的懂得地方，集中精神在这部分，继续读下去，将全书读完。避免自己被一个看不懂的章节注解评论或参考资料困住。  </p>\n<p>阅读的速度——理想上来说，不只是要能读得快，还要能用不同的速度来阅读，要知道什么时候用什么样的速度是恰当的。</p>\n<p>逗留与倒推—–矫正阅读速度可以利用双手训练自己的眼睛：将大拇指与食指、中指合并在一起，用这个“指针”顺着一行一行的字移动下去，速度要比你眼睛感觉的还要快一点。强迫自己的眼睛跟着手部的运动移动。继续练习增快手的动作，等到你发觉以前，你的速度已经可以比以前快两三倍了。<br>理解力的问题—-一个读者要能够正确地回答许多更进一步的问题，才表示能有更高一层的理解力。分析阅读，是想要理解（了解）一本书的基本条件。</p>\n<p>检视阅读的摘要—-以上内容概括</p>\n<h2 id=\"第五章：如何做一个自我要求的读者\"><a href=\"#第五章：如何做一个自我要求的读者\" class=\"headerlink\" title=\"第五章：如何做一个自我要求的读者\"></a>第五章：如何做一个自我要求的读者</h2><p> 在阅读时想要保持清醒或昏昏入睡，主要看你的阅读目标是什么。——–如果你的阅读目标是获得利益，不论是心灵或精神上的成长，你就得保持清醒。也就意味着阅读时要尽可能地保持主动，还要做一番努力。（主动阅读）  </p>\n<p><strong>主动阅读的基础：一个阅读者要提出的四个基本问题（这是阅读的基本规则）</strong></p>\n<ol>\n<li>整体来说，这本书到底在谈些什么？</li>\n<li>作者细部说了什么，怎么说的？一定要想办法找到主要得想法、声明与论点。这些组合成作者想要传达带的特殊讯息。  </li>\n<li>这本书说的有道理么？是全部有道理，还是部分有道理？—–必须要在回答前两个问题之后才能回答，否则是不行的，在判断这本书是否有道理之前必须先了解这本书在说些什么才行  </li>\n<li>这本书跟你有什么关系？—–如果这本书给了你一些讯息，一定要问问这些资讯有什么意义？为何作者会认为知道这些事很重要？你真的有必要去了解么？如果不只是提供了资讯，还启发了你，更有必要找到其他相关的、更深的含义或建议，以获得启示。</li>\n</ol>\n<p>任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题（然后尽你可能地找出答案）</p>\n<p><strong>如何让一本书真正的属于自己</strong>——-书成为你的一部分和你成为书的一部分是同一件事，就是要去写下来。</p>\n<p><strong>那么为什么阅读时在书上做笔记是不可或缺的事？</strong></p>\n<ol>\n<li>那会让你保持清醒  </li>\n<li>阅读，如果是主动的，那就是一种思考，而思考倾向于用语言表达出来，不管是讲还是写的，一个人如果说他知道自己在想些什么，但是说不出来。那通常是他自己并不知道自己在想些什么  </li>\n<li>将你的感想写下来，能帮助你记住作者的思想</li>\n</ol>\n<p><strong>阅读一本书应该像与作者之间的对话，那么就需要在这个双相沟通的过程中提问题，向自己提问题，也要向老师提问题。</strong></p>\n<p>在书上做笔记就是在表达跟作者之间相同或相异的观点。那么做笔记呢？有以下几个方法：  </p>\n<ol>\n<li>画底线  </li>\n<li>在画底线处的栏外再加画一道线  </li>\n<li>在空白处做星号或其他符号—-注意只用来强调书中十来个最重要的声明或段落即可  </li>\n<li>在空白处编号—–帮助记录作者的某个论点发展的一连串的重要陈述  </li>\n<li>在空白处记下其他页码—-强调作者书中其他部分同样或相关的要点、或与此处观点不同的地方，便于将散步全书的想法统一集中起来。  </li>\n<li>将关键字或句子圈起来  </li>\n<li>在书页的空白处做笔记——–可以是问题，也可以是讲复杂的论点进行简化说明。</li>\n</ol>\n<p><strong>三种做笔记的方法——-用那种完全依你阅读的层次而定</strong> </p>\n<ol>\n<li>结构笔记—–要记的重点是全书的架构，而不是内容，至少不是细节，比如检视阅读中回答的问题：<ul>\n<li>第一，这是什么样的一本书？  </li>\n<li>第二，整本书在谈的是什么？  </li>\n<li>第三，作者是借着怎样的整体架构来发展他的观点或者去陈述他对这个主题的理解。</li>\n</ul>\n</li>\n<li>概念笔记—-当做分析阅读时，关于这本书准确性与意义的问题，就要提出自己的答案了，那么此时的笔记不再跟结构有关而是概念，这些概念是作者的观点，而当你读得越深越广时，便也会出现你自己的观点了。  </li>\n<li>辩证笔记——-从好多本书中摘要，用单独的一张纸来记载，再用上概念的结构–就一个单一主题，将所有相关的陈述和疑问顺序而列。</li>\n</ol>\n<p><strong>培养阅读的习惯：</strong></p>\n<p>要养成习惯，除了不断地运作练习别无他法。也就是常说的从实际去做中学习到如何去做的道理。</p>\n<p> 所谓艺术或技巧，只属于哪个能养成习惯，并且能依照规则来运作的人。对于规则是否了解得够清楚，是能不能拥有技巧的关键。</p>\n<p>由许多规则中养成一个习惯：</p>\n<p>每一个分开来的步骤都需要你全神贯注地去做。在你分别练习过这些分开来的步骤以后，你不但能放下你的注意力，很有效地将每一个步骤做好，还能将所有的动作结合起来，表现出一个整体的顺畅动作。——–这是学习一种复杂技巧的基本知识。</p>\n<p>规则的多样化，意味着要养成一个习惯的复杂度，而非表示要形成许多个不同的习惯。在到达一个程度时，每个分开的动作自然会压缩、连结起来，变成一个完整的动作。当所有相关动作都能相当自然地做出来时，你就养成做这件事的习惯了。</p>"},{"title":"更换电脑hexo环境如何快速重新搭建？","date":"2023-04-11T07:59:11.000Z","comments":0,"description":null,"_content":"\n## 1.安装Git(默认安装)\n\n下载网址https://git-scm.com/download/win\n\n<!--more-->\n\n## #2.克隆main主分支，\n\n```\n$ git clone -b main https://github.com/XXX/XXX.github.io.git\n```\n\n## 3.克隆hexo_bak分支，\n\n```\n$ git clone -b hexo_bak https://github.com/XXX/XXX.github.io.git\n```\n\n## 4.安装node.js(修改安装目录，默认安装)\n\n下载网址https://nodejs.org/en，\n\n## 5.用 node -v 和 npm -v 命令检查版本\n\n上述node.js安装成功之后，npm同时也已经安装成功，用 node -v 和 npm -v 命令检查版本\n\n## 6.配置npm在安装全局模块时的路径和缓存cache的路径\n\n否则默认安装在C盘，不方便管理且占用C盘空间\n\t1，在node.js安装目录下新建两个文件夹 node_global和node_cache\n\t2，在git bush命令下执行如下两个命令：\n\n```c\n\tnpm config set prefix \"F:\\Blogs\\nodejs\\node_global\"\n\tnpm config set cache \"F:\\Blogs\\nodejs\\node_cache\"\n```\n\n​\t3，在环境变量 -> 系统变量中新建一个变量名为 “NODE_PATH”， 值为“F:\\Blogs\\nodejs\\node_modules”，\n​\t4，最后编辑用户变量里的Path，将相应npm的路径改为：F:\\Blogs\\nodejs\\node_global，\n​\t5，在git bush命令下执行 \n\n```\nnpm install webpack -g\n```\n\n 然后安装成功后可以看到自定义的两个文件夹已生效：\n\t6，npm webpack -v 查看安装webpack的版本号\n\n## 7.输入npm命令安装Hexo：\n\n```c\nnpm install -g hexo-cli\n```\n\n## 8.安装完成后，输入 hexo init 命令初始化博客：\n\n## 9.然后输入 hexo g 静态部署： \n\n## 10.部署完成，输入hexo s 命令可以查看\n\n浏览器输入 http://localhost:4000 就可以打开新部署的网页：看完之后 ctrl +c 停止运行服务器。\n\n## 11.hexo命令\n\n```c\n\thexo init    //命令初始化博客：\n\thexo clean   //清除缓存文件 db.json 和已生成的静态文件 public\n\thexo g       //生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\n\thexo s       //命令可以查看新部署的网页,浏览器输入 http://localhost:4000\n\thexo d       //自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\n```\n\n## 12.绑定GitHub\n\n​\t1.输入 ssh 命令，查看本机是否安装 SSH：ssh\n​\t2.输入 ssh-keygen -t rsa 命令（注意空格），指定 RSA 算法生成密钥，然后敲四次回车键，生成两个文件:秘钥 id_rsa 和公钥 id_rsa.pub. \n​\t3.将公钥 id_rsa.pub 的内容添加到 GitHub->settings->SSH and GPG keys-> New SSH key.\n​\t4.在 Git Bash 中输入 ssh -T git@github.com 进行检验\n\n## 13.将博客部署到设定的git仓库主分支main\n\n​\t安装Git部署插件npm install hexo-deployer-git --save(删除原.deploy_git文件夹，hexo g后重新生成)\n​\thexo clean   #清除缓存文件 db.json 和已生成的静态文件 public\n​\thexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\n​\thexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\n\n## 14.备份hexo到git分支hexo_bak\n\n​\t1.添加所有文件夹和文件到本地仓库\n\n```\ngit add .\n```\n\n​\t2.提交文件\n\n```\ngit commit -m \"提交注释\"\n```\n\n​\t3.push到git分支\n\n```\ngit push --set-upstream origin hexo_bak\n```\n\n","source":"_posts/hexo环境重新快速搭建.md","raw":"---\ntitle: 更换电脑hexo环境如何快速重新搭建？\ndate: 2023-4-11 15:59:11\ncategories: 笔记\ntags: \ncomments: false\ndescription: \n\n---\n\n## 1.安装Git(默认安装)\n\n下载网址https://git-scm.com/download/win\n\n<!--more-->\n\n## #2.克隆main主分支，\n\n```\n$ git clone -b main https://github.com/XXX/XXX.github.io.git\n```\n\n## 3.克隆hexo_bak分支，\n\n```\n$ git clone -b hexo_bak https://github.com/XXX/XXX.github.io.git\n```\n\n## 4.安装node.js(修改安装目录，默认安装)\n\n下载网址https://nodejs.org/en，\n\n## 5.用 node -v 和 npm -v 命令检查版本\n\n上述node.js安装成功之后，npm同时也已经安装成功，用 node -v 和 npm -v 命令检查版本\n\n## 6.配置npm在安装全局模块时的路径和缓存cache的路径\n\n否则默认安装在C盘，不方便管理且占用C盘空间\n\t1，在node.js安装目录下新建两个文件夹 node_global和node_cache\n\t2，在git bush命令下执行如下两个命令：\n\n```c\n\tnpm config set prefix \"F:\\Blogs\\nodejs\\node_global\"\n\tnpm config set cache \"F:\\Blogs\\nodejs\\node_cache\"\n```\n\n​\t3，在环境变量 -> 系统变量中新建一个变量名为 “NODE_PATH”， 值为“F:\\Blogs\\nodejs\\node_modules”，\n​\t4，最后编辑用户变量里的Path，将相应npm的路径改为：F:\\Blogs\\nodejs\\node_global，\n​\t5，在git bush命令下执行 \n\n```\nnpm install webpack -g\n```\n\n 然后安装成功后可以看到自定义的两个文件夹已生效：\n\t6，npm webpack -v 查看安装webpack的版本号\n\n## 7.输入npm命令安装Hexo：\n\n```c\nnpm install -g hexo-cli\n```\n\n## 8.安装完成后，输入 hexo init 命令初始化博客：\n\n## 9.然后输入 hexo g 静态部署： \n\n## 10.部署完成，输入hexo s 命令可以查看\n\n浏览器输入 http://localhost:4000 就可以打开新部署的网页：看完之后 ctrl +c 停止运行服务器。\n\n## 11.hexo命令\n\n```c\n\thexo init    //命令初始化博客：\n\thexo clean   //清除缓存文件 db.json 和已生成的静态文件 public\n\thexo g       //生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\n\thexo s       //命令可以查看新部署的网页,浏览器输入 http://localhost:4000\n\thexo d       //自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\n```\n\n## 12.绑定GitHub\n\n​\t1.输入 ssh 命令，查看本机是否安装 SSH：ssh\n​\t2.输入 ssh-keygen -t rsa 命令（注意空格），指定 RSA 算法生成密钥，然后敲四次回车键，生成两个文件:秘钥 id_rsa 和公钥 id_rsa.pub. \n​\t3.将公钥 id_rsa.pub 的内容添加到 GitHub->settings->SSH and GPG keys-> New SSH key.\n​\t4.在 Git Bash 中输入 ssh -T git@github.com 进行检验\n\n## 13.将博客部署到设定的git仓库主分支main\n\n​\t安装Git部署插件npm install hexo-deployer-git --save(删除原.deploy_git文件夹，hexo g后重新生成)\n​\thexo clean   #清除缓存文件 db.json 和已生成的静态文件 public\n​\thexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\n​\thexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\n\n## 14.备份hexo到git分支hexo_bak\n\n​\t1.添加所有文件夹和文件到本地仓库\n\n```\ngit add .\n```\n\n​\t2.提交文件\n\n```\ngit commit -m \"提交注释\"\n```\n\n​\t3.push到git分支\n\n```\ngit push --set-upstream origin hexo_bak\n```\n\n","slug":"hexo环境重新快速搭建","published":1,"updated":"2023-04-11T08:24:02.734Z","_id":"clgbycqco0001s8obco3m00nq","layout":"post","photos":[],"link":"","content":"<h2 id=\"1-安装Git-默认安装\"><a href=\"#1-安装Git-默认安装\" class=\"headerlink\" title=\"1.安装Git(默认安装)\"></a>1.安装Git(默认安装)</h2><p>下载网址<a href=\"https://git-scm.com/download/win\">https://git-scm.com/download/win</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"2-克隆main主分支，\"><a href=\"#2-克隆main主分支，\" class=\"headerlink\" title=\"#2.克隆main主分支，\"></a>#2.克隆main主分支，</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone -b main https://github.com/XXX/XXX.github.io.git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-克隆hexo-bak分支，\"><a href=\"#3-克隆hexo-bak分支，\" class=\"headerlink\" title=\"3.克隆hexo_bak分支，\"></a>3.克隆hexo_bak分支，</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone -b hexo_bak https://github.com/XXX/XXX.github.io.git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-安装node-js-修改安装目录，默认安装\"><a href=\"#4-安装node-js-修改安装目录，默认安装\" class=\"headerlink\" title=\"4.安装node.js(修改安装目录，默认安装)\"></a>4.安装node.js(修改安装目录，默认安装)</h2><p>下载网址<a href=\"https://nodejs.org/en%EF%BC%8C\">https://nodejs.org/en，</a></p>\n<h2 id=\"5-用-node-v-和-npm-v-命令检查版本\"><a href=\"#5-用-node-v-和-npm-v-命令检查版本\" class=\"headerlink\" title=\"5.用 node -v 和 npm -v 命令检查版本\"></a>5.用 node -v 和 npm -v 命令检查版本</h2><p>上述node.js安装成功之后，npm同时也已经安装成功，用 node -v 和 npm -v 命令检查版本</p>\n<h2 id=\"6-配置npm在安装全局模块时的路径和缓存cache的路径\"><a href=\"#6-配置npm在安装全局模块时的路径和缓存cache的路径\" class=\"headerlink\" title=\"6.配置npm在安装全局模块时的路径和缓存cache的路径\"></a>6.配置npm在安装全局模块时的路径和缓存cache的路径</h2><p>否则默认安装在C盘，不方便管理且占用C盘空间<br>    1，在node.js安装目录下新建两个文件夹 node_global和node_cache<br>    2，在git bush命令下执行如下两个命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> prefix <span class=\"string\">&quot;F:\\Blogs\\nodejs\\node_global&quot;</span></span><br><span class=\"line\">npm config <span class=\"built_in\">set</span> cache <span class=\"string\">&quot;F:\\Blogs\\nodejs\\node_cache&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t3，在环境变量 -&gt; 系统变量中新建一个变量名为 “NODE_PATH”， 值为“F:\\Blogs\\nodejs\\node_modules”，<br>​\t4，最后编辑用户变量里的Path，将相应npm的路径改为：F:\\Blogs\\nodejs\\node_global，<br>​\t5，在git bush命令下执行 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack -g</span><br></pre></td></tr></table></figure>\n\n<p> 然后安装成功后可以看到自定义的两个文件夹已生效：<br>    6，npm webpack -v 查看安装webpack的版本号</p>\n<h2 id=\"7-输入npm命令安装Hexo：\"><a href=\"#7-输入npm命令安装Hexo：\" class=\"headerlink\" title=\"7.输入npm命令安装Hexo：\"></a>7.输入npm命令安装Hexo：</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-安装完成后，输入-hexo-init-命令初始化博客：\"><a href=\"#8-安装完成后，输入-hexo-init-命令初始化博客：\" class=\"headerlink\" title=\"8.安装完成后，输入 hexo init 命令初始化博客：\"></a>8.安装完成后，输入 hexo init 命令初始化博客：</h2><h2 id=\"9-然后输入-hexo-g-静态部署：\"><a href=\"#9-然后输入-hexo-g-静态部署：\" class=\"headerlink\" title=\"9.然后输入 hexo g 静态部署：\"></a>9.然后输入 hexo g 静态部署：</h2><h2 id=\"10-部署完成，输入hexo-s-命令可以查看\"><a href=\"#10-部署完成，输入hexo-s-命令可以查看\" class=\"headerlink\" title=\"10.部署完成，输入hexo s 命令可以查看\"></a>10.部署完成，输入hexo s 命令可以查看</h2><p>浏览器输入 <a href=\"http://localhost:4000/\">http://localhost:4000</a> 就可以打开新部署的网页：看完之后 ctrl +c 停止运行服务器。</p>\n<h2 id=\"11-hexo命令\"><a href=\"#11-hexo命令\" class=\"headerlink\" title=\"11.hexo命令\"></a>11.hexo命令</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init    <span class=\"comment\">//命令初始化博客：</span></span><br><span class=\"line\">hexo clean   <span class=\"comment\">//清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class=\"line\">hexo g       <span class=\"comment\">//生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class=\"line\">hexo s       <span class=\"comment\">//命令可以查看新部署的网页,浏览器输入 http://localhost:4000</span></span><br><span class=\"line\">hexo d       <span class=\"comment\">//自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-绑定GitHub\"><a href=\"#12-绑定GitHub\" class=\"headerlink\" title=\"12.绑定GitHub\"></a>12.绑定GitHub</h2><p>​\t1.输入 ssh 命令，查看本机是否安装 SSH：ssh<br>​\t2.输入 ssh-keygen -t rsa 命令（注意空格），指定 RSA 算法生成密钥，然后敲四次回车键，生成两个文件:秘钥 id_rsa 和公钥 id_rsa.pub.<br>​\t3.将公钥 id_rsa.pub 的内容添加到 GitHub-&gt;settings-&gt;SSH and GPG keys-&gt; New SSH key.<br>​\t4.在 Git Bash 中输入 ssh -T <a href=\"mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109;\">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109;</a> 进行检验</p>\n<h2 id=\"13-将博客部署到设定的git仓库主分支main\"><a href=\"#13-将博客部署到设定的git仓库主分支main\" class=\"headerlink\" title=\"13.将博客部署到设定的git仓库主分支main\"></a>13.将博客部署到设定的git仓库主分支main</h2><p>​\t安装Git部署插件npm install hexo-deployer-git –save(删除原.deploy_git文件夹，hexo g后重新生成)<br>​\thexo clean   #清除缓存文件 db.json 和已生成的静态文件 public<br>​\thexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)<br>​\thexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</p>\n<h2 id=\"14-备份hexo到git分支hexo-bak\"><a href=\"#14-备份hexo到git分支hexo-bak\" class=\"headerlink\" title=\"14.备份hexo到git分支hexo_bak\"></a>14.备份hexo到git分支hexo_bak</h2><p>​\t1.添加所有文件夹和文件到本地仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<p>​\t2.提交文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;提交注释&quot;</span><br></pre></td></tr></table></figure>\n\n<p>​\t3.push到git分支</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push --set-upstream origin hexo_bak</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"style":""}},"length":1775,"excerpt":"<h2 id=\"1-安装Git-默认安装\"><a href=\"#1-安装Git-默认安装\" class=\"headerlink\" title=\"1.安装Git(默认安装)\"></a>1.安装Git(默认安装)</h2><p>下载网址<a href=\"https://git-scm.com/download/win\">https://git-scm.com/download/win</a></p>","more":"<h2 id=\"2-克隆main主分支，\"><a href=\"#2-克隆main主分支，\" class=\"headerlink\" title=\"#2.克隆main主分支，\"></a>#2.克隆main主分支，</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone -b main https://github.com/XXX/XXX.github.io.git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-克隆hexo-bak分支，\"><a href=\"#3-克隆hexo-bak分支，\" class=\"headerlink\" title=\"3.克隆hexo_bak分支，\"></a>3.克隆hexo_bak分支，</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone -b hexo_bak https://github.com/XXX/XXX.github.io.git</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-安装node-js-修改安装目录，默认安装\"><a href=\"#4-安装node-js-修改安装目录，默认安装\" class=\"headerlink\" title=\"4.安装node.js(修改安装目录，默认安装)\"></a>4.安装node.js(修改安装目录，默认安装)</h2><p>下载网址<a href=\"https://nodejs.org/en%EF%BC%8C\">https://nodejs.org/en，</a></p>\n<h2 id=\"5-用-node-v-和-npm-v-命令检查版本\"><a href=\"#5-用-node-v-和-npm-v-命令检查版本\" class=\"headerlink\" title=\"5.用 node -v 和 npm -v 命令检查版本\"></a>5.用 node -v 和 npm -v 命令检查版本</h2><p>上述node.js安装成功之后，npm同时也已经安装成功，用 node -v 和 npm -v 命令检查版本</p>\n<h2 id=\"6-配置npm在安装全局模块时的路径和缓存cache的路径\"><a href=\"#6-配置npm在安装全局模块时的路径和缓存cache的路径\" class=\"headerlink\" title=\"6.配置npm在安装全局模块时的路径和缓存cache的路径\"></a>6.配置npm在安装全局模块时的路径和缓存cache的路径</h2><p>否则默认安装在C盘，不方便管理且占用C盘空间<br>    1，在node.js安装目录下新建两个文件夹 node_global和node_cache<br>    2，在git bush命令下执行如下两个命令：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config <span class=\"built_in\">set</span> prefix <span class=\"string\">&quot;F:\\Blogs\\nodejs\\node_global&quot;</span></span><br><span class=\"line\">npm config <span class=\"built_in\">set</span> cache <span class=\"string\">&quot;F:\\Blogs\\nodejs\\node_cache&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t3，在环境变量 -&gt; 系统变量中新建一个变量名为 “NODE_PATH”， 值为“F:\\Blogs\\nodejs\\node_modules”，<br>​\t4，最后编辑用户变量里的Path，将相应npm的路径改为：F:\\Blogs\\nodejs\\node_global，<br>​\t5，在git bush命令下执行 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install webpack -g</span><br></pre></td></tr></table></figure>\n\n<p> 然后安装成功后可以看到自定义的两个文件夹已生效：<br>    6，npm webpack -v 查看安装webpack的版本号</p>\n<h2 id=\"7-输入npm命令安装Hexo：\"><a href=\"#7-输入npm命令安装Hexo：\" class=\"headerlink\" title=\"7.输入npm命令安装Hexo：\"></a>7.输入npm命令安装Hexo：</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-安装完成后，输入-hexo-init-命令初始化博客：\"><a href=\"#8-安装完成后，输入-hexo-init-命令初始化博客：\" class=\"headerlink\" title=\"8.安装完成后，输入 hexo init 命令初始化博客：\"></a>8.安装完成后，输入 hexo init 命令初始化博客：</h2><h2 id=\"9-然后输入-hexo-g-静态部署：\"><a href=\"#9-然后输入-hexo-g-静态部署：\" class=\"headerlink\" title=\"9.然后输入 hexo g 静态部署：\"></a>9.然后输入 hexo g 静态部署：</h2><h2 id=\"10-部署完成，输入hexo-s-命令可以查看\"><a href=\"#10-部署完成，输入hexo-s-命令可以查看\" class=\"headerlink\" title=\"10.部署完成，输入hexo s 命令可以查看\"></a>10.部署完成，输入hexo s 命令可以查看</h2><p>浏览器输入 <a href=\"http://localhost:4000/\">http://localhost:4000</a> 就可以打开新部署的网页：看完之后 ctrl +c 停止运行服务器。</p>\n<h2 id=\"11-hexo命令\"><a href=\"#11-hexo命令\" class=\"headerlink\" title=\"11.hexo命令\"></a>11.hexo命令</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init    <span class=\"comment\">//命令初始化博客：</span></span><br><span class=\"line\">hexo clean   <span class=\"comment\">//清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class=\"line\">hexo g       <span class=\"comment\">//生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class=\"line\">hexo s       <span class=\"comment\">//命令可以查看新部署的网页,浏览器输入 http://localhost:4000</span></span><br><span class=\"line\">hexo d       <span class=\"comment\">//自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"12-绑定GitHub\"><a href=\"#12-绑定GitHub\" class=\"headerlink\" title=\"12.绑定GitHub\"></a>12.绑定GitHub</h2><p>​\t1.输入 ssh 命令，查看本机是否安装 SSH：ssh<br>​\t2.输入 ssh-keygen -t rsa 命令（注意空格），指定 RSA 算法生成密钥，然后敲四次回车键，生成两个文件:秘钥 id_rsa 和公钥 id_rsa.pub.<br>​\t3.将公钥 id_rsa.pub 的内容添加到 GitHub-&gt;settings-&gt;SSH and GPG keys-&gt; New SSH key.<br>​\t4.在 Git Bash 中输入 ssh -T <a href=\"mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109;\">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#x6f;&#109;</a> 进行检验</p>\n<h2 id=\"13-将博客部署到设定的git仓库主分支main\"><a href=\"#13-将博客部署到设定的git仓库主分支main\" class=\"headerlink\" title=\"13.将博客部署到设定的git仓库主分支main\"></a>13.将博客部署到设定的git仓库主分支main</h2><p>​\t安装Git部署插件npm install hexo-deployer-git –save(删除原.deploy_git文件夹，hexo g后重新生成)<br>​\thexo clean   #清除缓存文件 db.json 和已生成的静态文件 public<br>​\thexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)<br>​\thexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</p>\n<h2 id=\"14-备份hexo到git分支hexo-bak\"><a href=\"#14-备份hexo到git分支hexo-bak\" class=\"headerlink\" title=\"14.备份hexo到git分支hexo_bak\"></a>14.备份hexo到git分支hexo_bak</h2><p>​\t1.添加所有文件夹和文件到本地仓库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br></pre></td></tr></table></figure>\n\n<p>​\t2.提交文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;提交注释&quot;</span><br></pre></td></tr></table></figure>\n\n<p>​\t3.push到git分支</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push --set-upstream origin hexo_bak</span><br></pre></td></tr></table></figure>"},{"title":"next主题美化（持续更新）","date":"2022-03-16T02:08:11.000Z","comments":0,"description":null,"_content":"\n## 1，新建“分类”下的页面\n\n1，打开主题配置文件\"config.yml\"\n\n2，找到Menu Settings\n\n<!--more-->\n\nmenu:\n  home: / || fa fa-home\t\t#首页\n  categories: /categories/ || fa fa-th\t#分类\n  notes: /categories/笔记/ || fa fa-folder-open\t#笔记\n  read: /categories/阅读/ || fa fa-book\t#阅读\n  tags: /tags/ || fa fa-tags\t\t#标签\n  archives: /archives/ || fa fa-archive\t#时间轴\n  about: /about/ || fa fa-user\t\t#关于\n  #schedule: /schedule/ || fa fa-calendar\t#日程表\n  #sitemap: /sitemap.xml || fa fa-sitemap\t#站点地图\n  #commonweal: /404/ || fa fa-heartbeat\t#公益 404\n\n3，对应添加你需要的页面，如：read: /categories/阅读/ || fa fa-book\t#阅读，read页面属于'categories'分类的子页面'阅读'，“||”前面的是目标链接，后面的是图标名称，next使用的图标全是[图标库 - Font Awesome 中文网](https://link.zhihu.com/?target=http%3A//www.fontawesome.com.cn/faicons/%23web-application)这一网站的，有想用的图标直接在fontawesome上面找图标的名称就行。\n\n4，新添加的菜单需要翻译对应的中文，打开theme/next/languages/zh-CN.yml，在menu下设置：\n\n5，同时，需要在Hexo根目录下的source中创建对应的文件夹，文件夹名称与<read>保持一致，文件夹中创建index.md文件，进行该页面描述，type必须与步骤3中添加的<categories>一致\n\n 在根目录下打开Git Bash，输入如下代码： hexo new page \"categories\" sources文件夹下会生成文件夹，文件中有一个`index.md`文件，修改内容分别如下： \n\ntitle: 阅读\ndate: 2021-01-08 16:04:21\ntype: \"categories\"\ncomments: false \n\n注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。 \n\n6，编辑博客文章时，categories分类必须与步骤3中添加的<阅读>一致\n\ntitle: 如何阅读一本书？\ndate: 2021-01-07 15:59:11\ncategories: 阅读\ntags: \n\n-读书\ncomments: false\ndescription: \n\n7，至此，上传后的博客文章和创建的页面相关联，正常显示，调转\n\n## 2，鼠标点击红心特效\n\n 在`/themes/next/source/js/`下新建文件 clicklove.js ，接着把下面的代码拷贝粘贴到 clicklove.js 文件中： \n\n```\n!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e<d.length;e++)d[e].alpha<=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&&e.onclick;e.onclick=function(e){t&&t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);\n\n```\n\n 在`\\themes\\next\\layout\\_layout.swig`文件末尾添加： \n\n```\n<!-- 页面点击小红心 -->\n<script type=\"text/javascript\" src=\"/js/click.js\"></script>\n```\n\n## 3，添加字数统计和阅读时长\n\n```c\n// 1，安装hexo-symbols-count-time \n$ npm installl hexo-symbols-count-time --save\n//1.1如果有警告如下\nnpm WARN babel-eslint@10.0.1 requires a peer of eslint@>= 4.12.1 but none is installed. You must install peer dependencies yourself.\n//还需安装eslint\n$ npm install eslint --save\n//2,在Hexo站点配置文件添加如下配置\nsymbols_count_time:\n  symbols: true                # 文章字数统计\n  time: true                   # 文章阅读时长\n  total_symbols: true          # 站点总字数统计\n  total_time: true             # 站点总阅读时长\n  exclude_codeblock: false     # 排除代码字数统计\n  awl: 4\t\t\t\t\t # Average Word Length\n  wpm: 275\t\t\t\t\t # Words Per Minute（每分钟阅读词数）\n  suffix: \"mins.\"\n//3, 在NexT主题配置文件添加如下配置（NexT主题已支持该插件，有的话无需再添加）\nsymbols_count_time:\n  separated_meta: true     # 是否另起一行（true的话不和发表时间等同一行）\n  item_text_post: true     # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）\n  item_text_total: false   # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）\n```\n\n\n\n## 4，添加背景图片,设置透明和边框圆角\n\n- 进入 `themes\\next\\source\\css` 目录中\n\n- 打开 `main.styl` 文件\n\n- 在末尾添加 `css` 代码即可\n\n-  背景图片位于 `themes\\next\\source\\images` 路径下 \n\n  ```css\n  // 自定义样式\n  // --------------------------------------------------\n  body {\n    background: url(/images/background.png);\n    background-repeat: no-repeat;\n    background-attachment: fixed;\n    background-position: 50% 50%;\n    color: var(--text-color);\n    font-family: 'Lato', \"PingFang SC\", \"Microsoft YaHei\", sans-serif;\n    font-size: 1em;\n    line-height: 2;\n  }\n  \n  // 侧边标题栏\n  .header-inner {\n    border-radius: 20px 20px 20px 20px; //边框圆角\n    opacity: 0.85;\n  }\n  \n  // 侧边头像栏\n  .sidebar{\n    transition-duration: 0.4s;  \n    opacity: 0.85;  // 透明度\n    border-radius: 10px 10px 10px 10px; //边框圆角\n  }\n  \n  // 侧边头像框内部\n  .sidebar-inner {\n    background: var(--content-bg-color);\n    border-radius: 10px 10px 10px 10px; //边框圆角\n    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);\n    box-sizing: border-box;\n    color: var(--text-color);\n    width: 240px;\n    opacity: 0;\n  }\n  \n  // 中心文章栏\n  .content {\n    padding-top: 15px;\n    opacity: 0.9;\n  }\n  \n  //第一个文章\n  .post-block {\n    background: var(--content-bg-color);\n    border-radius: 10px 10px 10px 10px; //边框圆角\n    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n    padding: 40px;\n  }\n  \n  //之后的所有文章\n  .post-block + .post-block {\n    border-radius: 10px 10px 10px 10px; //边框圆角\n    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);\n    margin-top: 12px;\n  }\n  ```\n## 5，插入图片\n\n  ### \t全局资源文件夹\n\n  ​\t\t资源（Asset）代表 `source` 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 `source/images` 文件夹中。然后通过类似于 `![](/images/image.jpg)` 的方法访问它们。\n\n  \n\n  ### \t文章资源文件夹\n\n  ​\t\t对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 `config.yml` 文件中的 `post_asset_folder` 选项设为 `true` 来打开。\n\n  ```yaml\n  _config.yml\n  post_asset_folder: true\n  ```\n\n   \t\t\n\n  ​\t当资源文件管理功能打开后，Hexo将会在你每一次通过 `hexo new [layout] ` 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 \n\n  \n\n  ### \t图片插件\n\n  ​\t插件hexo-renderer-marked解决了这个问题。可以只用`npm install hexo-renderer-marked`命令直接安装，之后在`config.yaml`中更改配置如下：\n\n```yaml\npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n\n​\t\t之后就可以在使用`![](image.jpg)`的方式愉快的插入图片了。","source":"_posts/next主题美化.md","raw":"---\ntitle: next主题美化（持续更新）\ndate: 2022-3-16 10:08:11\ncategories: 笔记\ntags: \ncomments: false\ndescription: \n\n---\n\n## 1，新建“分类”下的页面\n\n1，打开主题配置文件\"config.yml\"\n\n2，找到Menu Settings\n\n<!--more-->\n\nmenu:\n  home: / || fa fa-home\t\t#首页\n  categories: /categories/ || fa fa-th\t#分类\n  notes: /categories/笔记/ || fa fa-folder-open\t#笔记\n  read: /categories/阅读/ || fa fa-book\t#阅读\n  tags: /tags/ || fa fa-tags\t\t#标签\n  archives: /archives/ || fa fa-archive\t#时间轴\n  about: /about/ || fa fa-user\t\t#关于\n  #schedule: /schedule/ || fa fa-calendar\t#日程表\n  #sitemap: /sitemap.xml || fa fa-sitemap\t#站点地图\n  #commonweal: /404/ || fa fa-heartbeat\t#公益 404\n\n3，对应添加你需要的页面，如：read: /categories/阅读/ || fa fa-book\t#阅读，read页面属于'categories'分类的子页面'阅读'，“||”前面的是目标链接，后面的是图标名称，next使用的图标全是[图标库 - Font Awesome 中文网](https://link.zhihu.com/?target=http%3A//www.fontawesome.com.cn/faicons/%23web-application)这一网站的，有想用的图标直接在fontawesome上面找图标的名称就行。\n\n4，新添加的菜单需要翻译对应的中文，打开theme/next/languages/zh-CN.yml，在menu下设置：\n\n5，同时，需要在Hexo根目录下的source中创建对应的文件夹，文件夹名称与<read>保持一致，文件夹中创建index.md文件，进行该页面描述，type必须与步骤3中添加的<categories>一致\n\n 在根目录下打开Git Bash，输入如下代码： hexo new page \"categories\" sources文件夹下会生成文件夹，文件中有一个`index.md`文件，修改内容分别如下： \n\ntitle: 阅读\ndate: 2021-01-08 16:04:21\ntype: \"categories\"\ncomments: false \n\n注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。 \n\n6，编辑博客文章时，categories分类必须与步骤3中添加的<阅读>一致\n\ntitle: 如何阅读一本书？\ndate: 2021-01-07 15:59:11\ncategories: 阅读\ntags: \n\n-读书\ncomments: false\ndescription: \n\n7，至此，上传后的博客文章和创建的页面相关联，正常显示，调转\n\n## 2，鼠标点击红心特效\n\n 在`/themes/next/source/js/`下新建文件 clicklove.js ，接着把下面的代码拷贝粘贴到 clicklove.js 文件中： \n\n```\n!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e<d.length;e++)d[e].alpha<=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)}function o(){var t=\"function\"==typeof e.onclick&&e.onclick;e.onclick=function(e){t&&t(),i(e)}}function i(e){var a=t.createElement(\"div\");a.className=\"heart\",d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(\"style\");a.type=\"text/css\";try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(\"head\")[0].appendChild(a)}function s(){return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document);\n\n```\n\n 在`\\themes\\next\\layout\\_layout.swig`文件末尾添加： \n\n```\n<!-- 页面点击小红心 -->\n<script type=\"text/javascript\" src=\"/js/click.js\"></script>\n```\n\n## 3，添加字数统计和阅读时长\n\n```c\n// 1，安装hexo-symbols-count-time \n$ npm installl hexo-symbols-count-time --save\n//1.1如果有警告如下\nnpm WARN babel-eslint@10.0.1 requires a peer of eslint@>= 4.12.1 but none is installed. You must install peer dependencies yourself.\n//还需安装eslint\n$ npm install eslint --save\n//2,在Hexo站点配置文件添加如下配置\nsymbols_count_time:\n  symbols: true                # 文章字数统计\n  time: true                   # 文章阅读时长\n  total_symbols: true          # 站点总字数统计\n  total_time: true             # 站点总阅读时长\n  exclude_codeblock: false     # 排除代码字数统计\n  awl: 4\t\t\t\t\t # Average Word Length\n  wpm: 275\t\t\t\t\t # Words Per Minute（每分钟阅读词数）\n  suffix: \"mins.\"\n//3, 在NexT主题配置文件添加如下配置（NexT主题已支持该插件，有的话无需再添加）\nsymbols_count_time:\n  separated_meta: true     # 是否另起一行（true的话不和发表时间等同一行）\n  item_text_post: true     # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）\n  item_text_total: false   # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）\n```\n\n\n\n## 4，添加背景图片,设置透明和边框圆角\n\n- 进入 `themes\\next\\source\\css` 目录中\n\n- 打开 `main.styl` 文件\n\n- 在末尾添加 `css` 代码即可\n\n-  背景图片位于 `themes\\next\\source\\images` 路径下 \n\n  ```css\n  // 自定义样式\n  // --------------------------------------------------\n  body {\n    background: url(/images/background.png);\n    background-repeat: no-repeat;\n    background-attachment: fixed;\n    background-position: 50% 50%;\n    color: var(--text-color);\n    font-family: 'Lato', \"PingFang SC\", \"Microsoft YaHei\", sans-serif;\n    font-size: 1em;\n    line-height: 2;\n  }\n  \n  // 侧边标题栏\n  .header-inner {\n    border-radius: 20px 20px 20px 20px; //边框圆角\n    opacity: 0.85;\n  }\n  \n  // 侧边头像栏\n  .sidebar{\n    transition-duration: 0.4s;  \n    opacity: 0.85;  // 透明度\n    border-radius: 10px 10px 10px 10px; //边框圆角\n  }\n  \n  // 侧边头像框内部\n  .sidebar-inner {\n    background: var(--content-bg-color);\n    border-radius: 10px 10px 10px 10px; //边框圆角\n    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);\n    box-sizing: border-box;\n    color: var(--text-color);\n    width: 240px;\n    opacity: 0;\n  }\n  \n  // 中心文章栏\n  .content {\n    padding-top: 15px;\n    opacity: 0.9;\n  }\n  \n  //第一个文章\n  .post-block {\n    background: var(--content-bg-color);\n    border-radius: 10px 10px 10px 10px; //边框圆角\n    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);\n    padding: 40px;\n  }\n  \n  //之后的所有文章\n  .post-block + .post-block {\n    border-radius: 10px 10px 10px 10px; //边框圆角\n    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12), 0 -1px 0.5px 0 rgba(0,0,0,0.09);\n    margin-top: 12px;\n  }\n  ```\n## 5，插入图片\n\n  ### \t全局资源文件夹\n\n  ​\t\t资源（Asset）代表 `source` 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 `source/images` 文件夹中。然后通过类似于 `![](/images/image.jpg)` 的方法访问它们。\n\n  \n\n  ### \t文章资源文件夹\n\n  ​\t\t对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 `config.yml` 文件中的 `post_asset_folder` 选项设为 `true` 来打开。\n\n  ```yaml\n  _config.yml\n  post_asset_folder: true\n  ```\n\n   \t\t\n\n  ​\t当资源文件管理功能打开后，Hexo将会在你每一次通过 `hexo new [layout] ` 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 \n\n  \n\n  ### \t图片插件\n\n  ​\t插件hexo-renderer-marked解决了这个问题。可以只用`npm install hexo-renderer-marked`命令直接安装，之后在`config.yaml`中更改配置如下：\n\n```yaml\npost_asset_folder: true\nmarked:\n  prependRoot: true\n  postAsset: true\n```\n\n​\t\t之后就可以在使用`![](image.jpg)`的方式愉快的插入图片了。","slug":"next主题美化","published":1,"updated":"2023-04-13T04:44:33.135Z","_id":"clgbz5hpe0000s8ob1fr65els","layout":"post","photos":[],"link":"","content":"<h2 id=\"1，新建“分类”下的页面\"><a href=\"#1，新建“分类”下的页面\" class=\"headerlink\" title=\"1，新建“分类”下的页面\"></a>1，新建“分类”下的页面</h2><p>1，打开主题配置文件”config.yml”</p>\n<p>2，找到Menu Settings</p>\n<span id=\"more\"></span>\n\n<p>menu:<br>  home: &#x2F; || fa fa-home\t\t#首页<br>  categories: &#x2F;categories&#x2F; || fa fa-th\t#分类<br>  notes: &#x2F;categories&#x2F;笔记&#x2F; || fa fa-folder-open\t#笔记<br>  read: &#x2F;categories&#x2F;阅读&#x2F; || fa fa-book\t#阅读<br>  tags: &#x2F;tags&#x2F; || fa fa-tags\t\t#标签<br>  archives: &#x2F;archives&#x2F; || fa fa-archive\t#时间轴<br>  about: &#x2F;about&#x2F; || fa fa-user\t\t#关于<br>  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar\t#日程表<br>  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap\t#站点地图<br>  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat\t#公益 404</p>\n<p>3，对应添加你需要的页面，如：read: &#x2F;categories&#x2F;阅读&#x2F; || fa fa-book\t#阅读，read页面属于’categories’分类的子页面’阅读’，“||”前面的是目标链接，后面的是图标名称，next使用的图标全是<a href=\"https://link.zhihu.com/?target=http://www.fontawesome.com.cn/faicons/%23web-application\">图标库 - Font Awesome 中文网</a>这一网站的，有想用的图标直接在fontawesome上面找图标的名称就行。</p>\n<p>4，新添加的菜单需要翻译对应的中文，打开theme&#x2F;next&#x2F;languages&#x2F;zh-CN.yml，在menu下设置：</p>\n<p>5，同时，需要在Hexo根目录下的source中创建对应的文件夹，文件夹名称与<read>保持一致，文件夹中创建index.md文件，进行该页面描述，type必须与步骤3中添加的<categories>一致</p>\n<p> 在根目录下打开Git Bash，输入如下代码： hexo new page “categories” sources文件夹下会生成文件夹，文件中有一个<code>index.md</code>文件，修改内容分别如下： </p>\n<p>title: 阅读<br>date: 2021-01-08 16:04:21<br>type: “categories”<br>comments: false </p>\n<p>注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。 </p>\n<p>6，编辑博客文章时，categories分类必须与步骤3中添加的&lt;阅读&gt;一致</p>\n<p>title: 如何阅读一本书？<br>date: 2021-01-07 15:59:11<br>categories: 阅读<br>tags: </p>\n<p>-读书<br>comments: false<br>description: </p>\n<p>7，至此，上传后的博客文章和创建的页面相关联，正常显示，调转</p>\n<h2 id=\"2，鼠标点击红心特效\"><a href=\"#2，鼠标点击红心特效\" class=\"headerlink\" title=\"2，鼠标点击红心特效\"></a>2，鼠标点击红心特效</h2><p> 在<code>/themes/next/source/js/</code>下新建文件 clicklove.js ，接着把下面的代码拷贝粘贴到 clicklove.js 文件中： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 在<code>\\themes\\next\\layout\\_layout.swig</code>文件末尾添加： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 页面点击小红心 --&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/click.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3，添加字数统计和阅读时长\"><a href=\"#3，添加字数统计和阅读时长\" class=\"headerlink\" title=\"3，添加字数统计和阅读时长\"></a>3，添加字数统计和阅读时长</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1，安装hexo-symbols-count-time </span></span><br><span class=\"line\">$ npm installl hexo-symbols-count-time --save</span><br><span class=\"line\"><span class=\"comment\">//1.1如果有警告如下</span></span><br><span class=\"line\">npm WARN babel-eslint@<span class=\"number\">10.0</span><span class=\"number\">.1</span> requires a peer of eslint@&gt;= <span class=\"number\">4.12</span><span class=\"number\">.1</span> but none is installed. You must install peer dependencies yourself.</span><br><span class=\"line\"><span class=\"comment\">//还需安装eslint</span></span><br><span class=\"line\">$ npm install eslint --save</span><br><span class=\"line\"><span class=\"comment\">//2,在Hexo站点配置文件添加如下配置</span></span><br><span class=\"line\">symbols_count_time:</span><br><span class=\"line\">  symbols: <span class=\"literal\">true</span>                # 文章字数统计</span><br><span class=\"line\">  time: <span class=\"literal\">true</span>                   # 文章阅读时长</span><br><span class=\"line\">  total_symbols: <span class=\"literal\">true</span>          # 站点总字数统计</span><br><span class=\"line\">  total_time: <span class=\"literal\">true</span>             # 站点总阅读时长</span><br><span class=\"line\">  exclude_codeblock: <span class=\"literal\">false</span>     # 排除代码字数统计</span><br><span class=\"line\">  awl: <span class=\"number\">4</span>\t\t\t\t\t # Average Word Length</span><br><span class=\"line\">  wpm: <span class=\"number\">275</span>\t\t\t\t\t # Words Per Minute（每分钟阅读词数）</span><br><span class=\"line\">  suffix: <span class=\"string\">&quot;mins.&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//3, 在NexT主题配置文件添加如下配置（NexT主题已支持该插件，有的话无需再添加）</span></span><br><span class=\"line\">symbols_count_time:</span><br><span class=\"line\">  separated_meta: <span class=\"literal\">true</span>     # 是否另起一行（<span class=\"literal\">true</span>的话不和发表时间等同一行）</span><br><span class=\"line\">  item_text_post: <span class=\"literal\">true</span>     # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class=\"line\">  item_text_total: <span class=\"literal\">false</span>   # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4，添加背景图片-设置透明和边框圆角\"><a href=\"#4，添加背景图片-设置透明和边框圆角\" class=\"headerlink\" title=\"4，添加背景图片,设置透明和边框圆角\"></a>4，添加背景图片,设置透明和边框圆角</h2><ul>\n<li><p>进入 <code>themes\\next\\source\\css</code> 目录中</p>\n</li>\n<li><p>打开 <code>main.styl</code> 文件</p>\n</li>\n<li><p>在末尾添加 <code>css</code> 代码即可</p>\n</li>\n<li><p>背景图片位于 <code>themes\\next\\source\\images</code> 路径下</p>\n</li>\n</ul>\n  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 自定义样式</span><br><span class=\"line\">// --------------------------------------------------</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">/images/background.png</span>);</span><br><span class=\"line\">  <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">  <span class=\"attribute\">background-attachment</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">background-position</span>: <span class=\"number\">50%</span> <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--text-color);</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: <span class=\"string\">&#x27;Lato&#x27;</span>, <span class=\"string\">&quot;PingFang SC&quot;</span>, <span class=\"string\">&quot;Microsoft YaHei&quot;</span>, sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 侧边标题栏</span><br><span class=\"line\"><span class=\"selector-class\">.header-inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">20px</span> <span class=\"number\">20px</span> <span class=\"number\">20px</span> <span class=\"number\">20px</span>; //边框圆角</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.85</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 侧边头像栏</span><br><span class=\"line\"><span class=\"selector-class\">.sidebar</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition-duration</span>: <span class=\"number\">0.4s</span>;  </span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.85</span>;  // 透明度</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>; //边框圆角</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 侧边头像框内部</span><br><span class=\"line\"><span class=\"selector-class\">.sidebar-inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">var</span>(--content-bg-color);</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>; //边框圆角</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> <span class=\"number\">3px</span> <span class=\"number\">1px</span> -<span class=\"number\">2px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.06</span>), <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> -<span class=\"number\">1px</span> <span class=\"number\">0.5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.09</span>);</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--text-color);</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">240px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 中心文章栏</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//第一个文章</span><br><span class=\"line\"><span class=\"selector-class\">.post-block</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">var</span>(--content-bg-color);</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>; //边框圆角</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> <span class=\"number\">3px</span> <span class=\"number\">1px</span> -<span class=\"number\">2px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.06</span>), <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>);</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//之后的所有文章</span><br><span class=\"line\"><span class=\"selector-class\">.post-block</span> + <span class=\"selector-class\">.post-block</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>; //边框圆角</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> <span class=\"number\">3px</span> <span class=\"number\">1px</span> -<span class=\"number\">2px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.06</span>), <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> -<span class=\"number\">1px</span> <span class=\"number\">0.5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.09</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5，插入图片\"><a href=\"#5，插入图片\" class=\"headerlink\" title=\"5，插入图片\"></a>5，插入图片</h2><h3 id=\"全局资源文件夹\"><a href=\"#全局资源文件夹\" class=\"headerlink\" title=\"全局资源文件夹\"></a>全局资源文件夹</h3><p>  ​\t\t资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p>\n<h3 id=\"文章资源文件夹\"><a href=\"#文章资源文件夹\" class=\"headerlink\" title=\"文章资源文件夹\"></a>文章资源文件夹</h3><p>  ​\t\t对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p>\n  <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">_config.yml</span></span><br><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>  ​\t当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] </code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 </p>\n<h3 id=\"图片插件\"><a href=\"#图片插件\" class=\"headerlink\" title=\"图片插件\"></a>图片插件</h3><p>  ​\t插件hexo-renderer-marked解决了这个问题。可以只用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在<code>config.yaml</code>中更改配置如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">marked:</span></span><br><span class=\"line\">  <span class=\"attr\">prependRoot:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">postAsset:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t之后就可以在使用<code>![](image.jpg)</code>的方式愉快的插入图片了。</p>\n","site":{"data":{"style":""}},"length":6236,"excerpt":"<h2 id=\"1，新建“分类”下的页面\"><a href=\"#1，新建“分类”下的页面\" class=\"headerlink\" title=\"1，新建“分类”下的页面\"></a>1，新建“分类”下的页面</h2><p>1，打开主题配置文件”config.yml”</p>\n<p>2，找到Menu Settings</p>","more":"<p>menu:<br>  home: &#x2F; || fa fa-home\t\t#首页<br>  categories: &#x2F;categories&#x2F; || fa fa-th\t#分类<br>  notes: &#x2F;categories&#x2F;笔记&#x2F; || fa fa-folder-open\t#笔记<br>  read: &#x2F;categories&#x2F;阅读&#x2F; || fa fa-book\t#阅读<br>  tags: &#x2F;tags&#x2F; || fa fa-tags\t\t#标签<br>  archives: &#x2F;archives&#x2F; || fa fa-archive\t#时间轴<br>  about: &#x2F;about&#x2F; || fa fa-user\t\t#关于<br>  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar\t#日程表<br>  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap\t#站点地图<br>  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat\t#公益 404</p>\n<p>3，对应添加你需要的页面，如：read: &#x2F;categories&#x2F;阅读&#x2F; || fa fa-book\t#阅读，read页面属于’categories’分类的子页面’阅读’，“||”前面的是目标链接，后面的是图标名称，next使用的图标全是<a href=\"https://link.zhihu.com/?target=http://www.fontawesome.com.cn/faicons/%23web-application\">图标库 - Font Awesome 中文网</a>这一网站的，有想用的图标直接在fontawesome上面找图标的名称就行。</p>\n<p>4，新添加的菜单需要翻译对应的中文，打开theme&#x2F;next&#x2F;languages&#x2F;zh-CN.yml，在menu下设置：</p>\n<p>5，同时，需要在Hexo根目录下的source中创建对应的文件夹，文件夹名称与<read>保持一致，文件夹中创建index.md文件，进行该页面描述，type必须与步骤3中添加的<categories>一致</p>\n<p> 在根目录下打开Git Bash，输入如下代码： hexo new page “categories” sources文件夹下会生成文件夹，文件中有一个<code>index.md</code>文件，修改内容分别如下： </p>\n<p>title: 阅读<br>date: 2021-01-08 16:04:21<br>type: “categories”<br>comments: false </p>\n<p>注：如果有启用评论，默认页面带有评论。需要关闭的话，添加字段comments并将值设置为false。 </p>\n<p>6，编辑博客文章时，categories分类必须与步骤3中添加的&lt;阅读&gt;一致</p>\n<p>title: 如何阅读一本书？<br>date: 2021-01-07 15:59:11<br>categories: 阅读<br>tags: </p>\n<p>-读书<br>comments: false<br>description: </p>\n<p>7，至此，上传后的博客文章和创建的页面相关联，正常显示，调转</p>\n<h2 id=\"2，鼠标点击红心特效\"><a href=\"#2，鼠标点击红心特效\" class=\"headerlink\" title=\"2，鼠标点击红心特效\"></a>2，鼠标点击红心特效</h2><p> 在<code>/themes/next/source/js/</code>下新建文件 clicklove.js ，接着把下面的代码拷贝粘贴到 clicklove.js 文件中： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 在<code>\\themes\\next\\layout\\_layout.swig</code>文件末尾添加： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 页面点击小红心 --&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/click.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3，添加字数统计和阅读时长\"><a href=\"#3，添加字数统计和阅读时长\" class=\"headerlink\" title=\"3，添加字数统计和阅读时长\"></a>3，添加字数统计和阅读时长</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1，安装hexo-symbols-count-time </span></span><br><span class=\"line\">$ npm installl hexo-symbols-count-time --save</span><br><span class=\"line\"><span class=\"comment\">//1.1如果有警告如下</span></span><br><span class=\"line\">npm WARN babel-eslint@<span class=\"number\">10.0</span><span class=\"number\">.1</span> requires a peer of eslint@&gt;= <span class=\"number\">4.12</span><span class=\"number\">.1</span> but none is installed. You must install peer dependencies yourself.</span><br><span class=\"line\"><span class=\"comment\">//还需安装eslint</span></span><br><span class=\"line\">$ npm install eslint --save</span><br><span class=\"line\"><span class=\"comment\">//2,在Hexo站点配置文件添加如下配置</span></span><br><span class=\"line\">symbols_count_time:</span><br><span class=\"line\">  symbols: <span class=\"literal\">true</span>                # 文章字数统计</span><br><span class=\"line\">  time: <span class=\"literal\">true</span>                   # 文章阅读时长</span><br><span class=\"line\">  total_symbols: <span class=\"literal\">true</span>          # 站点总字数统计</span><br><span class=\"line\">  total_time: <span class=\"literal\">true</span>             # 站点总阅读时长</span><br><span class=\"line\">  exclude_codeblock: <span class=\"literal\">false</span>     # 排除代码字数统计</span><br><span class=\"line\">  awl: <span class=\"number\">4</span>\t\t\t\t\t # Average Word Length</span><br><span class=\"line\">  wpm: <span class=\"number\">275</span>\t\t\t\t\t # Words Per Minute（每分钟阅读词数）</span><br><span class=\"line\">  suffix: <span class=\"string\">&quot;mins.&quot;</span></span><br><span class=\"line\"><span class=\"comment\">//3, 在NexT主题配置文件添加如下配置（NexT主题已支持该插件，有的话无需再添加）</span></span><br><span class=\"line\">symbols_count_time:</span><br><span class=\"line\">  separated_meta: <span class=\"literal\">true</span>     # 是否另起一行（<span class=\"literal\">true</span>的话不和发表时间等同一行）</span><br><span class=\"line\">  item_text_post: <span class=\"literal\">true</span>     # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class=\"line\">  item_text_total: <span class=\"literal\">false</span>   # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"4，添加背景图片-设置透明和边框圆角\"><a href=\"#4，添加背景图片-设置透明和边框圆角\" class=\"headerlink\" title=\"4，添加背景图片,设置透明和边框圆角\"></a>4，添加背景图片,设置透明和边框圆角</h2><ul>\n<li><p>进入 <code>themes\\next\\source\\css</code> 目录中</p>\n</li>\n<li><p>打开 <code>main.styl</code> 文件</p>\n</li>\n<li><p>在末尾添加 <code>css</code> 代码即可</p>\n</li>\n<li><p>背景图片位于 <code>themes\\next\\source\\images</code> 路径下</p>\n</li>\n</ul>\n  <figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 自定义样式</span><br><span class=\"line\">// --------------------------------------------------</span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(<span class=\"string\">/images/background.png</span>);</span><br><span class=\"line\">  <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">  <span class=\"attribute\">background-attachment</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">background-position</span>: <span class=\"number\">50%</span> <span class=\"number\">50%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--text-color);</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: <span class=\"string\">&#x27;Lato&#x27;</span>, <span class=\"string\">&quot;PingFang SC&quot;</span>, <span class=\"string\">&quot;Microsoft YaHei&quot;</span>, sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1em</span>;</span><br><span class=\"line\">  <span class=\"attribute\">line-height</span>: <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 侧边标题栏</span><br><span class=\"line\"><span class=\"selector-class\">.header-inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">20px</span> <span class=\"number\">20px</span> <span class=\"number\">20px</span> <span class=\"number\">20px</span>; //边框圆角</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.85</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 侧边头像栏</span><br><span class=\"line\"><span class=\"selector-class\">.sidebar</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">transition-duration</span>: <span class=\"number\">0.4s</span>;  </span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.85</span>;  // 透明度</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>; //边框圆角</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 侧边头像框内部</span><br><span class=\"line\"><span class=\"selector-class\">.sidebar-inner</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">var</span>(--content-bg-color);</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>; //边框圆角</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> <span class=\"number\">3px</span> <span class=\"number\">1px</span> -<span class=\"number\">2px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.06</span>), <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> -<span class=\"number\">1px</span> <span class=\"number\">0.5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.09</span>);</span><br><span class=\"line\">  <span class=\"attribute\">box-sizing</span>: border-box;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--text-color);</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">240px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 中心文章栏</span><br><span class=\"line\"><span class=\"selector-class\">.content</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">padding-top</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">opacity</span>: <span class=\"number\">0.9</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//第一个文章</span><br><span class=\"line\"><span class=\"selector-class\">.post-block</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"built_in\">var</span>(--content-bg-color);</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>; //边框圆角</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> <span class=\"number\">3px</span> <span class=\"number\">1px</span> -<span class=\"number\">2px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.06</span>), <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>);</span><br><span class=\"line\">  <span class=\"attribute\">padding</span>: <span class=\"number\">40px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//之后的所有文章</span><br><span class=\"line\"><span class=\"selector-class\">.post-block</span> + <span class=\"selector-class\">.post-block</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-radius</span>: <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>; //边框圆角</span><br><span class=\"line\">  <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">2px</span> <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> <span class=\"number\">3px</span> <span class=\"number\">1px</span> -<span class=\"number\">2px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.06</span>), <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.12</span>), <span class=\"number\">0</span> -<span class=\"number\">1px</span> <span class=\"number\">0.5px</span> <span class=\"number\">0</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.09</span>);</span><br><span class=\"line\">  <span class=\"attribute\">margin-top</span>: <span class=\"number\">12px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5，插入图片\"><a href=\"#5，插入图片\" class=\"headerlink\" title=\"5，插入图片\"></a>5，插入图片</h2><h3 id=\"全局资源文件夹\"><a href=\"#全局资源文件夹\" class=\"headerlink\" title=\"全局资源文件夹\"></a>全局资源文件夹</h3><p>  ​\t\t资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p>\n<h3 id=\"文章资源文件夹\"><a href=\"#文章资源文件夹\" class=\"headerlink\" title=\"文章资源文件夹\"></a>文章资源文件夹</h3><p>  ​\t\t对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p>\n  <figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">_config.yml</span></span><br><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>  ​\t当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] </code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 </p>\n<h3 id=\"图片插件\"><a href=\"#图片插件\" class=\"headerlink\" title=\"图片插件\"></a>图片插件</h3><p>  ​\t插件hexo-renderer-marked解决了这个问题。可以只用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在<code>config.yaml</code>中更改配置如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">marked:</span></span><br><span class=\"line\">  <span class=\"attr\">prependRoot:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">postAsset:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t\t之后就可以在使用<code>![](image.jpg)</code>的方式愉快的插入图片了。</p>"},{"title":"Video for Linux two(简称v4l2)","date":"2023-04-13T03:56:11.000Z","comments":0,"description":null,"typora-root-url":"1-V4l2","_content":"\n<div align = \"center\">Video for Linux two(简称v4l2)</div>\n\n\n# 一、概述\n\n vl42是video for Linux 2的缩写，是一套Linux内核视频设备的驱动框架，该驱动框架为应用层提供一套统一的操作接口(一系列的ioctl)。包括一套数据结构和底层V4L2驱动接口。只能在Linux下使用。\n\n<!--more-->\n\nV4L2在设计时，是要支持很多广泛的设备的，它们之中只有一部分在本质上是真正的视频设备，可以支持多种设备,它可以有以下几种接口\n\nvideo capture interface：视频采集接口，这种接口应用于摄像头，v4l2在最初设计的时候就是应用于这种功能\n\nvideo output interface：视频输出接口，将静止图像或图像序列编码为模拟视频信号，通过此接口，应用程序可以控制编码过程并将图像从用户空间移动到驱动程序\n\nvideo overlay interface：视频直接传输接口，可以将采集到的视频数据直接传输到显示设备，不需要cpu参与，这种方式的显示图像的效率比其他方式高得多\n\n其他接口这里就不介绍了，下面来看一下v4l2的API\n\n\n# 二、作用\n\n它使程序有发现设备和操作设备的能力。它主要是用一系列的回调函数来实现这些功能。像设置摄像头的频率、帧频、视频压缩格式和图像参数等等。并使得它们的输出标准化。当然也可以用于其他多媒体的开发，如音频等。\n\n# 三、存放位置\n\n在Linux下，所有外设都被看成一种特殊的文件，成为“设备文件”，可以象访问普通文件一样对其进行读写。一般来说，采用V4L2驱动的摄像头设备文是/dev/v4l/video0。为了通用，可以建立一个到/dev/video0的链接。V4L2支持两种方式来采集图像：内存映射方式(mmap)和直接读取方式(read)。V4L2在include/linux/videodev.h文件中定义了一些重要的数据结构，在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据。Linux系统V4L2的能力可在Linux内核编译阶段配置，默认情况下都有此开发接口。V4L2从Linux 2.5.x版本的内核中开始出现。结构体详细参数可以在/include/uapi/linux/videodev2.h中查看。\n\n# 四、V4l2框架操作流程\n\n```c\n//1.打开视频设备文件\nint fd = open(\"/dev/video0\",O_RDWR);\n//2.查询视频设备属性，如：是否具有视频输入或者音频输入输出等\nioctl(fd,VIDIOC_QUERYCAP,&cap);\n//3.选择视频输入，一个视频设备可以有多个视频输入\n//4.设置视频采集的参数:视频的制式，图像的采集窗口，帧格式，帧率，旋转方式\nioctl(fd,VIDIOC_S_FMT,&fmt);\n//5.向驱动申请视频流数据的帧缓冲区，一般为4个。\nioctl(fd, VIDIOC_REQBUFS, &req);\n//6.查询帧缓冲区在内核空间中的长度和偏移量 \nioctl(fd, VIDIOC_QUERYBUF, &buf);\n//7.将申请到的帧缓冲映射到用户空间mmap，这样可以直接操作采集到的帧，不用复制\nbuffers[i].length = buf.length;\nbuffers[i].start = mmap(NULL, buffers[i].length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffers[i].offset);;\n//8.将申请到的帧缓冲全部放入视频采集输出队列，以便存放采集的数据\nioctl (fd, VIDIOC_QBUF, &buf);\n//9.开始视频采集\nioctl (fd, VIDIOC_STREAMON, &type);\n//10.出列以取得已采集数据的帧缓冲，取得原始数据\nioctl (fd, VIDIOC_DQBUF, &buf);\n//此时应用程序处理该帧缓冲区的数据，如：进行数据的处理和保存，\nfp = fopen(picture.yuv,\"w\");//保存图片\"w\"，保存视频\"a\"追加写\nfwrite(addr,1,length,fp);\nfclose(fp);\n//11.处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集\nioctl (fd, VIDIOC_QBUF, &buf);\n//12.停止视频的采集\nioctl (fd, VIDIOC_STREAMOFF, &type);\n//13.释放申请的视频帧缓冲区\nunmap;\n//14.关闭视频设备文件\nclose(fd);\n```\n\n\n\n# 五、V4l2的常用IOCTL接口命令-->>结构体介绍\n\n## 1、常用的IOCTL接口命令\n\n在内核目录include/linux/videodev2.h中定义\n\n```c\nVIDIOC_QUERYCAP        //查询驱动功能 \nVIDIOC_QUERYSTD     //检查当前视频设备支持的标准，例如PAL或NTSC。\nVIDIOC_S_INPUT\nVIDIOC_ENUMINPUT\t//枚举所有可用的输入\nVIDIOC_S_PARM\nVIDIOC_ENUM_FMT        //获取当前驱动支持的视频格式 \nVIDIOC_S_FMT        //设置当前驱动的频捕获格式 \nVIDIOC_G_FMT        //读取当前驱动的频捕获格式 \nVIDIOC_TRY_FMT        //验证当前驱动的显示格式 \nVIDIOC_CROPCAP        //查询驱动的修剪能力 \nVIDIOC_S_CROP        //设置视频信号的矩形边框 \nVIDIOC_G_CROP        //读取视频信号的矩形边框\nVIDIOC_REQBUFS\t\t //分配内存 \nVIDIOC_QUERYBUF //把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址\nVIDIOC_QBUF        //把数据从缓存中读取出来 \nVIDIOC_DQBUF        //把数据放回缓存队列 \nVIDIOC_STREAMON        //开始视频显示函数 \nVIDIOC_STREAMOFF        //结束视频显示函数 \nVIDIOC_EXPBUF        //\n```\n\n## 2、常用的结构体\n\n在内核目录include/linux/videodev2.h中定义。参见/include/uapi/linux/videodev2.h\n\n```c\nstruct v4l2_capability        //视频设备的功能，对应命令VIDIOC_QUERYCAP \nstruct v4l2_std_id        //视频制式\nstruct v4l2_input        //视频输入信息，对应命令VIDIOC_ENUMINPUT\nstruct v4l2_streamparm //结构体v4l2_streamparm来描述视频流的属性\nstruct v4l2_standard        //视频的制式，比如PAL，NTSC，对应命令VIDIOC_ENUMSTD \nstruct v4l2_format        //帧的格式，对应命令VIDIOC_G_FMT、VIDIOC_S_FMT等\nstruct v4l2_crop        //视频信号矩形边框\nstruct v4l2_requestbuffers        //申请帧缓冲，对应命令VIDIOC_REQBUFS\nstruct v4l2_buffer        //驱动中的一帧图像缓存，对应命令VIDIOC_QUERYBUF\nstruct v4l2_exportbuffer //导出fd\n```\n\n### 1、v4l2_capability\n\n```c\nstruct v4l2_capability\n{\n\tu8 driver[16]; // 驱动名字\n\tu8 card[32]; // 设备名字\n\tu8 bus_info[32]; // 设备在系统中的位置\n\tu32 version; // 驱动版本号\n\tu32 capabilities; // 设备支持的操作\n\tu32 reserved[4]; // 保留字段\n};\n```\n\n其中域 capabilities 代表设备支持的操作模式，常见的值有 V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING 表示是一个视频捕捉设备并且具有数据流控制模式；另外 driver 域需要和 struct video_device 中的 name 匹配。\n\n### 2、v4l2_input\n\n```c\nstruct v4l2_input {\n\t__u32\t     index;\t\t/*  Which input */\n\t__u8\t     name[32];\t\t/*  Label */\n\t__u32\t     type;\t\t/*  Type of input */\n\t__u32\t     audioset;\t\t/*  Associated audios (bitfield) */\n\t__u32        tuner;             /*  Associated tuner */\n\tv4l2_std_id  std;\n\t__u32\t     status;\n\t__u32\t     reserved[4];\n};\n```\n\n视频捕获的应用首先要通过VIDIOC_ENUMINPUT命令来枚举所有可用的输入。在V4L2层，这个调用会转换成调用一个驱动中对应的回调函数：\n int (*vidioc_enum_input)(struct file *file, void *private_data,  struct v4l2_input *input);\n\n### 3、v4l2_format\n\n```c\nstruct v4l2_format { \n    enum v4l2_buf_type type; \n    union { \n        struct v4l2_pix_format         pix;     /* V4L2_BUF_TYPE_VIDEO_CAPTURE */ \n        struct v4l2_window             win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */ \n        struct v4l2_vbi_format         vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */ \n        struct v4l2_sliced_vbi_format  sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */ \n        __u8   raw_data[200];                   /* user-defined */ \n    } fmt; \n}; \n \nenum v4l2_buf_type { \n    V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1, //视频捕获模式\n    V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2, \n    V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3, \n    ... \n    V4L2_BUF_TYPE_PRIVATE              = 0x80, \n}; \n   \nstruct v4l2_pix_format { \n    __u32                   width; //视频的宽\n    __u32                   height; //视频的高\n    __u32                   pixelformat; //视频数据格式\n    enum v4l2_field         field; \n    __u32                   bytesperline;   /* for padding, zero if unused */ \n    __u32                   sizeimage; \n    enum v4l2_colorspace    colorspace; \n    __u32                   priv;           /* private data, depends on pixelformat */ \n};\n```\n\n常见的捕获模式为 V4L2_BUF_TYPE_VIDEO_CAPTURE 即视频捕捉模式，在此模式下 fmt 联合体采用域 v4l2_pix_format：其中 width 为视频的宽、height 为视频的高、pixelformat 为视频数据格式（常见的值有 V4L2_PIX_FMT_YUV422P | V4L2_PIX_FMT_RGB565）、bytesperline 为一行图像占用的字节数、sizeimage 则为图像占用的总字节数、colorspace 指定设备的颜色空间。\n\n### 4、v4l2_requestbuffers\n\n```c\nstruct v4l2_requestbuffers {\n    __u32                   count;\n    enum v4l2_buf_type      type;\n    enum v4l2_memory        memory;\n    __u32                   reserved[2];\n};\nenum v4l2_memory {\n    V4L2_MEMORY_MMAP             = 1,\n    V4L2_MEMORY_USERPTR          = 2,\n    V4L2_MEMORY_OVERLAY          = 3,\n};\n```\n\nVIDIOC_REQBUFS 命令通过结构 v4l2_requestbuffers 请求驱动申请一片连续的内存用于缓存视频信息;count 指定根据图像占用空间大小申请的缓存区个数，type 为视频捕获模式，memory 为内存区的使用方式.\n\n### 5、v4l2_buffer\n\n```c\nstruct v4l2_buffer {\n    __u32   index;\t//buffer 序号 \n    enum v4l2_buf_type    type;\t//buffer 类型 \n    __u32    bytesused;\t//缓存已使用空间大小，buffer 中已使用的字节数\n    __u32    flags;\t//区分是MMAP 还是USERPTR\n    enum v4l2_field  field;\n    struct timeval    timestamp;\t//获取第一个字节时的系统时间 \n    struct v4l2_timecode   timecode;\n    __u32     sequence;\t//队列中的序号\n  \n    /* memory location */\n    enum v4l2_memory    memory;\t//缓存使用方式\n    union {\n            __u32   offset;//当前缓存与内存区起始地址的偏移，缓冲帧地址，只对MMAP 有效  \n            unsigned long   userptr;\n            struct v4l2_plane *planes;\n    } m;\n    __u32    length;\t//缓冲帧长度\n    __u32    input;\n    __u32    reserved;\t//一般用于传递物理地址值\n};\n\nstruct v4l2_plane {\n\t__u32\t\t\tbytesused;\n\t__u32\t\t\tlength;\n\tunion {\n\t\t__u32\t\tmem_offset;//offset是放在m.mem_offset中返回用户空间的\n\t\tunsigned long\tuserptr;\n\t\t__s32\t\tfd;\n\t} m;\n\t__u32\t\t\tdata_offset;\n\t__u32\t\t\treserved[11];\n};\n```\n\nflags 为缓存当前状态（常见值有 V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE，分别代表当前缓存已经映射、缓存可以采集数据、缓存可以提取数据）\n\n另外 VIDIOC_QUERYBUF，VIDIOC_QBUF 和 VIDIOC_DQBUF 命令都采用结构 v4l2_buffer 与驱动通信：VIDIOC_QBUF 命令向驱动传递应用程序已经处理完的缓存，即将缓存加入空闲可捕获视频的队列，传递的主要参数为 index；VIDIOC_DQBUF 命令向驱动获取已经存放有视频数据的缓存，v4l2_buffer 的各个域几乎都会被更新，但主要的参数也是 index，应用程序会根据 index 确定可用数据的起始地址和范围。\n\n### 6、v4l2_captureparm\n\n设置Stream参数。(主要是采集帧数)\n\n```c\nstruct v4l2_streamparm parms;\nparms.parm.capture.timeperframe.numerator=1;\nparms.parm.capture.timeperframe.denominator=60;\nrel = ioctl(fdUsbCam,VIDIOC_S_PARM, setfps);\n```\n\n对于捕获设备而言，parm.capture字段是要关注的内容，这个结构体如下：\n\n```c\nstruct v4l2_captureparm\n    {\n       __u32             capability;\n       __u32             capturemode;\n       structv4l2_fract  timeperframe;\n       __u32             extendedmode;\n       __u32          readbuffers;\n       __u32             reserved[4];\n   }; \ntimeperframe字段用于指定想要使用的帧频率，它又是一个结构体：\n    struct v4l2_fract{\n       __u32  numerator;\n       __u32  denominator;\n    };\n```\n\nnumerator和denominator所描述的系数给出的是成功的帧之间的时间间隔。numerator 分子， denominator 分母。主要表达每次帧之间时间间隔。 numerator/ denominator秒一帧。\n\n### 7、v4l2_exportbuffer\n\n```c\nstruct v4l2_exportbuffer {\n\t__u32\t\ttype; /* enum v4l2_buf_type */\n\t__u32\t\tindex;\n\t__u32\t\tplane;\n\t__u32\t\tflags;\n\t__s32\t\tfd;\n\t__u32\t\treserved[11];\n};\n```\n\n\n\n# 六、应用程序代码分析\n\n## 1、保存图像picture.yuv\n\n见code中，camera_app_pic.c\n\n```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <linux/videodev2.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <string.h>\n\ntypedef struct VideoBuffer {\n\tvoid   *start;//帧缓存mmap映射后的首地址\n\tsize_t  length;//缓存大小\n} VideoBuffer;\nVideoBuffer *buffers;//用来存放映射后的帧缓存区地址\n\nint camera_device_open(void)\n{\n\tint fd;\n\t//用阻塞模式打开摄像头设备\n\tfd = open(\"/dev/video0\",O_RDWR,0);//设备节点\n\tif(fd < 0){\n\t\tperror(\"open /dev/video0 is fail.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn fd;\n}\n\nint init_camera_attribute(int fd)\n{\n\tint numBufs;//\n\tv4l2_std_id id;\n\tstruct v4l2_format fmt;\n\tstruct v4l2_requestbuffers  req;\n\tstruct v4l2_buffer    buf;\n\n\t//检查当前视频设备支持的标准\n\tioctl(fd,VIDIOC_QUERYSTD,&id);\n\t\n\t//设置视频捕获格式\n\tmemset(&fmt,0,sizeof(fmt));\n\tfmt.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;//视频捕获模式\n\tfmt.fmt.pix.width = 640;//视频的宽\n\tfmt.fmt.pix.height = 480;//视频的高\n\tfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;//视频数据格式YUYV\n//\tfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YVU420;\n\tfmt.fmt.pix.field = V4L2_FIELD_INTERLACED;\n\n\tif(ioctl(fd,VIDIOC_S_FMT,&fmt) == -1){\n\t\tperror(\"set VIDIOC_S_FMT is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\t\n\t//分配内存，申请帧缓存，\n\tmemset(&req,0,sizeof(req));\n\treq.count = 4;//帧缓存的个数，一般不大于5\n\treq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\treq.memory = V4L2_MEMORY_MMAP;//内存区的使用方式，mmap映射\n\t\n\tif(ioctl(fd,VIDIOC_REQBUFS,&req) == -1){\n\t\tperror(\"set VIDIOC_REQBUFS is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t//获取并记录缓存的物理空间\n\tbuffers = calloc(req.count,sizeof(*buffers));\n\tfor(numBufs = 0; numBufs < req.count; numBufs ++){\n\t\tmemset(&buf,0,sizeof(buf));\n\t\tbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tbuf.memory = V4L2_MEMORY_MMAP;\n\t\tbuf.index = numBufs;//缓存编号，4帧缓存\n\n\t\t//读取缓存，查询帧缓冲区在内核空间中的长度和偏移量\n\t\tif(ioctl(fd,VIDIOC_QUERYBUF,&buf) == -1){\n\t\t\tperror(\"set VIDIOC_REQBUFS is fail\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\t // 转换成相对地址，将申请到的帧缓冲映射到用户空间mmap\n\t\tbuffers[numBufs].length = buf.length;\n\t\tbuffers[numBufs].start  = mmap(NULL,buf.length,PROT_READ|PROT_WRITE,\n\t\t\t\tMAP_SHARED,fd,buf.m.offset);\n\t\tif(buffers[numBufs].start == MAP_FAILED){\n\t\t\tperror(\"mmap is fail\");\n\t\t\texit(EXIT_FAILURE);\t\n\t\t}\n\n\t\t// 放入缓存队列\n\t\tif(ioctl(fd,VIDIOC_QBUF,&buf) == -1){\n\t\t\tperror(\"set VIDIOC_QBUF is fail\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint start_capturing(int fd)\n{\n\tenum v4l2_buf_type type;\n\n\t//开始采集数据\n\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tif(ioctl(fd,VIDIOC_STREAMON,&type) == -1){\n\t\tperror(\"start capturing is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn 0;\n}\n//保存图片\nint build_picture(void *addr,int length)\n{\n\tFILE *fp;\n\tstatic int num=0;\n\tchar picture_name[20];\n\tsprintf(picture_name,\"picture%d.yuv\",num++);\n\t\n\tfp = fopen(picture_name,\"w\");\n\tif(fp == NULL){\n\t\tperror(\"fail to open \");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfwrite(addr,1,length,fp);\n\n\tfclose(fp);\n\n\treturn 0;\n}\n\nint read_image(int fd)\n{\n\tstruct v4l2_buffer buf;\n\tmemset(&buf,0,sizeof(buf));\n\tbuf.type=V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tbuf.memory=V4L2_MEMORY_MMAP;\n\tbuf.index=0;\n\n\t//读取缓存，出列以取得已采集数据的帧缓冲，取得原始数据\n\tif(ioctl(fd,VIDIOC_DQBUF,&buf) == -1){\n\t\tperror(\"set VIDIOC_DQBUF is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t//将数据存为图片\n\tbuild_picture(buffers[buf.index].start,buffers[buf.index].length);\n\n\t//重新放入缓存队列，处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集\n\tif(ioctl(fd,VIDIOC_QBUF,&buf) == -1){\n\t\tperror(\"reset VIDIOC_QBUF is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn 0;\n\n}\n\nint when_to_read(int fd)\n{\n\tint i=0;\n\tfor(i=0;i<3;i++)//保存三张图片\n\t{\n\t\tfd_set rfds;//指定内核监测的文件描述符集合\n\t\tstruct timeval tv;//设置超时时间\n\t\tint retval;\n\n\t\tFD_ZERO(&rfds);//清空集合\n\t\tFD_SET(fd, &rfds);//将fd添加到集合中\n\n\t\ttv.tv_sec = 2;\n\t\ttv.tv_usec = 0;\n\t\t//当有数据采集好在缓冲区准备好时，开始读取缓存数据\n\t\tretval = select(fd+1, &rfds, NULL, NULL, &tv);\n\t\tif(retval == -1){\n\t\t\t perror(\"select()\");\n\t\t\t exit(EXIT_FAILURE);\n\t\t}else if(retval == 0){\n\t\t\tprintf(\"select is timeout\\n\");\n\t\t}else{\n\t\t\tread_image(fd);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint stop_capturing(int fd)\n{\n\tenum v4l2_buf_type type;\n\n\t//停止采集数据\n\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tif(ioctl(fd,VIDIOC_STREAMOFF,&type) == -1){\n\t\tperror(\"stop capturing is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn 0;\n}\n\nint uninit_camera(int fd)\n{\n\tint i;\n\t//释放申请的视频帧缓冲区\n\tfor(i=0;i<4;i++){\n\t\tif(-1 == munmap(buffers[i].start,buffers[i].length))\n\t\t{\n\t\t\tperror(\"munmap is fail\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\tfree(buffers);\n\t//关闭视频设备文件\n\tclose(fd);\n\treturn 0;\n}\nint main(int argc, const char *argv[])\n{\n\tint fd;\n\tfd = camera_device_open();\t\n\t\n\tinit_camera_attribute(fd);\n\t\n\tstart_capturing(fd);\n\t\n\twhen_to_read(fd);\n\n\tstop_capturing(fd);\n\t\n\tuninit_camera(fd);\n\n\treturn 0;\n}\n\n```\n\n\n\n## 2、保存视频video.yuv\n\n见code中，camera_app_mp4.c\n\n主要区别：fp = fopen(video_name,\"a\")，追加写的方式打开，进行采集\n\n# 七、V4l2驱动框架\n\n## 1、主要对象\n\n### 1、video_device\n\n```c\nstruct video_device\n\t\t{\n\t\t\tconst struct v4l2_file_operations *fops; \n\t\t\t//操作方法结构体\n\t\t\tstruct cdev *cdev;\t（file_opreations）\t\n\t\t\t//字符设备驱动\n\t\t\tstruct v4l2_device *v4l2_dev;\t/* v4l2_device parent */\n\t\t\tchar name[32]; \n\t\t\t//驱动的名字\n\t\t\tint minor;\n\t\t\t//次设备号\n\t\t\tvoid (*release)(struct video_device *vdev);\n\t\t\t//释放资源的函数\n\t\t\tconst struct v4l2_ioctl_ops *ioctl_ops;\n\t\t\t//ioctl的操作方法\n\t\t};\n```\n\n  一个字符设备，为用户空间提供设备节点(/dev/videox)，提供系统调用的相关操作(open、ioctl…) \n\n可以看到video_device中含有一个cdev还有v4l2_device，此外还有fops和ioctl_ops，从应用层进行系统调用会经过v4l2的核心层回调到这里 \n\n#### v4l2_file_operations\n\n```c\nstruct v4l2_file_operations {\n\tstruct module *owner;\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tunsigned int (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tunsigned long (*get_unmapped_area) (struct file *, unsigned long,\n\t\t\t\tunsigned long, unsigned long, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tint (*open) (struct file *);\n\tint (*release) (struct file *);\n};\n\n```\n\n#### v4l2_ioctl_ops\n\n```c\nstruct v4l2_ioctl_ops {\n\tint (*vidioc_querycap)(struct file *file, void *fh, struct v4l2_capability *cap);\n\t/* Buffer handlers */\n\tint (*vidioc_reqbufs) (struct file *file, void *fh, struct v4l2_requestbuffers *b);\n\tint (*vidioc_querybuf)(struct file *file, void *fh, struct v4l2_buffer *b);\n\tint (*vidioc_qbuf)    (struct file *file, void *fh, struct v4l2_buffer *b);\n\tint (*vidioc_dqbuf)   (struct file *file, void *fh, struct v4l2_buffer *b);\n    /* Stream on/off */\n\tint (*vidioc_streamon) (struct file *file, void *fh, enum v4l2_buf_type i);\n\tint (*vidioc_streamoff)(struct file *file, void *fh, enum v4l2_buf_type i);\n   \t...\n};\n```\n\n v4l2有很多ioctl操作，具体实现都在这里 \n\n### 2、v4l2_device\n\n```c\nstruct v4l2_device {\n\t/* used to keep track of the registered subdevs */\n\tstruct list_head subdevs;\n    ...\n};\n```\n\n  嵌入到video_device中，表示一个v4l2设备的实例 \n\n可以看到v4l2_device中有一个v4l2_subdev的链表，v4l2_device的主要目的时用来管理v4l2_subdev \n\n### 3、v4l2_subdev\n\n```c\nstruct v4l2_subdev {\n\tstruct list_head list;\n\tstruct v4l2_device *v4l2_dev;\n\tconst struct v4l2_subdev_ops *ops;\n};\n```\n\n 依附在v4l2_device之下，并表示一个v4l2设备的子设备，一个v4l2_devide下可以有多个sub_device \n\n v4l2_subdev中有一个v4l2_subdev_ops，实现了一系列的操作，供v4l2_device调用 \n\n **subdev的设计目的是为了多路复用，就是用一个v4l2_device可以服务多个v4l2_subdev** \n\n### 4、V4l2提供的注册接口\n\n```c\nint video_register_device(struct video_device *vdev, int type, int nr);//video_device注册\nvoid video_unregister_device(struct video_device *vdev);//video_device注销\nint v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev);//v4l2_device注册\nvoid v4l2_device_unregister(struct v4l2_device *v4l2_dev);//v4l2_device注销\nint v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,struct v4l2_subdev *sd);//v4l2_subdev注册\nvoid v4l2_device_unregister_subdev(struct v4l2_subdev *sd);//v4l2_subdev注销\n\n```\n\n\n\n## 2、图示\n\n<img src=\"1.png\"  />\n\n<img src=\"2.png\"  />\n\n<img src=\"3.png\" style=\"zoom:80%;\" />\n\n## 3、主要框架\n\n```c\n#include <...>\n\nstatic struct video_device* video_dev;\nstatic struct v4l2_device v4l2_dev;\n\n/* 实现各种系统调用 */\nstatic const struct v4l2_file_operations video_dev_fops = {\n\t.owner\t\t    = THIS_MODULE,\n\t.release        = vdev_close,\n\t.read           = vdev_read,\n\t.poll\t\t    = vdev_poll,\n\t.ioctl          = video_ioctl2,\n\t.mmap           = vdev_mmap,\n};\n\n/* 实现各种系统调用 */\nstatic const struct v4l2_ioctl_ops video_dev_ioctl_ops = {\n\t.vidioc_querycap      = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,\n\t.vidioc_reqbufs       = vidioc_reqbufs,\n\t.vidioc_querybuf      = vidioc_querybuf,\n\t.vidioc_qbuf          = vidioc_qbuf,\n\t.vidioc_dqbuf         = vidioc_dqbuf,\n\t.vidioc_enum_input    = vidioc_enum_input,\n\t.vidioc_g_input       = vidioc_g_input,\n\t.vidioc_s_input       = vidioc_s_input,\n\t.vidioc_streamon      = vidioc_streamon,\n\t.vidioc_streamoff     = vidioc_streamoff,\n};\n\nstatic int __init video_init(void)\n{\n    /* 分配并设置一个video_device */\n    video_dev = video_device_alloc();\n    video_dev->fops = &video_dev_fops;\n    video_dev->ioctl_ops = &video_dev_ioctl_ops;\n    video_dev->release = video_device_release;\n    video_dev->tvnorms = V4L2_STD_525_60;\n    video_dev->current_norm = V4L2_STD_NTSC_M;\n\n    /* 注册一个v4l2_device */\n    v4l2_device_register(video_dev->dev, &v4l2_dev);    \n    video_dev->v4l2_dev = &video_dev;\n\n    /* 注册一个video_device字符设备 */\n    video_register_device(video_dev, VFL_TYPE_GRABBER, -1);\n\n    return 0;\n}\n\nstatic void __exit video_exit(void)\n{\n    //注销\n    video_unregister_device(video_dev);\n    v4l2_device_unregister(&v4l2_dev);\n    video_device_release(video_dev);\n}\n\nmodule_init(video_init);\nmodule_exit(video_exit);\nMODULE_LICENSE(\"GPL\")\n```\n\n# 八、多路video输入分析\n\n## 1、多路操作流程\n\n```c\n//1.设备初始化\n_Init(){\n    _open()｛\n        fd[i] = open(dev_name[i], O_RDWR /* required */  | O_NONBLOCK, 0);\n    ioctl(fd[i], VIDIOC_S_INPUT, &inp);//设置输入\n    ioctl(fd[i], VIDIOC_S_PARM, &parms);//主要用来设置采集帧数\n        ｝;//打开设备节点\n    _Fmtset()｛\n        ioctl(fd[i], VIDIOC_S_FMT, &fmt);//设置\n        ioctl(fd[i], VIDIOC_G_FMT, &fmt);//查询，判断设置是否成功\n        ｝;//设置视频捕获模式\n    _BuffReq()｛\n        ioctl(fd[i], VIDIOC_REQBUFS, &req);\n        ioctl(fd[i], VIDIOC_QUERYBUF, &buf);\n        ioctl(fd[i], VIDIOC_QBUF, &buf);\n        ｝;//申请帧缓存，查询缓存转换地址，放入队列\n    _ON{\n        ioctl(fd[i], VIDIOC_STREAMON, &type);\n    };//开启视频捕获\n}\n//2.创建多线程\npthread_create(&capture_pth, NULL,Video_Capture, NULL);\n//3.采集数据\nVideo_Capture(){\n    //用select监视文件描述符，等待采集，如果有准备好的\n    select(fd[3] + 1, &fdr, NULL, NULL, &tv);//IO多路复用\n    //当准备好时，采用互斥锁的方式，唤醒休眠的数据处理函数\n    if( FD_ISSET(fd[0],&fdr) && FD_ISSET(fd[1],&fdr) && \\\n\t\tFD_ISSET(fd[2],&fdr) && FD_ISSET(fd[3],&fdr))\n\t\t{\n            _Queryaddr(){\n                ioctl(fd[i], VIDIOC_DQBUF, &buf);//出列\n                VideoPhyAddr[i] = buf.m.planes[0].m.mem_offset;\n                ioctl(fd[i], VIDIOC_QBUF, &buf);//入列\n            };\n            pthread_mutex_lock(&VideoMutex);//上锁\n            pthread_cond_signal(&VideoCond);//唤醒休眠\n            pthread_mutex_unlock(&VideoMutex);//解锁\n        }\n};\n//4.数据处理\n_LoadVideoData(){\n    pthread_mutex_lock(&VideoMutex);//上锁\n\tpthread_cond_wait(&VideoCond, &VideoMutex);//休眠\n\tpthread_mutex_unlock(&VideoMutex);//解锁\n    //************************\n    //***原始视频流数据处理***\n    //************************\n};\n```\n\n","source":"_posts/1-V4l2.md","raw":"---\ntitle: Video for Linux two(简称v4l2)\ndate: 2023-4-13 11:56:11\ncategories: 笔记\ntags: 嵌入式\ncomments: false\ndescription: \ntypora-root-url: 1-V4l2\n---\n\n<div align = \"center\">Video for Linux two(简称v4l2)</div>\n\n\n# 一、概述\n\n vl42是video for Linux 2的缩写，是一套Linux内核视频设备的驱动框架，该驱动框架为应用层提供一套统一的操作接口(一系列的ioctl)。包括一套数据结构和底层V4L2驱动接口。只能在Linux下使用。\n\n<!--more-->\n\nV4L2在设计时，是要支持很多广泛的设备的，它们之中只有一部分在本质上是真正的视频设备，可以支持多种设备,它可以有以下几种接口\n\nvideo capture interface：视频采集接口，这种接口应用于摄像头，v4l2在最初设计的时候就是应用于这种功能\n\nvideo output interface：视频输出接口，将静止图像或图像序列编码为模拟视频信号，通过此接口，应用程序可以控制编码过程并将图像从用户空间移动到驱动程序\n\nvideo overlay interface：视频直接传输接口，可以将采集到的视频数据直接传输到显示设备，不需要cpu参与，这种方式的显示图像的效率比其他方式高得多\n\n其他接口这里就不介绍了，下面来看一下v4l2的API\n\n\n# 二、作用\n\n它使程序有发现设备和操作设备的能力。它主要是用一系列的回调函数来实现这些功能。像设置摄像头的频率、帧频、视频压缩格式和图像参数等等。并使得它们的输出标准化。当然也可以用于其他多媒体的开发，如音频等。\n\n# 三、存放位置\n\n在Linux下，所有外设都被看成一种特殊的文件，成为“设备文件”，可以象访问普通文件一样对其进行读写。一般来说，采用V4L2驱动的摄像头设备文是/dev/v4l/video0。为了通用，可以建立一个到/dev/video0的链接。V4L2支持两种方式来采集图像：内存映射方式(mmap)和直接读取方式(read)。V4L2在include/linux/videodev.h文件中定义了一些重要的数据结构，在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据。Linux系统V4L2的能力可在Linux内核编译阶段配置，默认情况下都有此开发接口。V4L2从Linux 2.5.x版本的内核中开始出现。结构体详细参数可以在/include/uapi/linux/videodev2.h中查看。\n\n# 四、V4l2框架操作流程\n\n```c\n//1.打开视频设备文件\nint fd = open(\"/dev/video0\",O_RDWR);\n//2.查询视频设备属性，如：是否具有视频输入或者音频输入输出等\nioctl(fd,VIDIOC_QUERYCAP,&cap);\n//3.选择视频输入，一个视频设备可以有多个视频输入\n//4.设置视频采集的参数:视频的制式，图像的采集窗口，帧格式，帧率，旋转方式\nioctl(fd,VIDIOC_S_FMT,&fmt);\n//5.向驱动申请视频流数据的帧缓冲区，一般为4个。\nioctl(fd, VIDIOC_REQBUFS, &req);\n//6.查询帧缓冲区在内核空间中的长度和偏移量 \nioctl(fd, VIDIOC_QUERYBUF, &buf);\n//7.将申请到的帧缓冲映射到用户空间mmap，这样可以直接操作采集到的帧，不用复制\nbuffers[i].length = buf.length;\nbuffers[i].start = mmap(NULL, buffers[i].length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffers[i].offset);;\n//8.将申请到的帧缓冲全部放入视频采集输出队列，以便存放采集的数据\nioctl (fd, VIDIOC_QBUF, &buf);\n//9.开始视频采集\nioctl (fd, VIDIOC_STREAMON, &type);\n//10.出列以取得已采集数据的帧缓冲，取得原始数据\nioctl (fd, VIDIOC_DQBUF, &buf);\n//此时应用程序处理该帧缓冲区的数据，如：进行数据的处理和保存，\nfp = fopen(picture.yuv,\"w\");//保存图片\"w\"，保存视频\"a\"追加写\nfwrite(addr,1,length,fp);\nfclose(fp);\n//11.处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集\nioctl (fd, VIDIOC_QBUF, &buf);\n//12.停止视频的采集\nioctl (fd, VIDIOC_STREAMOFF, &type);\n//13.释放申请的视频帧缓冲区\nunmap;\n//14.关闭视频设备文件\nclose(fd);\n```\n\n\n\n# 五、V4l2的常用IOCTL接口命令-->>结构体介绍\n\n## 1、常用的IOCTL接口命令\n\n在内核目录include/linux/videodev2.h中定义\n\n```c\nVIDIOC_QUERYCAP        //查询驱动功能 \nVIDIOC_QUERYSTD     //检查当前视频设备支持的标准，例如PAL或NTSC。\nVIDIOC_S_INPUT\nVIDIOC_ENUMINPUT\t//枚举所有可用的输入\nVIDIOC_S_PARM\nVIDIOC_ENUM_FMT        //获取当前驱动支持的视频格式 \nVIDIOC_S_FMT        //设置当前驱动的频捕获格式 \nVIDIOC_G_FMT        //读取当前驱动的频捕获格式 \nVIDIOC_TRY_FMT        //验证当前驱动的显示格式 \nVIDIOC_CROPCAP        //查询驱动的修剪能力 \nVIDIOC_S_CROP        //设置视频信号的矩形边框 \nVIDIOC_G_CROP        //读取视频信号的矩形边框\nVIDIOC_REQBUFS\t\t //分配内存 \nVIDIOC_QUERYBUF //把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址\nVIDIOC_QBUF        //把数据从缓存中读取出来 \nVIDIOC_DQBUF        //把数据放回缓存队列 \nVIDIOC_STREAMON        //开始视频显示函数 \nVIDIOC_STREAMOFF        //结束视频显示函数 \nVIDIOC_EXPBUF        //\n```\n\n## 2、常用的结构体\n\n在内核目录include/linux/videodev2.h中定义。参见/include/uapi/linux/videodev2.h\n\n```c\nstruct v4l2_capability        //视频设备的功能，对应命令VIDIOC_QUERYCAP \nstruct v4l2_std_id        //视频制式\nstruct v4l2_input        //视频输入信息，对应命令VIDIOC_ENUMINPUT\nstruct v4l2_streamparm //结构体v4l2_streamparm来描述视频流的属性\nstruct v4l2_standard        //视频的制式，比如PAL，NTSC，对应命令VIDIOC_ENUMSTD \nstruct v4l2_format        //帧的格式，对应命令VIDIOC_G_FMT、VIDIOC_S_FMT等\nstruct v4l2_crop        //视频信号矩形边框\nstruct v4l2_requestbuffers        //申请帧缓冲，对应命令VIDIOC_REQBUFS\nstruct v4l2_buffer        //驱动中的一帧图像缓存，对应命令VIDIOC_QUERYBUF\nstruct v4l2_exportbuffer //导出fd\n```\n\n### 1、v4l2_capability\n\n```c\nstruct v4l2_capability\n{\n\tu8 driver[16]; // 驱动名字\n\tu8 card[32]; // 设备名字\n\tu8 bus_info[32]; // 设备在系统中的位置\n\tu32 version; // 驱动版本号\n\tu32 capabilities; // 设备支持的操作\n\tu32 reserved[4]; // 保留字段\n};\n```\n\n其中域 capabilities 代表设备支持的操作模式，常见的值有 V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING 表示是一个视频捕捉设备并且具有数据流控制模式；另外 driver 域需要和 struct video_device 中的 name 匹配。\n\n### 2、v4l2_input\n\n```c\nstruct v4l2_input {\n\t__u32\t     index;\t\t/*  Which input */\n\t__u8\t     name[32];\t\t/*  Label */\n\t__u32\t     type;\t\t/*  Type of input */\n\t__u32\t     audioset;\t\t/*  Associated audios (bitfield) */\n\t__u32        tuner;             /*  Associated tuner */\n\tv4l2_std_id  std;\n\t__u32\t     status;\n\t__u32\t     reserved[4];\n};\n```\n\n视频捕获的应用首先要通过VIDIOC_ENUMINPUT命令来枚举所有可用的输入。在V4L2层，这个调用会转换成调用一个驱动中对应的回调函数：\n int (*vidioc_enum_input)(struct file *file, void *private_data,  struct v4l2_input *input);\n\n### 3、v4l2_format\n\n```c\nstruct v4l2_format { \n    enum v4l2_buf_type type; \n    union { \n        struct v4l2_pix_format         pix;     /* V4L2_BUF_TYPE_VIDEO_CAPTURE */ \n        struct v4l2_window             win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */ \n        struct v4l2_vbi_format         vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */ \n        struct v4l2_sliced_vbi_format  sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */ \n        __u8   raw_data[200];                   /* user-defined */ \n    } fmt; \n}; \n \nenum v4l2_buf_type { \n    V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1, //视频捕获模式\n    V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2, \n    V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3, \n    ... \n    V4L2_BUF_TYPE_PRIVATE              = 0x80, \n}; \n   \nstruct v4l2_pix_format { \n    __u32                   width; //视频的宽\n    __u32                   height; //视频的高\n    __u32                   pixelformat; //视频数据格式\n    enum v4l2_field         field; \n    __u32                   bytesperline;   /* for padding, zero if unused */ \n    __u32                   sizeimage; \n    enum v4l2_colorspace    colorspace; \n    __u32                   priv;           /* private data, depends on pixelformat */ \n};\n```\n\n常见的捕获模式为 V4L2_BUF_TYPE_VIDEO_CAPTURE 即视频捕捉模式，在此模式下 fmt 联合体采用域 v4l2_pix_format：其中 width 为视频的宽、height 为视频的高、pixelformat 为视频数据格式（常见的值有 V4L2_PIX_FMT_YUV422P | V4L2_PIX_FMT_RGB565）、bytesperline 为一行图像占用的字节数、sizeimage 则为图像占用的总字节数、colorspace 指定设备的颜色空间。\n\n### 4、v4l2_requestbuffers\n\n```c\nstruct v4l2_requestbuffers {\n    __u32                   count;\n    enum v4l2_buf_type      type;\n    enum v4l2_memory        memory;\n    __u32                   reserved[2];\n};\nenum v4l2_memory {\n    V4L2_MEMORY_MMAP             = 1,\n    V4L2_MEMORY_USERPTR          = 2,\n    V4L2_MEMORY_OVERLAY          = 3,\n};\n```\n\nVIDIOC_REQBUFS 命令通过结构 v4l2_requestbuffers 请求驱动申请一片连续的内存用于缓存视频信息;count 指定根据图像占用空间大小申请的缓存区个数，type 为视频捕获模式，memory 为内存区的使用方式.\n\n### 5、v4l2_buffer\n\n```c\nstruct v4l2_buffer {\n    __u32   index;\t//buffer 序号 \n    enum v4l2_buf_type    type;\t//buffer 类型 \n    __u32    bytesused;\t//缓存已使用空间大小，buffer 中已使用的字节数\n    __u32    flags;\t//区分是MMAP 还是USERPTR\n    enum v4l2_field  field;\n    struct timeval    timestamp;\t//获取第一个字节时的系统时间 \n    struct v4l2_timecode   timecode;\n    __u32     sequence;\t//队列中的序号\n  \n    /* memory location */\n    enum v4l2_memory    memory;\t//缓存使用方式\n    union {\n            __u32   offset;//当前缓存与内存区起始地址的偏移，缓冲帧地址，只对MMAP 有效  \n            unsigned long   userptr;\n            struct v4l2_plane *planes;\n    } m;\n    __u32    length;\t//缓冲帧长度\n    __u32    input;\n    __u32    reserved;\t//一般用于传递物理地址值\n};\n\nstruct v4l2_plane {\n\t__u32\t\t\tbytesused;\n\t__u32\t\t\tlength;\n\tunion {\n\t\t__u32\t\tmem_offset;//offset是放在m.mem_offset中返回用户空间的\n\t\tunsigned long\tuserptr;\n\t\t__s32\t\tfd;\n\t} m;\n\t__u32\t\t\tdata_offset;\n\t__u32\t\t\treserved[11];\n};\n```\n\nflags 为缓存当前状态（常见值有 V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE，分别代表当前缓存已经映射、缓存可以采集数据、缓存可以提取数据）\n\n另外 VIDIOC_QUERYBUF，VIDIOC_QBUF 和 VIDIOC_DQBUF 命令都采用结构 v4l2_buffer 与驱动通信：VIDIOC_QBUF 命令向驱动传递应用程序已经处理完的缓存，即将缓存加入空闲可捕获视频的队列，传递的主要参数为 index；VIDIOC_DQBUF 命令向驱动获取已经存放有视频数据的缓存，v4l2_buffer 的各个域几乎都会被更新，但主要的参数也是 index，应用程序会根据 index 确定可用数据的起始地址和范围。\n\n### 6、v4l2_captureparm\n\n设置Stream参数。(主要是采集帧数)\n\n```c\nstruct v4l2_streamparm parms;\nparms.parm.capture.timeperframe.numerator=1;\nparms.parm.capture.timeperframe.denominator=60;\nrel = ioctl(fdUsbCam,VIDIOC_S_PARM, setfps);\n```\n\n对于捕获设备而言，parm.capture字段是要关注的内容，这个结构体如下：\n\n```c\nstruct v4l2_captureparm\n    {\n       __u32             capability;\n       __u32             capturemode;\n       structv4l2_fract  timeperframe;\n       __u32             extendedmode;\n       __u32          readbuffers;\n       __u32             reserved[4];\n   }; \ntimeperframe字段用于指定想要使用的帧频率，它又是一个结构体：\n    struct v4l2_fract{\n       __u32  numerator;\n       __u32  denominator;\n    };\n```\n\nnumerator和denominator所描述的系数给出的是成功的帧之间的时间间隔。numerator 分子， denominator 分母。主要表达每次帧之间时间间隔。 numerator/ denominator秒一帧。\n\n### 7、v4l2_exportbuffer\n\n```c\nstruct v4l2_exportbuffer {\n\t__u32\t\ttype; /* enum v4l2_buf_type */\n\t__u32\t\tindex;\n\t__u32\t\tplane;\n\t__u32\t\tflags;\n\t__s32\t\tfd;\n\t__u32\t\treserved[11];\n};\n```\n\n\n\n# 六、应用程序代码分析\n\n## 1、保存图像picture.yuv\n\n见code中，camera_app_pic.c\n\n```c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <linux/videodev2.h>\n#include <sys/ioctl.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <string.h>\n\ntypedef struct VideoBuffer {\n\tvoid   *start;//帧缓存mmap映射后的首地址\n\tsize_t  length;//缓存大小\n} VideoBuffer;\nVideoBuffer *buffers;//用来存放映射后的帧缓存区地址\n\nint camera_device_open(void)\n{\n\tint fd;\n\t//用阻塞模式打开摄像头设备\n\tfd = open(\"/dev/video0\",O_RDWR,0);//设备节点\n\tif(fd < 0){\n\t\tperror(\"open /dev/video0 is fail.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn fd;\n}\n\nint init_camera_attribute(int fd)\n{\n\tint numBufs;//\n\tv4l2_std_id id;\n\tstruct v4l2_format fmt;\n\tstruct v4l2_requestbuffers  req;\n\tstruct v4l2_buffer    buf;\n\n\t//检查当前视频设备支持的标准\n\tioctl(fd,VIDIOC_QUERYSTD,&id);\n\t\n\t//设置视频捕获格式\n\tmemset(&fmt,0,sizeof(fmt));\n\tfmt.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;//视频捕获模式\n\tfmt.fmt.pix.width = 640;//视频的宽\n\tfmt.fmt.pix.height = 480;//视频的高\n\tfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;//视频数据格式YUYV\n//\tfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YVU420;\n\tfmt.fmt.pix.field = V4L2_FIELD_INTERLACED;\n\n\tif(ioctl(fd,VIDIOC_S_FMT,&fmt) == -1){\n\t\tperror(\"set VIDIOC_S_FMT is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\t\n\t//分配内存，申请帧缓存，\n\tmemset(&req,0,sizeof(req));\n\treq.count = 4;//帧缓存的个数，一般不大于5\n\treq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\treq.memory = V4L2_MEMORY_MMAP;//内存区的使用方式，mmap映射\n\t\n\tif(ioctl(fd,VIDIOC_REQBUFS,&req) == -1){\n\t\tperror(\"set VIDIOC_REQBUFS is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t//获取并记录缓存的物理空间\n\tbuffers = calloc(req.count,sizeof(*buffers));\n\tfor(numBufs = 0; numBufs < req.count; numBufs ++){\n\t\tmemset(&buf,0,sizeof(buf));\n\t\tbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\t\tbuf.memory = V4L2_MEMORY_MMAP;\n\t\tbuf.index = numBufs;//缓存编号，4帧缓存\n\n\t\t//读取缓存，查询帧缓冲区在内核空间中的长度和偏移量\n\t\tif(ioctl(fd,VIDIOC_QUERYBUF,&buf) == -1){\n\t\t\tperror(\"set VIDIOC_REQBUFS is fail\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\t // 转换成相对地址，将申请到的帧缓冲映射到用户空间mmap\n\t\tbuffers[numBufs].length = buf.length;\n\t\tbuffers[numBufs].start  = mmap(NULL,buf.length,PROT_READ|PROT_WRITE,\n\t\t\t\tMAP_SHARED,fd,buf.m.offset);\n\t\tif(buffers[numBufs].start == MAP_FAILED){\n\t\t\tperror(\"mmap is fail\");\n\t\t\texit(EXIT_FAILURE);\t\n\t\t}\n\n\t\t// 放入缓存队列\n\t\tif(ioctl(fd,VIDIOC_QBUF,&buf) == -1){\n\t\t\tperror(\"set VIDIOC_QBUF is fail\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint start_capturing(int fd)\n{\n\tenum v4l2_buf_type type;\n\n\t//开始采集数据\n\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tif(ioctl(fd,VIDIOC_STREAMON,&type) == -1){\n\t\tperror(\"start capturing is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn 0;\n}\n//保存图片\nint build_picture(void *addr,int length)\n{\n\tFILE *fp;\n\tstatic int num=0;\n\tchar picture_name[20];\n\tsprintf(picture_name,\"picture%d.yuv\",num++);\n\t\n\tfp = fopen(picture_name,\"w\");\n\tif(fp == NULL){\n\t\tperror(\"fail to open \");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfwrite(addr,1,length,fp);\n\n\tfclose(fp);\n\n\treturn 0;\n}\n\nint read_image(int fd)\n{\n\tstruct v4l2_buffer buf;\n\tmemset(&buf,0,sizeof(buf));\n\tbuf.type=V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tbuf.memory=V4L2_MEMORY_MMAP;\n\tbuf.index=0;\n\n\t//读取缓存，出列以取得已采集数据的帧缓冲，取得原始数据\n\tif(ioctl(fd,VIDIOC_DQBUF,&buf) == -1){\n\t\tperror(\"set VIDIOC_DQBUF is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t//将数据存为图片\n\tbuild_picture(buffers[buf.index].start,buffers[buf.index].length);\n\n\t//重新放入缓存队列，处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集\n\tif(ioctl(fd,VIDIOC_QBUF,&buf) == -1){\n\t\tperror(\"reset VIDIOC_QBUF is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn 0;\n\n}\n\nint when_to_read(int fd)\n{\n\tint i=0;\n\tfor(i=0;i<3;i++)//保存三张图片\n\t{\n\t\tfd_set rfds;//指定内核监测的文件描述符集合\n\t\tstruct timeval tv;//设置超时时间\n\t\tint retval;\n\n\t\tFD_ZERO(&rfds);//清空集合\n\t\tFD_SET(fd, &rfds);//将fd添加到集合中\n\n\t\ttv.tv_sec = 2;\n\t\ttv.tv_usec = 0;\n\t\t//当有数据采集好在缓冲区准备好时，开始读取缓存数据\n\t\tretval = select(fd+1, &rfds, NULL, NULL, &tv);\n\t\tif(retval == -1){\n\t\t\t perror(\"select()\");\n\t\t\t exit(EXIT_FAILURE);\n\t\t}else if(retval == 0){\n\t\t\tprintf(\"select is timeout\\n\");\n\t\t}else{\n\t\t\tread_image(fd);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint stop_capturing(int fd)\n{\n\tenum v4l2_buf_type type;\n\n\t//停止采集数据\n\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\tif(ioctl(fd,VIDIOC_STREAMOFF,&type) == -1){\n\t\tperror(\"stop capturing is fail\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\treturn 0;\n}\n\nint uninit_camera(int fd)\n{\n\tint i;\n\t//释放申请的视频帧缓冲区\n\tfor(i=0;i<4;i++){\n\t\tif(-1 == munmap(buffers[i].start,buffers[i].length))\n\t\t{\n\t\t\tperror(\"munmap is fail\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\tfree(buffers);\n\t//关闭视频设备文件\n\tclose(fd);\n\treturn 0;\n}\nint main(int argc, const char *argv[])\n{\n\tint fd;\n\tfd = camera_device_open();\t\n\t\n\tinit_camera_attribute(fd);\n\t\n\tstart_capturing(fd);\n\t\n\twhen_to_read(fd);\n\n\tstop_capturing(fd);\n\t\n\tuninit_camera(fd);\n\n\treturn 0;\n}\n\n```\n\n\n\n## 2、保存视频video.yuv\n\n见code中，camera_app_mp4.c\n\n主要区别：fp = fopen(video_name,\"a\")，追加写的方式打开，进行采集\n\n# 七、V4l2驱动框架\n\n## 1、主要对象\n\n### 1、video_device\n\n```c\nstruct video_device\n\t\t{\n\t\t\tconst struct v4l2_file_operations *fops; \n\t\t\t//操作方法结构体\n\t\t\tstruct cdev *cdev;\t（file_opreations）\t\n\t\t\t//字符设备驱动\n\t\t\tstruct v4l2_device *v4l2_dev;\t/* v4l2_device parent */\n\t\t\tchar name[32]; \n\t\t\t//驱动的名字\n\t\t\tint minor;\n\t\t\t//次设备号\n\t\t\tvoid (*release)(struct video_device *vdev);\n\t\t\t//释放资源的函数\n\t\t\tconst struct v4l2_ioctl_ops *ioctl_ops;\n\t\t\t//ioctl的操作方法\n\t\t};\n```\n\n  一个字符设备，为用户空间提供设备节点(/dev/videox)，提供系统调用的相关操作(open、ioctl…) \n\n可以看到video_device中含有一个cdev还有v4l2_device，此外还有fops和ioctl_ops，从应用层进行系统调用会经过v4l2的核心层回调到这里 \n\n#### v4l2_file_operations\n\n```c\nstruct v4l2_file_operations {\n\tstruct module *owner;\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tunsigned int (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tunsigned long (*get_unmapped_area) (struct file *, unsigned long,\n\t\t\t\tunsigned long, unsigned long, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tint (*open) (struct file *);\n\tint (*release) (struct file *);\n};\n\n```\n\n#### v4l2_ioctl_ops\n\n```c\nstruct v4l2_ioctl_ops {\n\tint (*vidioc_querycap)(struct file *file, void *fh, struct v4l2_capability *cap);\n\t/* Buffer handlers */\n\tint (*vidioc_reqbufs) (struct file *file, void *fh, struct v4l2_requestbuffers *b);\n\tint (*vidioc_querybuf)(struct file *file, void *fh, struct v4l2_buffer *b);\n\tint (*vidioc_qbuf)    (struct file *file, void *fh, struct v4l2_buffer *b);\n\tint (*vidioc_dqbuf)   (struct file *file, void *fh, struct v4l2_buffer *b);\n    /* Stream on/off */\n\tint (*vidioc_streamon) (struct file *file, void *fh, enum v4l2_buf_type i);\n\tint (*vidioc_streamoff)(struct file *file, void *fh, enum v4l2_buf_type i);\n   \t...\n};\n```\n\n v4l2有很多ioctl操作，具体实现都在这里 \n\n### 2、v4l2_device\n\n```c\nstruct v4l2_device {\n\t/* used to keep track of the registered subdevs */\n\tstruct list_head subdevs;\n    ...\n};\n```\n\n  嵌入到video_device中，表示一个v4l2设备的实例 \n\n可以看到v4l2_device中有一个v4l2_subdev的链表，v4l2_device的主要目的时用来管理v4l2_subdev \n\n### 3、v4l2_subdev\n\n```c\nstruct v4l2_subdev {\n\tstruct list_head list;\n\tstruct v4l2_device *v4l2_dev;\n\tconst struct v4l2_subdev_ops *ops;\n};\n```\n\n 依附在v4l2_device之下，并表示一个v4l2设备的子设备，一个v4l2_devide下可以有多个sub_device \n\n v4l2_subdev中有一个v4l2_subdev_ops，实现了一系列的操作，供v4l2_device调用 \n\n **subdev的设计目的是为了多路复用，就是用一个v4l2_device可以服务多个v4l2_subdev** \n\n### 4、V4l2提供的注册接口\n\n```c\nint video_register_device(struct video_device *vdev, int type, int nr);//video_device注册\nvoid video_unregister_device(struct video_device *vdev);//video_device注销\nint v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev);//v4l2_device注册\nvoid v4l2_device_unregister(struct v4l2_device *v4l2_dev);//v4l2_device注销\nint v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,struct v4l2_subdev *sd);//v4l2_subdev注册\nvoid v4l2_device_unregister_subdev(struct v4l2_subdev *sd);//v4l2_subdev注销\n\n```\n\n\n\n## 2、图示\n\n<img src=\"1.png\"  />\n\n<img src=\"2.png\"  />\n\n<img src=\"3.png\" style=\"zoom:80%;\" />\n\n## 3、主要框架\n\n```c\n#include <...>\n\nstatic struct video_device* video_dev;\nstatic struct v4l2_device v4l2_dev;\n\n/* 实现各种系统调用 */\nstatic const struct v4l2_file_operations video_dev_fops = {\n\t.owner\t\t    = THIS_MODULE,\n\t.release        = vdev_close,\n\t.read           = vdev_read,\n\t.poll\t\t    = vdev_poll,\n\t.ioctl          = video_ioctl2,\n\t.mmap           = vdev_mmap,\n};\n\n/* 实现各种系统调用 */\nstatic const struct v4l2_ioctl_ops video_dev_ioctl_ops = {\n\t.vidioc_querycap      = vidioc_querycap,\n\t.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,\n\t.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,\n\t.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,\n\t.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,\n\t.vidioc_reqbufs       = vidioc_reqbufs,\n\t.vidioc_querybuf      = vidioc_querybuf,\n\t.vidioc_qbuf          = vidioc_qbuf,\n\t.vidioc_dqbuf         = vidioc_dqbuf,\n\t.vidioc_enum_input    = vidioc_enum_input,\n\t.vidioc_g_input       = vidioc_g_input,\n\t.vidioc_s_input       = vidioc_s_input,\n\t.vidioc_streamon      = vidioc_streamon,\n\t.vidioc_streamoff     = vidioc_streamoff,\n};\n\nstatic int __init video_init(void)\n{\n    /* 分配并设置一个video_device */\n    video_dev = video_device_alloc();\n    video_dev->fops = &video_dev_fops;\n    video_dev->ioctl_ops = &video_dev_ioctl_ops;\n    video_dev->release = video_device_release;\n    video_dev->tvnorms = V4L2_STD_525_60;\n    video_dev->current_norm = V4L2_STD_NTSC_M;\n\n    /* 注册一个v4l2_device */\n    v4l2_device_register(video_dev->dev, &v4l2_dev);    \n    video_dev->v4l2_dev = &video_dev;\n\n    /* 注册一个video_device字符设备 */\n    video_register_device(video_dev, VFL_TYPE_GRABBER, -1);\n\n    return 0;\n}\n\nstatic void __exit video_exit(void)\n{\n    //注销\n    video_unregister_device(video_dev);\n    v4l2_device_unregister(&v4l2_dev);\n    video_device_release(video_dev);\n}\n\nmodule_init(video_init);\nmodule_exit(video_exit);\nMODULE_LICENSE(\"GPL\")\n```\n\n# 八、多路video输入分析\n\n## 1、多路操作流程\n\n```c\n//1.设备初始化\n_Init(){\n    _open()｛\n        fd[i] = open(dev_name[i], O_RDWR /* required */  | O_NONBLOCK, 0);\n    ioctl(fd[i], VIDIOC_S_INPUT, &inp);//设置输入\n    ioctl(fd[i], VIDIOC_S_PARM, &parms);//主要用来设置采集帧数\n        ｝;//打开设备节点\n    _Fmtset()｛\n        ioctl(fd[i], VIDIOC_S_FMT, &fmt);//设置\n        ioctl(fd[i], VIDIOC_G_FMT, &fmt);//查询，判断设置是否成功\n        ｝;//设置视频捕获模式\n    _BuffReq()｛\n        ioctl(fd[i], VIDIOC_REQBUFS, &req);\n        ioctl(fd[i], VIDIOC_QUERYBUF, &buf);\n        ioctl(fd[i], VIDIOC_QBUF, &buf);\n        ｝;//申请帧缓存，查询缓存转换地址，放入队列\n    _ON{\n        ioctl(fd[i], VIDIOC_STREAMON, &type);\n    };//开启视频捕获\n}\n//2.创建多线程\npthread_create(&capture_pth, NULL,Video_Capture, NULL);\n//3.采集数据\nVideo_Capture(){\n    //用select监视文件描述符，等待采集，如果有准备好的\n    select(fd[3] + 1, &fdr, NULL, NULL, &tv);//IO多路复用\n    //当准备好时，采用互斥锁的方式，唤醒休眠的数据处理函数\n    if( FD_ISSET(fd[0],&fdr) && FD_ISSET(fd[1],&fdr) && \\\n\t\tFD_ISSET(fd[2],&fdr) && FD_ISSET(fd[3],&fdr))\n\t\t{\n            _Queryaddr(){\n                ioctl(fd[i], VIDIOC_DQBUF, &buf);//出列\n                VideoPhyAddr[i] = buf.m.planes[0].m.mem_offset;\n                ioctl(fd[i], VIDIOC_QBUF, &buf);//入列\n            };\n            pthread_mutex_lock(&VideoMutex);//上锁\n            pthread_cond_signal(&VideoCond);//唤醒休眠\n            pthread_mutex_unlock(&VideoMutex);//解锁\n        }\n};\n//4.数据处理\n_LoadVideoData(){\n    pthread_mutex_lock(&VideoMutex);//上锁\n\tpthread_cond_wait(&VideoCond, &VideoMutex);//休眠\n\tpthread_mutex_unlock(&VideoMutex);//解锁\n    //************************\n    //***原始视频流数据处理***\n    //************************\n};\n```\n\n","slug":"1-V4l2","published":1,"updated":"2023-04-13T04:21:44.991Z","_id":"clgelnnse0002rgob33xj3z9r","layout":"post","photos":[],"link":"","content":"<div align = \"center\">Video for Linux two(简称v4l2)</div>\n\n\n<h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p> vl42是video for Linux 2的缩写，是一套Linux内核视频设备的驱动框架，该驱动框架为应用层提供一套统一的操作接口(一系列的ioctl)。包括一套数据结构和底层V4L2驱动接口。只能在Linux下使用。</p>\n<span id=\"more\"></span>\n\n<p>V4L2在设计时，是要支持很多广泛的设备的，它们之中只有一部分在本质上是真正的视频设备，可以支持多种设备,它可以有以下几种接口</p>\n<p>video capture interface：视频采集接口，这种接口应用于摄像头，v4l2在最初设计的时候就是应用于这种功能</p>\n<p>video output interface：视频输出接口，将静止图像或图像序列编码为模拟视频信号，通过此接口，应用程序可以控制编码过程并将图像从用户空间移动到驱动程序</p>\n<p>video overlay interface：视频直接传输接口，可以将采集到的视频数据直接传输到显示设备，不需要cpu参与，这种方式的显示图像的效率比其他方式高得多</p>\n<p>其他接口这里就不介绍了，下面来看一下v4l2的API</p>\n<h1 id=\"二、作用\"><a href=\"#二、作用\" class=\"headerlink\" title=\"二、作用\"></a>二、作用</h1><p>它使程序有发现设备和操作设备的能力。它主要是用一系列的回调函数来实现这些功能。像设置摄像头的频率、帧频、视频压缩格式和图像参数等等。并使得它们的输出标准化。当然也可以用于其他多媒体的开发，如音频等。</p>\n<h1 id=\"三、存放位置\"><a href=\"#三、存放位置\" class=\"headerlink\" title=\"三、存放位置\"></a>三、存放位置</h1><p>在Linux下，所有外设都被看成一种特殊的文件，成为“设备文件”，可以象访问普通文件一样对其进行读写。一般来说，采用V4L2驱动的摄像头设备文是&#x2F;dev&#x2F;v4l&#x2F;video0。为了通用，可以建立一个到&#x2F;dev&#x2F;video0的链接。V4L2支持两种方式来采集图像：内存映射方式(mmap)和直接读取方式(read)。V4L2在include&#x2F;linux&#x2F;videodev.h文件中定义了一些重要的数据结构，在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据。Linux系统V4L2的能力可在Linux内核编译阶段配置，默认情况下都有此开发接口。V4L2从Linux 2.5.x版本的内核中开始出现。结构体详细参数可以在&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;videodev2.h中查看。</p>\n<h1 id=\"四、V4l2框架操作流程\"><a href=\"#四、V4l2框架操作流程\" class=\"headerlink\" title=\"四、V4l2框架操作流程\"></a>四、V4l2框架操作流程</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.打开视频设备文件</span></span><br><span class=\"line\"><span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;/dev/video0&quot;</span>,O_RDWR);</span><br><span class=\"line\"><span class=\"comment\">//2.查询视频设备属性，如：是否具有视频输入或者音频输入输出等</span></span><br><span class=\"line\">ioctl(fd,VIDIOC_QUERYCAP,&amp;cap);</span><br><span class=\"line\"><span class=\"comment\">//3.选择视频输入，一个视频设备可以有多个视频输入</span></span><br><span class=\"line\"><span class=\"comment\">//4.设置视频采集的参数:视频的制式，图像的采集窗口，帧格式，帧率，旋转方式</span></span><br><span class=\"line\">ioctl(fd,VIDIOC_S_FMT,&amp;fmt);</span><br><span class=\"line\"><span class=\"comment\">//5.向驱动申请视频流数据的帧缓冲区，一般为4个。</span></span><br><span class=\"line\">ioctl(fd, VIDIOC_REQBUFS, &amp;req);</span><br><span class=\"line\"><span class=\"comment\">//6.查询帧缓冲区在内核空间中的长度和偏移量 </span></span><br><span class=\"line\">ioctl(fd, VIDIOC_QUERYBUF, &amp;buf);</span><br><span class=\"line\"><span class=\"comment\">//7.将申请到的帧缓冲映射到用户空间mmap，这样可以直接操作采集到的帧，不用复制</span></span><br><span class=\"line\">buffers[i].length = buf.length;</span><br><span class=\"line\">buffers[i].start = mmap(<span class=\"literal\">NULL</span>, buffers[i].length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffers[i].offset);;</span><br><span class=\"line\"><span class=\"comment\">//8.将申请到的帧缓冲全部放入视频采集输出队列，以便存放采集的数据</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_QBUF, &amp;buf);</span><br><span class=\"line\"><span class=\"comment\">//9.开始视频采集</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_STREAMON, &amp;type);</span><br><span class=\"line\"><span class=\"comment\">//10.出列以取得已采集数据的帧缓冲，取得原始数据</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_DQBUF, &amp;buf);</span><br><span class=\"line\"><span class=\"comment\">//此时应用程序处理该帧缓冲区的数据，如：进行数据的处理和保存，</span></span><br><span class=\"line\">fp = fopen(picture.yuv,<span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//保存图片&quot;w&quot;，保存视频&quot;a&quot;追加写</span></span><br><span class=\"line\">fwrite(addr,<span class=\"number\">1</span>,length,fp);</span><br><span class=\"line\">fclose(fp);</span><br><span class=\"line\"><span class=\"comment\">//11.处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_QBUF, &amp;buf);</span><br><span class=\"line\"><span class=\"comment\">//12.停止视频的采集</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_STREAMOFF, &amp;type);</span><br><span class=\"line\"><span class=\"comment\">//13.释放申请的视频帧缓冲区</span></span><br><span class=\"line\">unmap;</span><br><span class=\"line\"><span class=\"comment\">//14.关闭视频设备文件</span></span><br><span class=\"line\">close(fd);</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"五、V4l2的常用IOCTL接口命令–-gt-gt-结构体介绍\"><a href=\"#五、V4l2的常用IOCTL接口命令–-gt-gt-结构体介绍\" class=\"headerlink\" title=\"五、V4l2的常用IOCTL接口命令–&gt;&gt;结构体介绍\"></a>五、V4l2的常用IOCTL接口命令–&gt;&gt;结构体介绍</h1><h2 id=\"1、常用的IOCTL接口命令\"><a href=\"#1、常用的IOCTL接口命令\" class=\"headerlink\" title=\"1、常用的IOCTL接口命令\"></a>1、常用的IOCTL接口命令</h2><p>在内核目录include&#x2F;linux&#x2F;videodev2.h中定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VIDIOC_QUERYCAP        <span class=\"comment\">//查询驱动功能 </span></span><br><span class=\"line\">VIDIOC_QUERYSTD     <span class=\"comment\">//检查当前视频设备支持的标准，例如PAL或NTSC。</span></span><br><span class=\"line\">VIDIOC_S_INPUT</span><br><span class=\"line\">VIDIOC_ENUMINPUT\t<span class=\"comment\">//枚举所有可用的输入</span></span><br><span class=\"line\">VIDIOC_S_PARM</span><br><span class=\"line\">VIDIOC_ENUM_FMT        <span class=\"comment\">//获取当前驱动支持的视频格式 </span></span><br><span class=\"line\">VIDIOC_S_FMT        <span class=\"comment\">//设置当前驱动的频捕获格式 </span></span><br><span class=\"line\">VIDIOC_G_FMT        <span class=\"comment\">//读取当前驱动的频捕获格式 </span></span><br><span class=\"line\">VIDIOC_TRY_FMT        <span class=\"comment\">//验证当前驱动的显示格式 </span></span><br><span class=\"line\">VIDIOC_CROPCAP        <span class=\"comment\">//查询驱动的修剪能力 </span></span><br><span class=\"line\">VIDIOC_S_CROP        <span class=\"comment\">//设置视频信号的矩形边框 </span></span><br><span class=\"line\">VIDIOC_G_CROP        <span class=\"comment\">//读取视频信号的矩形边框</span></span><br><span class=\"line\">VIDIOC_REQBUFS\t\t <span class=\"comment\">//分配内存 </span></span><br><span class=\"line\">VIDIOC_QUERYBUF <span class=\"comment\">//把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址</span></span><br><span class=\"line\">VIDIOC_QBUF        <span class=\"comment\">//把数据从缓存中读取出来 </span></span><br><span class=\"line\">VIDIOC_DQBUF        <span class=\"comment\">//把数据放回缓存队列 </span></span><br><span class=\"line\">VIDIOC_STREAMON        <span class=\"comment\">//开始视频显示函数 </span></span><br><span class=\"line\">VIDIOC_STREAMOFF        <span class=\"comment\">//结束视频显示函数 </span></span><br><span class=\"line\">VIDIOC_EXPBUF        <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、常用的结构体\"><a href=\"#2、常用的结构体\" class=\"headerlink\" title=\"2、常用的结构体\"></a>2、常用的结构体</h2><p>在内核目录include&#x2F;linux&#x2F;videodev2.h中定义。参见&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;videodev2.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_capability</span>        //视频设备的功能，对应命令<span class=\"title\">VIDIOC_QUERYCAP</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_std_id</span>        //视频制式</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_input</span>        //视频输入信息，对应命令<span class=\"title\">VIDIOC_ENUMINPUT</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_streamparm</span> //结构体<span class=\"title\">v4l2_streamparm</span>来描述视频流的属性</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_standard</span>        //视频的制式，比如<span class=\"title\">PAL</span>，<span class=\"title\">NTSC</span>，对应命令<span class=\"title\">VIDIOC_ENUMSTD</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_format</span>        //帧的格式，对应命令<span class=\"title\">VIDIOC_G_FMT</span>、<span class=\"title\">VIDIOC_S_FMT</span>等</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_crop</span>        //视频信号矩形边框</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_requestbuffers</span>        //申请帧缓冲，对应命令<span class=\"title\">VIDIOC_REQBUFS</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_buffer</span>        //驱动中的一帧图像缓存，对应命令<span class=\"title\">VIDIOC_QUERYBUF</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_exportbuffer</span> //导出<span class=\"title\">fd</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、v4l2-capability\"><a href=\"#1、v4l2-capability\" class=\"headerlink\" title=\"1、v4l2_capability\"></a>1、v4l2_capability</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_capability</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tu8 driver[<span class=\"number\">16</span>]; <span class=\"comment\">// 驱动名字</span></span><br><span class=\"line\">\tu8 card[<span class=\"number\">32</span>]; <span class=\"comment\">// 设备名字</span></span><br><span class=\"line\">\tu8 bus_info[<span class=\"number\">32</span>]; <span class=\"comment\">// 设备在系统中的位置</span></span><br><span class=\"line\">\tu32 version; <span class=\"comment\">// 驱动版本号</span></span><br><span class=\"line\">\tu32 capabilities; <span class=\"comment\">// 设备支持的操作</span></span><br><span class=\"line\">\tu32 reserved[<span class=\"number\">4</span>]; <span class=\"comment\">// 保留字段</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中域 capabilities 代表设备支持的操作模式，常见的值有 V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING 表示是一个视频捕捉设备并且具有数据流控制模式；另外 driver 域需要和 struct video_device 中的 name 匹配。</p>\n<h3 id=\"2、v4l2-input\"><a href=\"#2、v4l2-input\" class=\"headerlink\" title=\"2、v4l2_input\"></a>2、v4l2_input</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_input</span> &#123;</span></span><br><span class=\"line\">\t__u32\t     index;\t\t<span class=\"comment\">/*  Which input */</span></span><br><span class=\"line\">\t__u8\t     name[<span class=\"number\">32</span>];\t\t<span class=\"comment\">/*  Label */</span></span><br><span class=\"line\">\t__u32\t     type;\t\t<span class=\"comment\">/*  Type of input */</span></span><br><span class=\"line\">\t__u32\t     audioset;\t\t<span class=\"comment\">/*  Associated audios (bitfield) */</span></span><br><span class=\"line\">\t__u32        tuner;             <span class=\"comment\">/*  Associated tuner */</span></span><br><span class=\"line\">\tv4l2_std_id  <span class=\"built_in\">std</span>;</span><br><span class=\"line\">\t__u32\t     status;</span><br><span class=\"line\">\t__u32\t     reserved[<span class=\"number\">4</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>视频捕获的应用首先要通过VIDIOC_ENUMINPUT命令来枚举所有可用的输入。在V4L2层，这个调用会转换成调用一个驱动中对应的回调函数：<br> int (*vidioc_enum_input)(struct file *file, void *private_data,  struct v4l2_input *input);</p>\n<h3 id=\"3、v4l2-format\"><a href=\"#3、v4l2-format\" class=\"headerlink\" title=\"3、v4l2_format\"></a>3、v4l2_format</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_format</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span> <span class=\"title\">type</span>;</span> </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span> </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_pix_format</span>         <span class=\"title\">pix</span>;</span>     <span class=\"comment\">/* V4L2_BUF_TYPE_VIDEO_CAPTURE */</span> </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_window</span>             <span class=\"title\">win</span>;</span>     <span class=\"comment\">/* V4L2_BUF_TYPE_VIDEO_OVERLAY */</span> </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_vbi_format</span>         <span class=\"title\">vbi</span>;</span>     <span class=\"comment\">/* V4L2_BUF_TYPE_VBI_CAPTURE */</span> </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_sliced_vbi_format</span>  <span class=\"title\">sliced</span>;</span>  <span class=\"comment\">/* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */</span> </span><br><span class=\"line\">        __u8   raw_data[<span class=\"number\">200</span>];                   <span class=\"comment\">/* user-defined */</span> </span><br><span class=\"line\">    &#125; fmt; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span> &#123;</span> </span><br><span class=\"line\">    V4L2_BUF_TYPE_VIDEO_CAPTURE        = <span class=\"number\">1</span>, <span class=\"comment\">//视频捕获模式</span></span><br><span class=\"line\">    V4L2_BUF_TYPE_VIDEO_OUTPUT         = <span class=\"number\">2</span>, </span><br><span class=\"line\">    V4L2_BUF_TYPE_VIDEO_OVERLAY        = <span class=\"number\">3</span>, </span><br><span class=\"line\">    ... </span><br><span class=\"line\">    V4L2_BUF_TYPE_PRIVATE              = <span class=\"number\">0x80</span>, </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_pix_format</span> &#123;</span> </span><br><span class=\"line\">    __u32                   width; <span class=\"comment\">//视频的宽</span></span><br><span class=\"line\">    __u32                   height; <span class=\"comment\">//视频的高</span></span><br><span class=\"line\">    __u32                   pixelformat; <span class=\"comment\">//视频数据格式</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_field</span>         <span class=\"title\">field</span>;</span> </span><br><span class=\"line\">    __u32                   bytesperline;   <span class=\"comment\">/* for padding, zero if unused */</span> </span><br><span class=\"line\">    __u32                   sizeimage; </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_colorspace</span>    <span class=\"title\">colorspace</span>;</span> </span><br><span class=\"line\">    __u32                   priv;           <span class=\"comment\">/* private data, depends on pixelformat */</span> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>常见的捕获模式为 V4L2_BUF_TYPE_VIDEO_CAPTURE 即视频捕捉模式，在此模式下 fmt 联合体采用域 v4l2_pix_format：其中 width 为视频的宽、height 为视频的高、pixelformat 为视频数据格式（常见的值有 V4L2_PIX_FMT_YUV422P | V4L2_PIX_FMT_RGB565）、bytesperline 为一行图像占用的字节数、sizeimage 则为图像占用的总字节数、colorspace 指定设备的颜色空间。</p>\n<h3 id=\"4、v4l2-requestbuffers\"><a href=\"#4、v4l2-requestbuffers\" class=\"headerlink\" title=\"4、v4l2_requestbuffers\"></a>4、v4l2_requestbuffers</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_requestbuffers</span> &#123;</span></span><br><span class=\"line\">    __u32                   count;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span>      <span class=\"title\">type</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_memory</span>        <span class=\"title\">memory</span>;</span></span><br><span class=\"line\">    __u32                   reserved[<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_memory</span> &#123;</span></span><br><span class=\"line\">    V4L2_MEMORY_MMAP             = <span class=\"number\">1</span>,</span><br><span class=\"line\">    V4L2_MEMORY_USERPTR          = <span class=\"number\">2</span>,</span><br><span class=\"line\">    V4L2_MEMORY_OVERLAY          = <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>VIDIOC_REQBUFS 命令通过结构 v4l2_requestbuffers 请求驱动申请一片连续的内存用于缓存视频信息;count 指定根据图像占用空间大小申请的缓存区个数，type 为视频捕获模式，memory 为内存区的使用方式.</p>\n<h3 id=\"5、v4l2-buffer\"><a href=\"#5、v4l2-buffer\" class=\"headerlink\" title=\"5、v4l2_buffer\"></a>5、v4l2_buffer</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_buffer</span> &#123;</span></span><br><span class=\"line\">    __u32   index;\t<span class=\"comment\">//buffer 序号 </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span>    <span class=\"title\">type</span>;</span>\t<span class=\"comment\">//buffer 类型 </span></span><br><span class=\"line\">    __u32    bytesused;\t<span class=\"comment\">//缓存已使用空间大小，buffer 中已使用的字节数</span></span><br><span class=\"line\">    __u32    flags;\t<span class=\"comment\">//区分是MMAP 还是USERPTR</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_field</span>  <span class=\"title\">field</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span>    <span class=\"title\">timestamp</span>;</span>\t<span class=\"comment\">//获取第一个字节时的系统时间 </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_timecode</span>   <span class=\"title\">timecode</span>;</span></span><br><span class=\"line\">    __u32     sequence;\t<span class=\"comment\">//队列中的序号</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* memory location */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_memory</span>    <span class=\"title\">memory</span>;</span>\t<span class=\"comment\">//缓存使用方式</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">            __u32   offset;<span class=\"comment\">//当前缓存与内存区起始地址的偏移，缓冲帧地址，只对MMAP 有效  </span></span><br><span class=\"line\">            <span class=\"type\">unsigned</span> <span class=\"type\">long</span>   userptr;</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_plane</span> *<span class=\"title\">planes</span>;</span></span><br><span class=\"line\">    &#125; m;</span><br><span class=\"line\">    __u32    length;\t<span class=\"comment\">//缓冲帧长度</span></span><br><span class=\"line\">    __u32    input;</span><br><span class=\"line\">    __u32    reserved;\t<span class=\"comment\">//一般用于传递物理地址值</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_plane</span> &#123;</span></span><br><span class=\"line\">\t__u32\t\t\tbytesused;</span><br><span class=\"line\">\t__u32\t\t\tlength;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">\t\t__u32\t\tmem_offset;<span class=\"comment\">//offset是放在m.mem_offset中返回用户空间的</span></span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span>\tuserptr;</span><br><span class=\"line\">\t\t__s32\t\tfd;</span><br><span class=\"line\">\t&#125; m;</span><br><span class=\"line\">\t__u32\t\t\tdata_offset;</span><br><span class=\"line\">\t__u32\t\t\treserved[<span class=\"number\">11</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>flags 为缓存当前状态（常见值有 V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE，分别代表当前缓存已经映射、缓存可以采集数据、缓存可以提取数据）</p>\n<p>另外 VIDIOC_QUERYBUF，VIDIOC_QBUF 和 VIDIOC_DQBUF 命令都采用结构 v4l2_buffer 与驱动通信：VIDIOC_QBUF 命令向驱动传递应用程序已经处理完的缓存，即将缓存加入空闲可捕获视频的队列，传递的主要参数为 index；VIDIOC_DQBUF 命令向驱动获取已经存放有视频数据的缓存，v4l2_buffer 的各个域几乎都会被更新，但主要的参数也是 index，应用程序会根据 index 确定可用数据的起始地址和范围。</p>\n<h3 id=\"6、v4l2-captureparm\"><a href=\"#6、v4l2-captureparm\" class=\"headerlink\" title=\"6、v4l2_captureparm\"></a>6、v4l2_captureparm</h3><p>设置Stream参数。(主要是采集帧数)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_streamparm</span> <span class=\"title\">parms</span>;</span></span><br><span class=\"line\">parms.parm.capture.timeperframe.numerator=<span class=\"number\">1</span>;</span><br><span class=\"line\">parms.parm.capture.timeperframe.denominator=<span class=\"number\">60</span>;</span><br><span class=\"line\">rel = ioctl(fdUsbCam,VIDIOC_S_PARM, setfps);</span><br></pre></td></tr></table></figure>\n\n<p>对于捕获设备而言，parm.capture字段是要关注的内容，这个结构体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_captureparm</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">       __u32             capability;</span><br><span class=\"line\">       __u32             capturemode;</span><br><span class=\"line\">       structv4l2_fract  timeperframe;</span><br><span class=\"line\">       __u32             extendedmode;</span><br><span class=\"line\">       __u32          readbuffers;</span><br><span class=\"line\">       __u32             reserved[<span class=\"number\">4</span>];</span><br><span class=\"line\">   &#125;; </span><br><span class=\"line\">timeperframe字段用于指定想要使用的帧频率，它又是一个结构体：</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_fract</span>&#123;</span></span><br><span class=\"line\">       __u32  numerator;</span><br><span class=\"line\">       __u32  denominator;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>numerator和denominator所描述的系数给出的是成功的帧之间的时间间隔。numerator 分子， denominator 分母。主要表达每次帧之间时间间隔。 numerator&#x2F; denominator秒一帧。</p>\n<h3 id=\"7、v4l2-exportbuffer\"><a href=\"#7、v4l2-exportbuffer\" class=\"headerlink\" title=\"7、v4l2_exportbuffer\"></a>7、v4l2_exportbuffer</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_exportbuffer</span> &#123;</span></span><br><span class=\"line\">\t__u32\t\ttype; <span class=\"comment\">/* enum v4l2_buf_type */</span></span><br><span class=\"line\">\t__u32\t\tindex;</span><br><span class=\"line\">\t__u32\t\tplane;</span><br><span class=\"line\">\t__u32\t\tflags;</span><br><span class=\"line\">\t__s32\t\tfd;</span><br><span class=\"line\">\t__u32\t\treserved[<span class=\"number\">11</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"六、应用程序代码分析\"><a href=\"#六、应用程序代码分析\" class=\"headerlink\" title=\"六、应用程序代码分析\"></a>六、应用程序代码分析</h1><h2 id=\"1、保存图像picture-yuv\"><a href=\"#1、保存图像picture-yuv\" class=\"headerlink\" title=\"1、保存图像picture.yuv\"></a>1、保存图像picture.yuv</h2><p>见code中，camera_app_pic.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/videodev2.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/select.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VideoBuffer</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">void</span>   *start;<span class=\"comment\">//帧缓存mmap映射后的首地址</span></span><br><span class=\"line\">\t<span class=\"type\">size_t</span>  length;<span class=\"comment\">//缓存大小</span></span><br><span class=\"line\">&#125; VideoBuffer;</span><br><span class=\"line\">VideoBuffer *buffers;<span class=\"comment\">//用来存放映射后的帧缓存区地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">camera_device_open</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd;</span><br><span class=\"line\">\t<span class=\"comment\">//用阻塞模式打开摄像头设备</span></span><br><span class=\"line\">\tfd = open(<span class=\"string\">&quot;/dev/video0&quot;</span>,O_RDWR,<span class=\"number\">0</span>);<span class=\"comment\">//设备节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(fd &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;open /dev/video0 is fail.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">init_camera_attribute</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> numBufs;<span class=\"comment\">//</span></span><br><span class=\"line\">\tv4l2_std_id id;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_format</span> <span class=\"title\">fmt</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_requestbuffers</span>  <span class=\"title\">req</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_buffer</span>    <span class=\"title\">buf</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//检查当前视频设备支持的标准</span></span><br><span class=\"line\">\tioctl(fd,VIDIOC_QUERYSTD,&amp;id);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//设置视频捕获格式</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(&amp;fmt,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(fmt));</span><br><span class=\"line\">\tfmt.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;<span class=\"comment\">//视频捕获模式</span></span><br><span class=\"line\">\tfmt.fmt.pix.width = <span class=\"number\">640</span>;<span class=\"comment\">//视频的宽</span></span><br><span class=\"line\">\tfmt.fmt.pix.height = <span class=\"number\">480</span>;<span class=\"comment\">//视频的高</span></span><br><span class=\"line\">\tfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;<span class=\"comment\">//视频数据格式YUYV</span></span><br><span class=\"line\"><span class=\"comment\">//\tfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YVU420;</span></span><br><span class=\"line\">\tfmt.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_S_FMT,&amp;fmt) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;set VIDIOC_S_FMT is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//分配内存，申请帧缓存，</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(&amp;req,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(req));</span><br><span class=\"line\">\treq.count = <span class=\"number\">4</span>;<span class=\"comment\">//帧缓存的个数，一般不大于5</span></span><br><span class=\"line\">\treq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\treq.memory = V4L2_MEMORY_MMAP;<span class=\"comment\">//内存区的使用方式，mmap映射</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_REQBUFS,&amp;req) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;set VIDIOC_REQBUFS is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//获取并记录缓存的物理空间</span></span><br><span class=\"line\">\tbuffers = <span class=\"built_in\">calloc</span>(req.count,<span class=\"keyword\">sizeof</span>(*buffers));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(numBufs = <span class=\"number\">0</span>; numBufs &lt; req.count; numBufs ++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(&amp;buf,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\tbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\t\tbuf.memory = V4L2_MEMORY_MMAP;</span><br><span class=\"line\">\t\tbuf.index = numBufs;<span class=\"comment\">//缓存编号，4帧缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//读取缓存，查询帧缓冲区在内核空间中的长度和偏移量</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_QUERYBUF,&amp;buf) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">&quot;set VIDIOC_REQBUFS is fail&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t <span class=\"comment\">// 转换成相对地址，将申请到的帧缓冲映射到用户空间mmap</span></span><br><span class=\"line\">\t\tbuffers[numBufs].length = buf.length;</span><br><span class=\"line\">\t\tbuffers[numBufs].start  = mmap(<span class=\"literal\">NULL</span>,buf.length,PROT_READ|PROT_WRITE,</span><br><span class=\"line\">\t\t\t\tMAP_SHARED,fd,buf.m.offset);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(buffers[numBufs].start == MAP_FAILED)&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">&quot;mmap is fail&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 放入缓存队列</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_QBUF,&amp;buf) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">&quot;set VIDIOC_QBUF is fail&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">start_capturing</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span> <span class=\"title\">type</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//开始采集数据</span></span><br><span class=\"line\">\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_STREAMON,&amp;type) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;start capturing is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//保存图片</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">build_picture</span><span class=\"params\">(<span class=\"type\">void</span> *addr,<span class=\"type\">int</span> length)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tFILE *fp;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> picture_name[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">sprintf</span>(picture_name,<span class=\"string\">&quot;picture%d.yuv&quot;</span>,num++);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tfp = fopen(picture_name,<span class=\"string\">&quot;w&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(fp == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;fail to open &quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfwrite(addr,<span class=\"number\">1</span>,length,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">read_image</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_buffer</span> <span class=\"title\">buf</span>;</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(&amp;buf,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\tbuf.type=V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\tbuf.memory=V4L2_MEMORY_MMAP;</span><br><span class=\"line\">\tbuf.index=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//读取缓存，出列以取得已采集数据的帧缓冲，取得原始数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_DQBUF,&amp;buf) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;set VIDIOC_DQBUF is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将数据存为图片</span></span><br><span class=\"line\">\tbuild_picture(buffers[buf.index].start,buffers[buf.index].length);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//重新放入缓存队列，处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_QBUF,&amp;buf) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;reset VIDIOC_QBUF is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">when_to_read</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)<span class=\"comment\">//保存三张图片</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfd_set rfds;<span class=\"comment\">//指定内核监测的文件描述符集合</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span><span class=\"comment\">//设置超时时间</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> retval;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFD_ZERO(&amp;rfds);<span class=\"comment\">//清空集合</span></span><br><span class=\"line\">\t\tFD_SET(fd, &amp;rfds);<span class=\"comment\">//将fd添加到集合中</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttv.tv_sec = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\ttv.tv_usec = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当有数据采集好在缓冲区准备好时，开始读取缓存数据</span></span><br><span class=\"line\">\t\tretval = select(fd+<span class=\"number\">1</span>, &amp;rfds, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;tv);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(retval == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t perror(<span class=\"string\">&quot;select()&quot;</span>);</span><br><span class=\"line\">\t\t\t <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(retval == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;select is timeout\\n&quot;</span>);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tread_image(fd);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">stop_capturing</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span> <span class=\"title\">type</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//停止采集数据</span></span><br><span class=\"line\">\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_STREAMOFF,&amp;type) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;stop capturing is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">uninit_camera</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"comment\">//释放申请的视频帧缓冲区</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == munmap(buffers[i].start,buffers[i].length))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">&quot;munmap is fail&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(buffers);</span><br><span class=\"line\">\t<span class=\"comment\">//关闭视频设备文件</span></span><br><span class=\"line\">\tclose(fd);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd;</span><br><span class=\"line\">\tfd = camera_device_open();\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tinit_camera_attribute(fd);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tstart_capturing(fd);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhen_to_read(fd);</span><br><span class=\"line\"></span><br><span class=\"line\">\tstop_capturing(fd);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tuninit_camera(fd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2、保存视频video-yuv\"><a href=\"#2、保存视频video-yuv\" class=\"headerlink\" title=\"2、保存视频video.yuv\"></a>2、保存视频video.yuv</h2><p>见code中，camera_app_mp4.c</p>\n<p>主要区别：fp &#x3D; fopen(video_name,”a”)，追加写的方式打开，进行采集</p>\n<h1 id=\"七、V4l2驱动框架\"><a href=\"#七、V4l2驱动框架\" class=\"headerlink\" title=\"七、V4l2驱动框架\"></a>七、V4l2驱动框架</h1><h2 id=\"1、主要对象\"><a href=\"#1、主要对象\" class=\"headerlink\" title=\"1、主要对象\"></a>1、主要对象</h2><h3 id=\"1、video-device\"><a href=\"#1、video-device\" class=\"headerlink\" title=\"1、video_device\"></a>1、video_device</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">video_device</span></span></span><br><span class=\"line\"><span class=\"class\">\t\t&#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_file_operations</span> *<span class=\"title\">fops</span>;</span> </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//操作方法结构体</span></span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> *<span class=\"title\">cdev</span>;</span>\t（file_opreations）\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//字符设备驱动</span></span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_device</span> *<span class=\"title\">v4l2_dev</span>;</span>\t<span class=\"comment\">/* v4l2_device parent */</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">char</span> name[<span class=\"number\">32</span>]; </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//驱动的名字</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> minor;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//次设备号</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">void</span> (*release)(<span class=\"keyword\">struct</span> video_device *vdev);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//释放资源的函数</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_ioctl_ops</span> *<span class=\"title\">ioctl_ops</span>;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//ioctl的操作方法</span></span><br><span class=\"line\">\t\t&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>  一个字符设备，为用户空间提供设备节点(&#x2F;dev&#x2F;videox)，提供系统调用的相关操作(open、ioctl…) </p>\n<p>可以看到video_device中含有一个cdev还有v4l2_device，此外还有fops和ioctl_ops，从应用层进行系统调用会经过v4l2的核心层回调到这里 </p>\n<h4 id=\"v4l2-file-operations\"><a href=\"#v4l2-file-operations\" class=\"headerlink\" title=\"v4l2_file_operations\"></a>v4l2_file_operations</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_file_operations</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*read) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">char</span> __user *, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*write) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">const</span> <span class=\"type\">char</span> __user *, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *);</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"title function_\">int</span> <span class=\"params\">(*poll)</span> <span class=\"params\">(<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> poll_table_struct *)</span>;</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*ioctl) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>);</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*unlocked_ioctl) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>);</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"title function_\">long</span> <span class=\"params\">(*get_unmapped_area)</span> <span class=\"params\">(<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>)</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*mmap) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> vm_area_struct *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*open) (<span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*release) (<span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v4l2-ioctl-ops\"><a href=\"#v4l2-ioctl-ops\" class=\"headerlink\" title=\"v4l2_ioctl_ops\"></a>v4l2_ioctl_ops</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_ioctl_ops</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_querycap)(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_capability *cap);</span><br><span class=\"line\">\t<span class=\"comment\">/* Buffer handlers */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_reqbufs) (<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_requestbuffers *b);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_querybuf)(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_buffer *b);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_qbuf)    (<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_buffer *b);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_dqbuf)   (<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_buffer *b);</span><br><span class=\"line\">    <span class=\"comment\">/* Stream on/off */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_streamon) (<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">enum</span> v4l2_buf_type i);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_streamoff)(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">enum</span> v4l2_buf_type i);</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> v4l2有很多ioctl操作，具体实现都在这里 </p>\n<h3 id=\"2、v4l2-device\"><a href=\"#2、v4l2-device\" class=\"headerlink\" title=\"2、v4l2_device\"></a>2、v4l2_device</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_device</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">/* used to keep track of the registered subdevs */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">subdevs</span>;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>  嵌入到video_device中，表示一个v4l2设备的实例 </p>\n<p>可以看到v4l2_device中有一个v4l2_subdev的链表，v4l2_device的主要目的时用来管理v4l2_subdev </p>\n<h3 id=\"3、v4l2-subdev\"><a href=\"#3、v4l2-subdev\" class=\"headerlink\" title=\"3、v4l2_subdev\"></a>3、v4l2_subdev</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_subdev</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_device</span> *<span class=\"title\">v4l2_dev</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_subdev_ops</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> 依附在v4l2_device之下，并表示一个v4l2设备的子设备，一个v4l2_devide下可以有多个sub_device </p>\n<p> v4l2_subdev中有一个v4l2_subdev_ops，实现了一系列的操作，供v4l2_device调用 </p>\n<p> <strong>subdev的设计目的是为了多路复用，就是用一个v4l2_device可以服务多个v4l2_subdev</strong> </p>\n<h3 id=\"4、V4l2提供的注册接口\"><a href=\"#4、V4l2提供的注册接口\" class=\"headerlink\" title=\"4、V4l2提供的注册接口\"></a>4、V4l2提供的注册接口</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">video_register_device</span><span class=\"params\">(<span class=\"keyword\">struct</span> video_device *vdev, <span class=\"type\">int</span> type, <span class=\"type\">int</span> nr)</span>;<span class=\"comment\">//video_device注册</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">video_unregister_device</span><span class=\"params\">(<span class=\"keyword\">struct</span> video_device *vdev)</span>;<span class=\"comment\">//video_device注销</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">v4l2_device_register</span><span class=\"params\">(<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">struct</span> v4l2_device *v4l2_dev)</span>;<span class=\"comment\">//v4l2_device注册</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">v4l2_device_unregister</span><span class=\"params\">(<span class=\"keyword\">struct</span> v4l2_device *v4l2_dev)</span>;<span class=\"comment\">//v4l2_device注销</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">v4l2_device_register_subdev</span><span class=\"params\">(<span class=\"keyword\">struct</span> v4l2_device *v4l2_dev,<span class=\"keyword\">struct</span> v4l2_subdev *sd)</span>;<span class=\"comment\">//v4l2_subdev注册</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">v4l2_device_unregister_subdev</span><span class=\"params\">(<span class=\"keyword\">struct</span> v4l2_subdev *sd)</span>;<span class=\"comment\">//v4l2_subdev注销</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2、图示\"><a href=\"#2、图示\" class=\"headerlink\" title=\"2、图示\"></a>2、图示</h2><img src=\"1.png\"  />\n\n<img src=\"2.png\"  />\n\n<img src=\"3.png\" style=\"zoom:80%;\" />\n\n<h2 id=\"3、主要框架\"><a href=\"#3、主要框架\" class=\"headerlink\" title=\"3、主要框架\"></a>3、主要框架</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;...&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">video_device</span>* <span class=\"title\">video_dev</span>;</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_device</span> <span class=\"title\">v4l2_dev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现各种系统调用 */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_file_operations</span> <span class=\"title\">video_dev_fops</span> =</span> &#123;</span><br><span class=\"line\">\t.owner\t\t    = THIS_MODULE,</span><br><span class=\"line\">\t.release        = vdev_close,</span><br><span class=\"line\">\t.read           = vdev_read,</span><br><span class=\"line\">\t.poll\t\t    = vdev_poll,</span><br><span class=\"line\">\t.ioctl          = video_ioctl2,</span><br><span class=\"line\">\t.mmap           = vdev_mmap,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现各种系统调用 */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_ioctl_ops</span> <span class=\"title\">video_dev_ioctl_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.vidioc_querycap      = vidioc_querycap,</span><br><span class=\"line\">\t.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,</span><br><span class=\"line\">\t.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,</span><br><span class=\"line\">\t.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,</span><br><span class=\"line\">\t.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,</span><br><span class=\"line\">\t.vidioc_reqbufs       = vidioc_reqbufs,</span><br><span class=\"line\">\t.vidioc_querybuf      = vidioc_querybuf,</span><br><span class=\"line\">\t.vidioc_qbuf          = vidioc_qbuf,</span><br><span class=\"line\">\t.vidioc_dqbuf         = vidioc_dqbuf,</span><br><span class=\"line\">\t.vidioc_enum_input    = vidioc_enum_input,</span><br><span class=\"line\">\t.vidioc_g_input       = vidioc_g_input,</span><br><span class=\"line\">\t.vidioc_s_input       = vidioc_s_input,</span><br><span class=\"line\">\t.vidioc_streamon      = vidioc_streamon,</span><br><span class=\"line\">\t.vidioc_streamoff     = vidioc_streamoff,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __init <span class=\"title function_\">video_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 分配并设置一个video_device */</span></span><br><span class=\"line\">    video_dev = video_device_alloc();</span><br><span class=\"line\">    video_dev-&gt;fops = &amp;video_dev_fops;</span><br><span class=\"line\">    video_dev-&gt;ioctl_ops = &amp;video_dev_ioctl_ops;</span><br><span class=\"line\">    video_dev-&gt;release = video_device_release;</span><br><span class=\"line\">    video_dev-&gt;tvnorms = V4L2_STD_525_60;</span><br><span class=\"line\">    video_dev-&gt;current_norm = V4L2_STD_NTSC_M;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 注册一个v4l2_device */</span></span><br><span class=\"line\">    v4l2_device_register(video_dev-&gt;dev, &amp;v4l2_dev);    </span><br><span class=\"line\">    video_dev-&gt;v4l2_dev = &amp;video_dev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 注册一个video_device字符设备 */</span></span><br><span class=\"line\">    video_register_device(video_dev, VFL_TYPE_GRABBER, <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __exit <span class=\"title function_\">video_exit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//注销</span></span><br><span class=\"line\">    video_unregister_device(video_dev);</span><br><span class=\"line\">    v4l2_device_unregister(&amp;v4l2_dev);</span><br><span class=\"line\">    video_device_release(video_dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(video_init);</span><br><span class=\"line\">module_exit(video_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"八、多路video输入分析\"><a href=\"#八、多路video输入分析\" class=\"headerlink\" title=\"八、多路video输入分析\"></a>八、多路video输入分析</h1><h2 id=\"1、多路操作流程\"><a href=\"#1、多路操作流程\" class=\"headerlink\" title=\"1、多路操作流程\"></a>1、多路操作流程</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.设备初始化</span></span><br><span class=\"line\">_Init()&#123;</span><br><span class=\"line\">    _open()｛</span><br><span class=\"line\">        fd[i] = open(dev_name[i], O_RDWR <span class=\"comment\">/* required */</span>  | O_NONBLOCK, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ioctl(fd[i], VIDIOC_S_INPUT, &amp;inp);<span class=\"comment\">//设置输入</span></span><br><span class=\"line\">    ioctl(fd[i], VIDIOC_S_PARM, &amp;parms);<span class=\"comment\">//主要用来设置采集帧数</span></span><br><span class=\"line\">        ｝;<span class=\"comment\">//打开设备节点</span></span><br><span class=\"line\">    _Fmtset()｛</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_S_FMT, &amp;fmt);<span class=\"comment\">//设置</span></span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_G_FMT, &amp;fmt);<span class=\"comment\">//查询，判断设置是否成功</span></span><br><span class=\"line\">        ｝;<span class=\"comment\">//设置视频捕获模式</span></span><br><span class=\"line\">    _BuffReq()｛</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_REQBUFS, &amp;req);</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_QUERYBUF, &amp;buf);</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_QBUF, &amp;buf);</span><br><span class=\"line\">        ｝;<span class=\"comment\">//申请帧缓存，查询缓存转换地址，放入队列</span></span><br><span class=\"line\">    _ON&#123;</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_STREAMON, &amp;type);</span><br><span class=\"line\">    &#125;;<span class=\"comment\">//开启视频捕获</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.创建多线程</span></span><br><span class=\"line\">pthread_create(&amp;capture_pth, <span class=\"literal\">NULL</span>,Video_Capture, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">//3.采集数据</span></span><br><span class=\"line\">Video_Capture()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用select监视文件描述符，等待采集，如果有准备好的</span></span><br><span class=\"line\">    select(fd[<span class=\"number\">3</span>] + <span class=\"number\">1</span>, &amp;fdr, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;tv);<span class=\"comment\">//IO多路复用</span></span><br><span class=\"line\">    <span class=\"comment\">//当准备好时，采用互斥锁的方式，唤醒休眠的数据处理函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( FD_ISSET(fd[<span class=\"number\">0</span>],&amp;fdr) &amp;&amp; FD_ISSET(fd[<span class=\"number\">1</span>],&amp;fdr) &amp;&amp; \\</span><br><span class=\"line\">\t\tFD_ISSET(fd[<span class=\"number\">2</span>],&amp;fdr) &amp;&amp; FD_ISSET(fd[<span class=\"number\">3</span>],&amp;fdr))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">            _Queryaddr()&#123;</span><br><span class=\"line\">                ioctl(fd[i], VIDIOC_DQBUF, &amp;buf);<span class=\"comment\">//出列</span></span><br><span class=\"line\">                VideoPhyAddr[i] = buf.m.planes[<span class=\"number\">0</span>].m.mem_offset;</span><br><span class=\"line\">                ioctl(fd[i], VIDIOC_QBUF, &amp;buf);<span class=\"comment\">//入列</span></span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            pthread_mutex_lock(&amp;VideoMutex);<span class=\"comment\">//上锁</span></span><br><span class=\"line\">            pthread_cond_signal(&amp;VideoCond);<span class=\"comment\">//唤醒休眠</span></span><br><span class=\"line\">            pthread_mutex_unlock(&amp;VideoMutex);<span class=\"comment\">//解锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//4.数据处理</span></span><br><span class=\"line\">_LoadVideoData()&#123;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;VideoMutex);<span class=\"comment\">//上锁</span></span><br><span class=\"line\">\tpthread_cond_wait(&amp;VideoCond, &amp;VideoMutex);<span class=\"comment\">//休眠</span></span><br><span class=\"line\">\tpthread_mutex_unlock(&amp;VideoMutex);<span class=\"comment\">//解锁</span></span><br><span class=\"line\">    <span class=\"comment\">//************************</span></span><br><span class=\"line\">    <span class=\"comment\">//***原始视频流数据处理***</span></span><br><span class=\"line\">    <span class=\"comment\">//************************</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"style":""}},"length":18186,"excerpt":"<div align = \"center\">Video for Linux two(简称v4l2)</div>\n\n\n<h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p> vl42是video for Linux 2的缩写，是一套Linux内核视频设备的驱动框架，该驱动框架为应用层提供一套统一的操作接口(一系列的ioctl)。包括一套数据结构和底层V4L2驱动接口。只能在Linux下使用。</p>","more":"<p>V4L2在设计时，是要支持很多广泛的设备的，它们之中只有一部分在本质上是真正的视频设备，可以支持多种设备,它可以有以下几种接口</p>\n<p>video capture interface：视频采集接口，这种接口应用于摄像头，v4l2在最初设计的时候就是应用于这种功能</p>\n<p>video output interface：视频输出接口，将静止图像或图像序列编码为模拟视频信号，通过此接口，应用程序可以控制编码过程并将图像从用户空间移动到驱动程序</p>\n<p>video overlay interface：视频直接传输接口，可以将采集到的视频数据直接传输到显示设备，不需要cpu参与，这种方式的显示图像的效率比其他方式高得多</p>\n<p>其他接口这里就不介绍了，下面来看一下v4l2的API</p>\n<h1 id=\"二、作用\"><a href=\"#二、作用\" class=\"headerlink\" title=\"二、作用\"></a>二、作用</h1><p>它使程序有发现设备和操作设备的能力。它主要是用一系列的回调函数来实现这些功能。像设置摄像头的频率、帧频、视频压缩格式和图像参数等等。并使得它们的输出标准化。当然也可以用于其他多媒体的开发，如音频等。</p>\n<h1 id=\"三、存放位置\"><a href=\"#三、存放位置\" class=\"headerlink\" title=\"三、存放位置\"></a>三、存放位置</h1><p>在Linux下，所有外设都被看成一种特殊的文件，成为“设备文件”，可以象访问普通文件一样对其进行读写。一般来说，采用V4L2驱动的摄像头设备文是&#x2F;dev&#x2F;v4l&#x2F;video0。为了通用，可以建立一个到&#x2F;dev&#x2F;video0的链接。V4L2支持两种方式来采集图像：内存映射方式(mmap)和直接读取方式(read)。V4L2在include&#x2F;linux&#x2F;videodev.h文件中定义了一些重要的数据结构，在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据。Linux系统V4L2的能力可在Linux内核编译阶段配置，默认情况下都有此开发接口。V4L2从Linux 2.5.x版本的内核中开始出现。结构体详细参数可以在&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;videodev2.h中查看。</p>\n<h1 id=\"四、V4l2框架操作流程\"><a href=\"#四、V4l2框架操作流程\" class=\"headerlink\" title=\"四、V4l2框架操作流程\"></a>四、V4l2框架操作流程</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.打开视频设备文件</span></span><br><span class=\"line\"><span class=\"type\">int</span> fd = open(<span class=\"string\">&quot;/dev/video0&quot;</span>,O_RDWR);</span><br><span class=\"line\"><span class=\"comment\">//2.查询视频设备属性，如：是否具有视频输入或者音频输入输出等</span></span><br><span class=\"line\">ioctl(fd,VIDIOC_QUERYCAP,&amp;cap);</span><br><span class=\"line\"><span class=\"comment\">//3.选择视频输入，一个视频设备可以有多个视频输入</span></span><br><span class=\"line\"><span class=\"comment\">//4.设置视频采集的参数:视频的制式，图像的采集窗口，帧格式，帧率，旋转方式</span></span><br><span class=\"line\">ioctl(fd,VIDIOC_S_FMT,&amp;fmt);</span><br><span class=\"line\"><span class=\"comment\">//5.向驱动申请视频流数据的帧缓冲区，一般为4个。</span></span><br><span class=\"line\">ioctl(fd, VIDIOC_REQBUFS, &amp;req);</span><br><span class=\"line\"><span class=\"comment\">//6.查询帧缓冲区在内核空间中的长度和偏移量 </span></span><br><span class=\"line\">ioctl(fd, VIDIOC_QUERYBUF, &amp;buf);</span><br><span class=\"line\"><span class=\"comment\">//7.将申请到的帧缓冲映射到用户空间mmap，这样可以直接操作采集到的帧，不用复制</span></span><br><span class=\"line\">buffers[i].length = buf.length;</span><br><span class=\"line\">buffers[i].start = mmap(<span class=\"literal\">NULL</span>, buffers[i].length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffers[i].offset);;</span><br><span class=\"line\"><span class=\"comment\">//8.将申请到的帧缓冲全部放入视频采集输出队列，以便存放采集的数据</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_QBUF, &amp;buf);</span><br><span class=\"line\"><span class=\"comment\">//9.开始视频采集</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_STREAMON, &amp;type);</span><br><span class=\"line\"><span class=\"comment\">//10.出列以取得已采集数据的帧缓冲，取得原始数据</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_DQBUF, &amp;buf);</span><br><span class=\"line\"><span class=\"comment\">//此时应用程序处理该帧缓冲区的数据，如：进行数据的处理和保存，</span></span><br><span class=\"line\">fp = fopen(picture.yuv,<span class=\"string\">&quot;w&quot;</span>);<span class=\"comment\">//保存图片&quot;w&quot;，保存视频&quot;a&quot;追加写</span></span><br><span class=\"line\">fwrite(addr,<span class=\"number\">1</span>,length,fp);</span><br><span class=\"line\">fclose(fp);</span><br><span class=\"line\"><span class=\"comment\">//11.处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_QBUF, &amp;buf);</span><br><span class=\"line\"><span class=\"comment\">//12.停止视频的采集</span></span><br><span class=\"line\">ioctl (fd, VIDIOC_STREAMOFF, &amp;type);</span><br><span class=\"line\"><span class=\"comment\">//13.释放申请的视频帧缓冲区</span></span><br><span class=\"line\">unmap;</span><br><span class=\"line\"><span class=\"comment\">//14.关闭视频设备文件</span></span><br><span class=\"line\">close(fd);</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"五、V4l2的常用IOCTL接口命令–-gt-gt-结构体介绍\"><a href=\"#五、V4l2的常用IOCTL接口命令–-gt-gt-结构体介绍\" class=\"headerlink\" title=\"五、V4l2的常用IOCTL接口命令–&gt;&gt;结构体介绍\"></a>五、V4l2的常用IOCTL接口命令–&gt;&gt;结构体介绍</h1><h2 id=\"1、常用的IOCTL接口命令\"><a href=\"#1、常用的IOCTL接口命令\" class=\"headerlink\" title=\"1、常用的IOCTL接口命令\"></a>1、常用的IOCTL接口命令</h2><p>在内核目录include&#x2F;linux&#x2F;videodev2.h中定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VIDIOC_QUERYCAP        <span class=\"comment\">//查询驱动功能 </span></span><br><span class=\"line\">VIDIOC_QUERYSTD     <span class=\"comment\">//检查当前视频设备支持的标准，例如PAL或NTSC。</span></span><br><span class=\"line\">VIDIOC_S_INPUT</span><br><span class=\"line\">VIDIOC_ENUMINPUT\t<span class=\"comment\">//枚举所有可用的输入</span></span><br><span class=\"line\">VIDIOC_S_PARM</span><br><span class=\"line\">VIDIOC_ENUM_FMT        <span class=\"comment\">//获取当前驱动支持的视频格式 </span></span><br><span class=\"line\">VIDIOC_S_FMT        <span class=\"comment\">//设置当前驱动的频捕获格式 </span></span><br><span class=\"line\">VIDIOC_G_FMT        <span class=\"comment\">//读取当前驱动的频捕获格式 </span></span><br><span class=\"line\">VIDIOC_TRY_FMT        <span class=\"comment\">//验证当前驱动的显示格式 </span></span><br><span class=\"line\">VIDIOC_CROPCAP        <span class=\"comment\">//查询驱动的修剪能力 </span></span><br><span class=\"line\">VIDIOC_S_CROP        <span class=\"comment\">//设置视频信号的矩形边框 </span></span><br><span class=\"line\">VIDIOC_G_CROP        <span class=\"comment\">//读取视频信号的矩形边框</span></span><br><span class=\"line\">VIDIOC_REQBUFS\t\t <span class=\"comment\">//分配内存 </span></span><br><span class=\"line\">VIDIOC_QUERYBUF <span class=\"comment\">//把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址</span></span><br><span class=\"line\">VIDIOC_QBUF        <span class=\"comment\">//把数据从缓存中读取出来 </span></span><br><span class=\"line\">VIDIOC_DQBUF        <span class=\"comment\">//把数据放回缓存队列 </span></span><br><span class=\"line\">VIDIOC_STREAMON        <span class=\"comment\">//开始视频显示函数 </span></span><br><span class=\"line\">VIDIOC_STREAMOFF        <span class=\"comment\">//结束视频显示函数 </span></span><br><span class=\"line\">VIDIOC_EXPBUF        <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、常用的结构体\"><a href=\"#2、常用的结构体\" class=\"headerlink\" title=\"2、常用的结构体\"></a>2、常用的结构体</h2><p>在内核目录include&#x2F;linux&#x2F;videodev2.h中定义。参见&#x2F;include&#x2F;uapi&#x2F;linux&#x2F;videodev2.h</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_capability</span>        //视频设备的功能，对应命令<span class=\"title\">VIDIOC_QUERYCAP</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_std_id</span>        //视频制式</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_input</span>        //视频输入信息，对应命令<span class=\"title\">VIDIOC_ENUMINPUT</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_streamparm</span> //结构体<span class=\"title\">v4l2_streamparm</span>来描述视频流的属性</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_standard</span>        //视频的制式，比如<span class=\"title\">PAL</span>，<span class=\"title\">NTSC</span>，对应命令<span class=\"title\">VIDIOC_ENUMSTD</span> </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_format</span>        //帧的格式，对应命令<span class=\"title\">VIDIOC_G_FMT</span>、<span class=\"title\">VIDIOC_S_FMT</span>等</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_crop</span>        //视频信号矩形边框</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_requestbuffers</span>        //申请帧缓冲，对应命令<span class=\"title\">VIDIOC_REQBUFS</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_buffer</span>        //驱动中的一帧图像缓存，对应命令<span class=\"title\">VIDIOC_QUERYBUF</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_exportbuffer</span> //导出<span class=\"title\">fd</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、v4l2-capability\"><a href=\"#1、v4l2-capability\" class=\"headerlink\" title=\"1、v4l2_capability\"></a>1、v4l2_capability</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_capability</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tu8 driver[<span class=\"number\">16</span>]; <span class=\"comment\">// 驱动名字</span></span><br><span class=\"line\">\tu8 card[<span class=\"number\">32</span>]; <span class=\"comment\">// 设备名字</span></span><br><span class=\"line\">\tu8 bus_info[<span class=\"number\">32</span>]; <span class=\"comment\">// 设备在系统中的位置</span></span><br><span class=\"line\">\tu32 version; <span class=\"comment\">// 驱动版本号</span></span><br><span class=\"line\">\tu32 capabilities; <span class=\"comment\">// 设备支持的操作</span></span><br><span class=\"line\">\tu32 reserved[<span class=\"number\">4</span>]; <span class=\"comment\">// 保留字段</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中域 capabilities 代表设备支持的操作模式，常见的值有 V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING 表示是一个视频捕捉设备并且具有数据流控制模式；另外 driver 域需要和 struct video_device 中的 name 匹配。</p>\n<h3 id=\"2、v4l2-input\"><a href=\"#2、v4l2-input\" class=\"headerlink\" title=\"2、v4l2_input\"></a>2、v4l2_input</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_input</span> &#123;</span></span><br><span class=\"line\">\t__u32\t     index;\t\t<span class=\"comment\">/*  Which input */</span></span><br><span class=\"line\">\t__u8\t     name[<span class=\"number\">32</span>];\t\t<span class=\"comment\">/*  Label */</span></span><br><span class=\"line\">\t__u32\t     type;\t\t<span class=\"comment\">/*  Type of input */</span></span><br><span class=\"line\">\t__u32\t     audioset;\t\t<span class=\"comment\">/*  Associated audios (bitfield) */</span></span><br><span class=\"line\">\t__u32        tuner;             <span class=\"comment\">/*  Associated tuner */</span></span><br><span class=\"line\">\tv4l2_std_id  <span class=\"built_in\">std</span>;</span><br><span class=\"line\">\t__u32\t     status;</span><br><span class=\"line\">\t__u32\t     reserved[<span class=\"number\">4</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>视频捕获的应用首先要通过VIDIOC_ENUMINPUT命令来枚举所有可用的输入。在V4L2层，这个调用会转换成调用一个驱动中对应的回调函数：<br> int (*vidioc_enum_input)(struct file *file, void *private_data,  struct v4l2_input *input);</p>\n<h3 id=\"3、v4l2-format\"><a href=\"#3、v4l2-format\" class=\"headerlink\" title=\"3、v4l2_format\"></a>3、v4l2_format</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_format</span> &#123;</span> </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span> <span class=\"title\">type</span>;</span> </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span> </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_pix_format</span>         <span class=\"title\">pix</span>;</span>     <span class=\"comment\">/* V4L2_BUF_TYPE_VIDEO_CAPTURE */</span> </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_window</span>             <span class=\"title\">win</span>;</span>     <span class=\"comment\">/* V4L2_BUF_TYPE_VIDEO_OVERLAY */</span> </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_vbi_format</span>         <span class=\"title\">vbi</span>;</span>     <span class=\"comment\">/* V4L2_BUF_TYPE_VBI_CAPTURE */</span> </span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_sliced_vbi_format</span>  <span class=\"title\">sliced</span>;</span>  <span class=\"comment\">/* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */</span> </span><br><span class=\"line\">        __u8   raw_data[<span class=\"number\">200</span>];                   <span class=\"comment\">/* user-defined */</span> </span><br><span class=\"line\">    &#125; fmt; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span> &#123;</span> </span><br><span class=\"line\">    V4L2_BUF_TYPE_VIDEO_CAPTURE        = <span class=\"number\">1</span>, <span class=\"comment\">//视频捕获模式</span></span><br><span class=\"line\">    V4L2_BUF_TYPE_VIDEO_OUTPUT         = <span class=\"number\">2</span>, </span><br><span class=\"line\">    V4L2_BUF_TYPE_VIDEO_OVERLAY        = <span class=\"number\">3</span>, </span><br><span class=\"line\">    ... </span><br><span class=\"line\">    V4L2_BUF_TYPE_PRIVATE              = <span class=\"number\">0x80</span>, </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_pix_format</span> &#123;</span> </span><br><span class=\"line\">    __u32                   width; <span class=\"comment\">//视频的宽</span></span><br><span class=\"line\">    __u32                   height; <span class=\"comment\">//视频的高</span></span><br><span class=\"line\">    __u32                   pixelformat; <span class=\"comment\">//视频数据格式</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_field</span>         <span class=\"title\">field</span>;</span> </span><br><span class=\"line\">    __u32                   bytesperline;   <span class=\"comment\">/* for padding, zero if unused */</span> </span><br><span class=\"line\">    __u32                   sizeimage; </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_colorspace</span>    <span class=\"title\">colorspace</span>;</span> </span><br><span class=\"line\">    __u32                   priv;           <span class=\"comment\">/* private data, depends on pixelformat */</span> </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>常见的捕获模式为 V4L2_BUF_TYPE_VIDEO_CAPTURE 即视频捕捉模式，在此模式下 fmt 联合体采用域 v4l2_pix_format：其中 width 为视频的宽、height 为视频的高、pixelformat 为视频数据格式（常见的值有 V4L2_PIX_FMT_YUV422P | V4L2_PIX_FMT_RGB565）、bytesperline 为一行图像占用的字节数、sizeimage 则为图像占用的总字节数、colorspace 指定设备的颜色空间。</p>\n<h3 id=\"4、v4l2-requestbuffers\"><a href=\"#4、v4l2-requestbuffers\" class=\"headerlink\" title=\"4、v4l2_requestbuffers\"></a>4、v4l2_requestbuffers</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_requestbuffers</span> &#123;</span></span><br><span class=\"line\">    __u32                   count;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span>      <span class=\"title\">type</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_memory</span>        <span class=\"title\">memory</span>;</span></span><br><span class=\"line\">    __u32                   reserved[<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_memory</span> &#123;</span></span><br><span class=\"line\">    V4L2_MEMORY_MMAP             = <span class=\"number\">1</span>,</span><br><span class=\"line\">    V4L2_MEMORY_USERPTR          = <span class=\"number\">2</span>,</span><br><span class=\"line\">    V4L2_MEMORY_OVERLAY          = <span class=\"number\">3</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>VIDIOC_REQBUFS 命令通过结构 v4l2_requestbuffers 请求驱动申请一片连续的内存用于缓存视频信息;count 指定根据图像占用空间大小申请的缓存区个数，type 为视频捕获模式，memory 为内存区的使用方式.</p>\n<h3 id=\"5、v4l2-buffer\"><a href=\"#5、v4l2-buffer\" class=\"headerlink\" title=\"5、v4l2_buffer\"></a>5、v4l2_buffer</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_buffer</span> &#123;</span></span><br><span class=\"line\">    __u32   index;\t<span class=\"comment\">//buffer 序号 </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span>    <span class=\"title\">type</span>;</span>\t<span class=\"comment\">//buffer 类型 </span></span><br><span class=\"line\">    __u32    bytesused;\t<span class=\"comment\">//缓存已使用空间大小，buffer 中已使用的字节数</span></span><br><span class=\"line\">    __u32    flags;\t<span class=\"comment\">//区分是MMAP 还是USERPTR</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_field</span>  <span class=\"title\">field</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span>    <span class=\"title\">timestamp</span>;</span>\t<span class=\"comment\">//获取第一个字节时的系统时间 </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_timecode</span>   <span class=\"title\">timecode</span>;</span></span><br><span class=\"line\">    __u32     sequence;\t<span class=\"comment\">//队列中的序号</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/* memory location */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_memory</span>    <span class=\"title\">memory</span>;</span>\t<span class=\"comment\">//缓存使用方式</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">            __u32   offset;<span class=\"comment\">//当前缓存与内存区起始地址的偏移，缓冲帧地址，只对MMAP 有效  </span></span><br><span class=\"line\">            <span class=\"type\">unsigned</span> <span class=\"type\">long</span>   userptr;</span><br><span class=\"line\">            <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_plane</span> *<span class=\"title\">planes</span>;</span></span><br><span class=\"line\">    &#125; m;</span><br><span class=\"line\">    __u32    length;\t<span class=\"comment\">//缓冲帧长度</span></span><br><span class=\"line\">    __u32    input;</span><br><span class=\"line\">    __u32    reserved;\t<span class=\"comment\">//一般用于传递物理地址值</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_plane</span> &#123;</span></span><br><span class=\"line\">\t__u32\t\t\tbytesused;</span><br><span class=\"line\">\t__u32\t\t\tlength;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">\t\t__u32\t\tmem_offset;<span class=\"comment\">//offset是放在m.mem_offset中返回用户空间的</span></span><br><span class=\"line\">\t\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span>\tuserptr;</span><br><span class=\"line\">\t\t__s32\t\tfd;</span><br><span class=\"line\">\t&#125; m;</span><br><span class=\"line\">\t__u32\t\t\tdata_offset;</span><br><span class=\"line\">\t__u32\t\t\treserved[<span class=\"number\">11</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>flags 为缓存当前状态（常见值有 V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE，分别代表当前缓存已经映射、缓存可以采集数据、缓存可以提取数据）</p>\n<p>另外 VIDIOC_QUERYBUF，VIDIOC_QBUF 和 VIDIOC_DQBUF 命令都采用结构 v4l2_buffer 与驱动通信：VIDIOC_QBUF 命令向驱动传递应用程序已经处理完的缓存，即将缓存加入空闲可捕获视频的队列，传递的主要参数为 index；VIDIOC_DQBUF 命令向驱动获取已经存放有视频数据的缓存，v4l2_buffer 的各个域几乎都会被更新，但主要的参数也是 index，应用程序会根据 index 确定可用数据的起始地址和范围。</p>\n<h3 id=\"6、v4l2-captureparm\"><a href=\"#6、v4l2-captureparm\" class=\"headerlink\" title=\"6、v4l2_captureparm\"></a>6、v4l2_captureparm</h3><p>设置Stream参数。(主要是采集帧数)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_streamparm</span> <span class=\"title\">parms</span>;</span></span><br><span class=\"line\">parms.parm.capture.timeperframe.numerator=<span class=\"number\">1</span>;</span><br><span class=\"line\">parms.parm.capture.timeperframe.denominator=<span class=\"number\">60</span>;</span><br><span class=\"line\">rel = ioctl(fdUsbCam,VIDIOC_S_PARM, setfps);</span><br></pre></td></tr></table></figure>\n\n<p>对于捕获设备而言，parm.capture字段是要关注的内容，这个结构体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_captureparm</span></span></span><br><span class=\"line\"><span class=\"class\">    &#123;</span></span><br><span class=\"line\">       __u32             capability;</span><br><span class=\"line\">       __u32             capturemode;</span><br><span class=\"line\">       structv4l2_fract  timeperframe;</span><br><span class=\"line\">       __u32             extendedmode;</span><br><span class=\"line\">       __u32          readbuffers;</span><br><span class=\"line\">       __u32             reserved[<span class=\"number\">4</span>];</span><br><span class=\"line\">   &#125;; </span><br><span class=\"line\">timeperframe字段用于指定想要使用的帧频率，它又是一个结构体：</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_fract</span>&#123;</span></span><br><span class=\"line\">       __u32  numerator;</span><br><span class=\"line\">       __u32  denominator;</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>numerator和denominator所描述的系数给出的是成功的帧之间的时间间隔。numerator 分子， denominator 分母。主要表达每次帧之间时间间隔。 numerator&#x2F; denominator秒一帧。</p>\n<h3 id=\"7、v4l2-exportbuffer\"><a href=\"#7、v4l2-exportbuffer\" class=\"headerlink\" title=\"7、v4l2_exportbuffer\"></a>7、v4l2_exportbuffer</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_exportbuffer</span> &#123;</span></span><br><span class=\"line\">\t__u32\t\ttype; <span class=\"comment\">/* enum v4l2_buf_type */</span></span><br><span class=\"line\">\t__u32\t\tindex;</span><br><span class=\"line\">\t__u32\t\tplane;</span><br><span class=\"line\">\t__u32\t\tflags;</span><br><span class=\"line\">\t__s32\t\tfd;</span><br><span class=\"line\">\t__u32\t\treserved[<span class=\"number\">11</span>];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"六、应用程序代码分析\"><a href=\"#六、应用程序代码分析\" class=\"headerlink\" title=\"六、应用程序代码分析\"></a>六、应用程序代码分析</h1><h2 id=\"1、保存图像picture-yuv\"><a href=\"#1、保存图像picture-yuv\" class=\"headerlink\" title=\"1、保存图像picture.yuv\"></a>1、保存图像picture.yuv</h2><p>见code中，camera_app_pic.c</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/videodev2.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/ioctl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/select.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VideoBuffer</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">void</span>   *start;<span class=\"comment\">//帧缓存mmap映射后的首地址</span></span><br><span class=\"line\">\t<span class=\"type\">size_t</span>  length;<span class=\"comment\">//缓存大小</span></span><br><span class=\"line\">&#125; VideoBuffer;</span><br><span class=\"line\">VideoBuffer *buffers;<span class=\"comment\">//用来存放映射后的帧缓存区地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">camera_device_open</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd;</span><br><span class=\"line\">\t<span class=\"comment\">//用阻塞模式打开摄像头设备</span></span><br><span class=\"line\">\tfd = open(<span class=\"string\">&quot;/dev/video0&quot;</span>,O_RDWR,<span class=\"number\">0</span>);<span class=\"comment\">//设备节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(fd &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;open /dev/video0 is fail.\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">init_camera_attribute</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> numBufs;<span class=\"comment\">//</span></span><br><span class=\"line\">\tv4l2_std_id id;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_format</span> <span class=\"title\">fmt</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_requestbuffers</span>  <span class=\"title\">req</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_buffer</span>    <span class=\"title\">buf</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//检查当前视频设备支持的标准</span></span><br><span class=\"line\">\tioctl(fd,VIDIOC_QUERYSTD,&amp;id);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//设置视频捕获格式</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(&amp;fmt,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(fmt));</span><br><span class=\"line\">\tfmt.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;<span class=\"comment\">//视频捕获模式</span></span><br><span class=\"line\">\tfmt.fmt.pix.width = <span class=\"number\">640</span>;<span class=\"comment\">//视频的宽</span></span><br><span class=\"line\">\tfmt.fmt.pix.height = <span class=\"number\">480</span>;<span class=\"comment\">//视频的高</span></span><br><span class=\"line\">\tfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;<span class=\"comment\">//视频数据格式YUYV</span></span><br><span class=\"line\"><span class=\"comment\">//\tfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YVU420;</span></span><br><span class=\"line\">\tfmt.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_S_FMT,&amp;fmt) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;set VIDIOC_S_FMT is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">//分配内存，申请帧缓存，</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(&amp;req,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(req));</span><br><span class=\"line\">\treq.count = <span class=\"number\">4</span>;<span class=\"comment\">//帧缓存的个数，一般不大于5</span></span><br><span class=\"line\">\treq.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\treq.memory = V4L2_MEMORY_MMAP;<span class=\"comment\">//内存区的使用方式，mmap映射</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_REQBUFS,&amp;req) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;set VIDIOC_REQBUFS is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//获取并记录缓存的物理空间</span></span><br><span class=\"line\">\tbuffers = <span class=\"built_in\">calloc</span>(req.count,<span class=\"keyword\">sizeof</span>(*buffers));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(numBufs = <span class=\"number\">0</span>; numBufs &lt; req.count; numBufs ++)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(&amp;buf,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\t\tbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\t\tbuf.memory = V4L2_MEMORY_MMAP;</span><br><span class=\"line\">\t\tbuf.index = numBufs;<span class=\"comment\">//缓存编号，4帧缓存</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//读取缓存，查询帧缓冲区在内核空间中的长度和偏移量</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_QUERYBUF,&amp;buf) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">&quot;set VIDIOC_REQBUFS is fail&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t <span class=\"comment\">// 转换成相对地址，将申请到的帧缓冲映射到用户空间mmap</span></span><br><span class=\"line\">\t\tbuffers[numBufs].length = buf.length;</span><br><span class=\"line\">\t\tbuffers[numBufs].start  = mmap(<span class=\"literal\">NULL</span>,buf.length,PROT_READ|PROT_WRITE,</span><br><span class=\"line\">\t\t\t\tMAP_SHARED,fd,buf.m.offset);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(buffers[numBufs].start == MAP_FAILED)&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">&quot;mmap is fail&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);\t</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 放入缓存队列</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_QBUF,&amp;buf) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">&quot;set VIDIOC_QBUF is fail&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">start_capturing</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span> <span class=\"title\">type</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//开始采集数据</span></span><br><span class=\"line\">\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_STREAMON,&amp;type) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;start capturing is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//保存图片</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">build_picture</span><span class=\"params\">(<span class=\"type\">void</span> *addr,<span class=\"type\">int</span> length)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tFILE *fp;</span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> picture_name[<span class=\"number\">20</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">sprintf</span>(picture_name,<span class=\"string\">&quot;picture%d.yuv&quot;</span>,num++);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tfp = fopen(picture_name,<span class=\"string\">&quot;w&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(fp == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;fail to open &quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfwrite(addr,<span class=\"number\">1</span>,length,fp);</span><br><span class=\"line\"></span><br><span class=\"line\">\tfclose(fp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">read_image</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_buffer</span> <span class=\"title\">buf</span>;</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(&amp;buf,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(buf));</span><br><span class=\"line\">\tbuf.type=V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\tbuf.memory=V4L2_MEMORY_MMAP;</span><br><span class=\"line\">\tbuf.index=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//读取缓存，出列以取得已采集数据的帧缓冲，取得原始数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_DQBUF,&amp;buf) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;set VIDIOC_DQBUF is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//将数据存为图片</span></span><br><span class=\"line\">\tbuild_picture(buffers[buf.index].start,buffers[buf.index].length);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//重新放入缓存队列，处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_QBUF,&amp;buf) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;reset VIDIOC_QBUF is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">when_to_read</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)<span class=\"comment\">//保存三张图片</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tfd_set rfds;<span class=\"comment\">//指定内核监测的文件描述符集合</span></span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv</span>;</span><span class=\"comment\">//设置超时时间</span></span><br><span class=\"line\">\t\t<span class=\"type\">int</span> retval;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tFD_ZERO(&amp;rfds);<span class=\"comment\">//清空集合</span></span><br><span class=\"line\">\t\tFD_SET(fd, &amp;rfds);<span class=\"comment\">//将fd添加到集合中</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttv.tv_sec = <span class=\"number\">2</span>;</span><br><span class=\"line\">\t\ttv.tv_usec = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//当有数据采集好在缓冲区准备好时，开始读取缓存数据</span></span><br><span class=\"line\">\t\tretval = select(fd+<span class=\"number\">1</span>, &amp;rfds, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;tv);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(retval == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t perror(<span class=\"string\">&quot;select()&quot;</span>);</span><br><span class=\"line\">\t\t\t <span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(retval == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;select is timeout\\n&quot;</span>);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tread_image(fd);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">stop_capturing</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">v4l2_buf_type</span> <span class=\"title\">type</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//停止采集数据</span></span><br><span class=\"line\">\ttype = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ioctl(fd,VIDIOC_STREAMOFF,&amp;type) == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\tperror(<span class=\"string\">&quot;stop capturing is fail&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">uninit_camera</span><span class=\"params\">(<span class=\"type\">int</span> fd)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"comment\">//释放申请的视频帧缓冲区</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"number\">-1</span> == munmap(buffers[i].start,buffers[i].length))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tperror(<span class=\"string\">&quot;munmap is fail&quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(buffers);</span><br><span class=\"line\">\t<span class=\"comment\">//关闭视频设备文件</span></span><br><span class=\"line\">\tclose(fd);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> fd;</span><br><span class=\"line\">\tfd = camera_device_open();\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tinit_camera_attribute(fd);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tstart_capturing(fd);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhen_to_read(fd);</span><br><span class=\"line\"></span><br><span class=\"line\">\tstop_capturing(fd);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tuninit_camera(fd);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2、保存视频video-yuv\"><a href=\"#2、保存视频video-yuv\" class=\"headerlink\" title=\"2、保存视频video.yuv\"></a>2、保存视频video.yuv</h2><p>见code中，camera_app_mp4.c</p>\n<p>主要区别：fp &#x3D; fopen(video_name,”a”)，追加写的方式打开，进行采集</p>\n<h1 id=\"七、V4l2驱动框架\"><a href=\"#七、V4l2驱动框架\" class=\"headerlink\" title=\"七、V4l2驱动框架\"></a>七、V4l2驱动框架</h1><h2 id=\"1、主要对象\"><a href=\"#1、主要对象\" class=\"headerlink\" title=\"1、主要对象\"></a>1、主要对象</h2><h3 id=\"1、video-device\"><a href=\"#1、video-device\" class=\"headerlink\" title=\"1、video_device\"></a>1、video_device</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">video_device</span></span></span><br><span class=\"line\"><span class=\"class\">\t\t&#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_file_operations</span> *<span class=\"title\">fops</span>;</span> </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//操作方法结构体</span></span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> *<span class=\"title\">cdev</span>;</span>\t（file_opreations）\t</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//字符设备驱动</span></span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_device</span> *<span class=\"title\">v4l2_dev</span>;</span>\t<span class=\"comment\">/* v4l2_device parent */</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">char</span> name[<span class=\"number\">32</span>]; </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//驱动的名字</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> minor;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//次设备号</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">void</span> (*release)(<span class=\"keyword\">struct</span> video_device *vdev);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//释放资源的函数</span></span><br><span class=\"line\">\t\t\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_ioctl_ops</span> *<span class=\"title\">ioctl_ops</span>;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//ioctl的操作方法</span></span><br><span class=\"line\">\t\t&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>  一个字符设备，为用户空间提供设备节点(&#x2F;dev&#x2F;videox)，提供系统调用的相关操作(open、ioctl…) </p>\n<p>可以看到video_device中含有一个cdev还有v4l2_device，此外还有fops和ioctl_ops，从应用层进行系统调用会经过v4l2的核心层回调到这里 </p>\n<h4 id=\"v4l2-file-operations\"><a href=\"#v4l2-file-operations\" class=\"headerlink\" title=\"v4l2_file_operations\"></a>v4l2_file_operations</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_file_operations</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*read) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">char</span> __user *, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*write) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">const</span> <span class=\"type\">char</span> __user *, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *);</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"title function_\">int</span> <span class=\"params\">(*poll)</span> <span class=\"params\">(<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> poll_table_struct *)</span>;</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*ioctl) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>);</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*unlocked_ioctl) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>);</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"title function_\">long</span> <span class=\"params\">(*get_unmapped_area)</span> <span class=\"params\">(<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>,</span></span><br><span class=\"line\"><span class=\"params\">\t\t\t\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>)</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*mmap) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> vm_area_struct *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*open) (<span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*release) (<span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"v4l2-ioctl-ops\"><a href=\"#v4l2-ioctl-ops\" class=\"headerlink\" title=\"v4l2_ioctl_ops\"></a>v4l2_ioctl_ops</h4><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_ioctl_ops</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_querycap)(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_capability *cap);</span><br><span class=\"line\">\t<span class=\"comment\">/* Buffer handlers */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_reqbufs) (<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_requestbuffers *b);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_querybuf)(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_buffer *b);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_qbuf)    (<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_buffer *b);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_dqbuf)   (<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">struct</span> v4l2_buffer *b);</span><br><span class=\"line\">    <span class=\"comment\">/* Stream on/off */</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_streamon) (<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">enum</span> v4l2_buf_type i);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*vidioc_streamoff)(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">void</span> *fh, <span class=\"keyword\">enum</span> v4l2_buf_type i);</span><br><span class=\"line\">   \t...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> v4l2有很多ioctl操作，具体实现都在这里 </p>\n<h3 id=\"2、v4l2-device\"><a href=\"#2、v4l2-device\" class=\"headerlink\" title=\"2、v4l2_device\"></a>2、v4l2_device</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_device</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">/* used to keep track of the registered subdevs */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">subdevs</span>;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>  嵌入到video_device中，表示一个v4l2设备的实例 </p>\n<p>可以看到v4l2_device中有一个v4l2_subdev的链表，v4l2_device的主要目的时用来管理v4l2_subdev </p>\n<h3 id=\"3、v4l2-subdev\"><a href=\"#3、v4l2-subdev\" class=\"headerlink\" title=\"3、v4l2_subdev\"></a>3、v4l2_subdev</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_subdev</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">list_head</span> <span class=\"title\">list</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_device</span> *<span class=\"title\">v4l2_dev</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_subdev_ops</span> *<span class=\"title\">ops</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p> 依附在v4l2_device之下，并表示一个v4l2设备的子设备，一个v4l2_devide下可以有多个sub_device </p>\n<p> v4l2_subdev中有一个v4l2_subdev_ops，实现了一系列的操作，供v4l2_device调用 </p>\n<p> <strong>subdev的设计目的是为了多路复用，就是用一个v4l2_device可以服务多个v4l2_subdev</strong> </p>\n<h3 id=\"4、V4l2提供的注册接口\"><a href=\"#4、V4l2提供的注册接口\" class=\"headerlink\" title=\"4、V4l2提供的注册接口\"></a>4、V4l2提供的注册接口</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">video_register_device</span><span class=\"params\">(<span class=\"keyword\">struct</span> video_device *vdev, <span class=\"type\">int</span> type, <span class=\"type\">int</span> nr)</span>;<span class=\"comment\">//video_device注册</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">video_unregister_device</span><span class=\"params\">(<span class=\"keyword\">struct</span> video_device *vdev)</span>;<span class=\"comment\">//video_device注销</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">v4l2_device_register</span><span class=\"params\">(<span class=\"keyword\">struct</span> device *dev, <span class=\"keyword\">struct</span> v4l2_device *v4l2_dev)</span>;<span class=\"comment\">//v4l2_device注册</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">v4l2_device_unregister</span><span class=\"params\">(<span class=\"keyword\">struct</span> v4l2_device *v4l2_dev)</span>;<span class=\"comment\">//v4l2_device注销</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">v4l2_device_register_subdev</span><span class=\"params\">(<span class=\"keyword\">struct</span> v4l2_device *v4l2_dev,<span class=\"keyword\">struct</span> v4l2_subdev *sd)</span>;<span class=\"comment\">//v4l2_subdev注册</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">v4l2_device_unregister_subdev</span><span class=\"params\">(<span class=\"keyword\">struct</span> v4l2_subdev *sd)</span>;<span class=\"comment\">//v4l2_subdev注销</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2、图示\"><a href=\"#2、图示\" class=\"headerlink\" title=\"2、图示\"></a>2、图示</h2><img src=\"1.png\"  />\n\n<img src=\"2.png\"  />\n\n<img src=\"3.png\" style=\"zoom:80%;\" />\n\n<h2 id=\"3、主要框架\"><a href=\"#3、主要框架\" class=\"headerlink\" title=\"3、主要框架\"></a>3、主要框架</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;...&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">video_device</span>* <span class=\"title\">video_dev</span>;</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_device</span> <span class=\"title\">v4l2_dev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现各种系统调用 */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_file_operations</span> <span class=\"title\">video_dev_fops</span> =</span> &#123;</span><br><span class=\"line\">\t.owner\t\t    = THIS_MODULE,</span><br><span class=\"line\">\t.release        = vdev_close,</span><br><span class=\"line\">\t.read           = vdev_read,</span><br><span class=\"line\">\t.poll\t\t    = vdev_poll,</span><br><span class=\"line\">\t.ioctl          = video_ioctl2,</span><br><span class=\"line\">\t.mmap           = vdev_mmap,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 实现各种系统调用 */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">v4l2_ioctl_ops</span> <span class=\"title\">video_dev_ioctl_ops</span> =</span> &#123;</span><br><span class=\"line\">\t.vidioc_querycap      = vidioc_querycap,</span><br><span class=\"line\">\t.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,</span><br><span class=\"line\">\t.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,</span><br><span class=\"line\">\t.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,</span><br><span class=\"line\">\t.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,</span><br><span class=\"line\">\t.vidioc_reqbufs       = vidioc_reqbufs,</span><br><span class=\"line\">\t.vidioc_querybuf      = vidioc_querybuf,</span><br><span class=\"line\">\t.vidioc_qbuf          = vidioc_qbuf,</span><br><span class=\"line\">\t.vidioc_dqbuf         = vidioc_dqbuf,</span><br><span class=\"line\">\t.vidioc_enum_input    = vidioc_enum_input,</span><br><span class=\"line\">\t.vidioc_g_input       = vidioc_g_input,</span><br><span class=\"line\">\t.vidioc_s_input       = vidioc_s_input,</span><br><span class=\"line\">\t.vidioc_streamon      = vidioc_streamon,</span><br><span class=\"line\">\t.vidioc_streamoff     = vidioc_streamoff,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __init <span class=\"title function_\">video_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 分配并设置一个video_device */</span></span><br><span class=\"line\">    video_dev = video_device_alloc();</span><br><span class=\"line\">    video_dev-&gt;fops = &amp;video_dev_fops;</span><br><span class=\"line\">    video_dev-&gt;ioctl_ops = &amp;video_dev_ioctl_ops;</span><br><span class=\"line\">    video_dev-&gt;release = video_device_release;</span><br><span class=\"line\">    video_dev-&gt;tvnorms = V4L2_STD_525_60;</span><br><span class=\"line\">    video_dev-&gt;current_norm = V4L2_STD_NTSC_M;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 注册一个v4l2_device */</span></span><br><span class=\"line\">    v4l2_device_register(video_dev-&gt;dev, &amp;v4l2_dev);    </span><br><span class=\"line\">    video_dev-&gt;v4l2_dev = &amp;video_dev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 注册一个video_device字符设备 */</span></span><br><span class=\"line\">    video_register_device(video_dev, VFL_TYPE_GRABBER, <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __exit <span class=\"title function_\">video_exit</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//注销</span></span><br><span class=\"line\">    video_unregister_device(video_dev);</span><br><span class=\"line\">    v4l2_device_unregister(&amp;v4l2_dev);</span><br><span class=\"line\">    video_device_release(video_dev);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module_init(video_init);</span><br><span class=\"line\">module_exit(video_exit);</span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"八、多路video输入分析\"><a href=\"#八、多路video输入分析\" class=\"headerlink\" title=\"八、多路video输入分析\"></a>八、多路video输入分析</h1><h2 id=\"1、多路操作流程\"><a href=\"#1、多路操作流程\" class=\"headerlink\" title=\"1、多路操作流程\"></a>1、多路操作流程</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1.设备初始化</span></span><br><span class=\"line\">_Init()&#123;</span><br><span class=\"line\">    _open()｛</span><br><span class=\"line\">        fd[i] = open(dev_name[i], O_RDWR <span class=\"comment\">/* required */</span>  | O_NONBLOCK, <span class=\"number\">0</span>);</span><br><span class=\"line\">    ioctl(fd[i], VIDIOC_S_INPUT, &amp;inp);<span class=\"comment\">//设置输入</span></span><br><span class=\"line\">    ioctl(fd[i], VIDIOC_S_PARM, &amp;parms);<span class=\"comment\">//主要用来设置采集帧数</span></span><br><span class=\"line\">        ｝;<span class=\"comment\">//打开设备节点</span></span><br><span class=\"line\">    _Fmtset()｛</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_S_FMT, &amp;fmt);<span class=\"comment\">//设置</span></span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_G_FMT, &amp;fmt);<span class=\"comment\">//查询，判断设置是否成功</span></span><br><span class=\"line\">        ｝;<span class=\"comment\">//设置视频捕获模式</span></span><br><span class=\"line\">    _BuffReq()｛</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_REQBUFS, &amp;req);</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_QUERYBUF, &amp;buf);</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_QBUF, &amp;buf);</span><br><span class=\"line\">        ｝;<span class=\"comment\">//申请帧缓存，查询缓存转换地址，放入队列</span></span><br><span class=\"line\">    _ON&#123;</span><br><span class=\"line\">        ioctl(fd[i], VIDIOC_STREAMON, &amp;type);</span><br><span class=\"line\">    &#125;;<span class=\"comment\">//开启视频捕获</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.创建多线程</span></span><br><span class=\"line\">pthread_create(&amp;capture_pth, <span class=\"literal\">NULL</span>,Video_Capture, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"><span class=\"comment\">//3.采集数据</span></span><br><span class=\"line\">Video_Capture()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用select监视文件描述符，等待采集，如果有准备好的</span></span><br><span class=\"line\">    select(fd[<span class=\"number\">3</span>] + <span class=\"number\">1</span>, &amp;fdr, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>, &amp;tv);<span class=\"comment\">//IO多路复用</span></span><br><span class=\"line\">    <span class=\"comment\">//当准备好时，采用互斥锁的方式，唤醒休眠的数据处理函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( FD_ISSET(fd[<span class=\"number\">0</span>],&amp;fdr) &amp;&amp; FD_ISSET(fd[<span class=\"number\">1</span>],&amp;fdr) &amp;&amp; \\</span><br><span class=\"line\">\t\tFD_ISSET(fd[<span class=\"number\">2</span>],&amp;fdr) &amp;&amp; FD_ISSET(fd[<span class=\"number\">3</span>],&amp;fdr))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">            _Queryaddr()&#123;</span><br><span class=\"line\">                ioctl(fd[i], VIDIOC_DQBUF, &amp;buf);<span class=\"comment\">//出列</span></span><br><span class=\"line\">                VideoPhyAddr[i] = buf.m.planes[<span class=\"number\">0</span>].m.mem_offset;</span><br><span class=\"line\">                ioctl(fd[i], VIDIOC_QBUF, &amp;buf);<span class=\"comment\">//入列</span></span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            pthread_mutex_lock(&amp;VideoMutex);<span class=\"comment\">//上锁</span></span><br><span class=\"line\">            pthread_cond_signal(&amp;VideoCond);<span class=\"comment\">//唤醒休眠</span></span><br><span class=\"line\">            pthread_mutex_unlock(&amp;VideoMutex);<span class=\"comment\">//解锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//4.数据处理</span></span><br><span class=\"line\">_LoadVideoData()&#123;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;VideoMutex);<span class=\"comment\">//上锁</span></span><br><span class=\"line\">\tpthread_cond_wait(&amp;VideoCond, &amp;VideoMutex);<span class=\"comment\">//休眠</span></span><br><span class=\"line\">\tpthread_mutex_unlock(&amp;VideoMutex);<span class=\"comment\">//解锁</span></span><br><span class=\"line\">    <span class=\"comment\">//************************</span></span><br><span class=\"line\">    <span class=\"comment\">//***原始视频流数据处理***</span></span><br><span class=\"line\">    <span class=\"comment\">//************************</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"图像格式之 YUV & RGB","date":"2023-04-13T04:56:11.000Z","comments":0,"description":null,"typora-root-url":"2-YUV&RGB","_content":"\n<div align = \"center\">图像格式之 YUV & RGB</div>\n\n# 一、图像颜色空间介绍\n\n## 1.RGB\n\n采样与编码格式\n\nR、G、B分别代表red、green、blue，三原色。将他们按照不同比例叠加，可得到更多不同颜色。\n\n![](1.png)\n\n每个像素点的颜色由R、G、B三原色表示。每一个颜色通道（原色）包含2^8= 256种不同的红/绿/蓝（八位二进制），占用8bit，也就是一字节，那么一个像素点也就占用了3字节。\n\n<!--more-->\n\n图片大小计算：一张 1280 * 720 大小的图片，就占用 1280 * 720 * 3 / 1024 / 1024 = 2.63 MB 存储空间。\n\n```c\n//RGB常见的的几种格式和描述：\nRGB565 每个像素用16位表示，RGB分量各使用5位、6位、5位；\nRGB555 每个像素用16位表示，RGB分量都使用5位（剩下1位不用）；\nRGB24 每个像素用24位表示，RGB分量各使用8位；\nRGB32 每个像素用32位表示，RGB分量各使用8位（剩下8位不用）；\nARGB32 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha(透明度)通道值）；\n```\n\n常见的RGB格式有：RGB_565、RGB_888、ARGB_8888、ARGB_4444等。但是也有列外，尤其是搞安卓的同学要特别注意，谷歌在这里给我们挖了一个坑，那就是，ARGB_8888和ARGB_4444实际上在底层对应的是 RGBA_8888和RGBA_4444，例如ARGB_8888图像，其像素数据在内存中其实是以R G B A R G B A …的顺序排布的。\n\n## 2.YUV\n\n简介：与我们熟知的RGB类似，YUV也是一种颜色编码方法；主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，\n\n这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。\n\n### 1）颜色空间\n\n在YUV颜色空间中，YUV（YCbCr ）格式也包含三个分量：\n\t\tY——明亮度（Luma），也成灰阶，没有UV分量也可成像，图像是黑白的（基础信号）\n\t\tUV——色度（Chroma）：色彩+色彩饱和度（正交调制信号）\n\n每个 Y 分量可以都有自己对应的 UV 分量，也可以几个 Y 分量共用 UV 分量，这就是为何会有YUV4:4:4、YUV4:2:2、YUV4:2:0采样格式出现，用于减小图像包含的数据量大小，便于传输和存储。\n\n![](2.png)\n\n```c\n//YUV种类分为很多，可以理解是一个二维的，即空间间，和空间内，这样的表述，借鉴了h264中的帧间和帧内的思想。\n空间-间：不同空间，即描述一个像素的bit数不同，比如yuv444，yuv422，yuv411，yuv420\n空间-内：相同空间，即描述一个像素的bit数相同，但是存储方式不同，比如对于yuv420而言，又可细分为yuv420p，yuv420sp，nv21，nv12，yv12，yu12，I420\n//为什么yuv444，yuv420，yuv422，yuv411都是用的4呢？\n-->因为用到了共享的思想，这是yuv和rgb的本质区别.\nrgb是一个像素是一个家庭，家庭成员是r，g，b，但是yuv是若干像素是一个家庭，不同像素的y共享同一个u和v，这样，引入了共享的思想，虽然最小单位是一个字节，但实际上描述一个像素点的字节，不一定是字节的整数倍\n```\n\n### 2）采样格式\n\n#### YUV 444\n\nYUV三个信道的信号全采样，每个像素的三个分量信息完整（每个分量一般用8bit），因此每个像素经量化后，未经压缩，占用3字节。\n\n```c\n[yuv][yuv][yuv][yuv]\n[yuv][yuv][yuv][yuv]\n[yuv][yuv][yuv][yuv]\n[yuv][yuv][yuv][yuv]\n//一个家庭成员是[yuv]，每个Y对应一组UV，一个YUV占24bits 3个字节；\n\n//假设四个像素为:\t[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]\n//存放的码流为:\tY0 U0 V0 Y1 U1 V1Y2 U2 V2Y3 U3 V3\n```\n\n\n\n#### YUV 422\n\n亮度Y分量保持不变；对UV分量进行采样，数据量减小一半。\n\n```c\n[yu][yv][yu][yv]\n[yv][yu][yv][yu]\n[yu][yv][yu][yv]\n[yv][yu][yv][yu]\n//一个家庭成员是[yu] [yv]，也就是2个Y公用一个UV，一个YUV占8+4+4=16bits 2个节。\n\n//假设四个像素为:[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]\n//采样码流为：[Y0 U0 ] [Y1 V1] [Y2 U2 ] [Y3 V3]\n```\n\n隔行扫描，行1出U分量，那么下一行行2则出V分量（即UV分量按照1:1的比例进行采样），最终相邻两个Y分量共用一组UV分量。\n\n#### YUV 420\n\n亮度Y分量保持不变；对UV分量进行采样，数据量只有1/4\n\n``` c\n//吐槽:yuv420的意思似乎是在yuv422的基础上，再拿掉两个v，这样不就没有v了吗？其实yuv420的取名方式不是很高明，更确切的命名为yuv420yuv402也就是第一行只有两个u，而第二行只有两个v，如下图；\n```\n\n```c\n[yu][y][yu][y]\n[yv][y][yv][y]\n[yu][y][yu][y]\n[yv][y][yv][y]\n//一个家庭成员是[yu][y],4个Y公用一组UV，每个YUV占用8+2+2=12bits，1.5个字节；\n//\t\t\t  [yv][y]\n//假设八个像素为:[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]\n//\t\t\t   [Y5 U5 V5] [Y6 U6 V6] [Y7 U7 V7] [Y8 U8 V8]\n//采样码流为：[Y0 U0 ] [Y1 ] [Y2 U2 ] [Y3 ]\n//\t\t\t[Y5 V5] [Y6 ] [Y7 V7] [Y8 ]\n//存放的码流为:\n//\t\t\t[Y0 U0 V5] [Y1 U0 V5] [Y2 U2 V7] [Y3 U2 V7]\n//\t\t\t[Y5 U0 V5] [Y6 U0 V5] [Y7 U2 V7] [Y8 U2 V7]\n```\n\n隔行扫描，且UV分量按照2:1的比例进行采样，第一个像素保留一半U/(V)数据，相邻第二个像素U和V分量全舍弃，第三个像素采集第二次U/(V)数据，第四个像素U和V分量全舍弃，第五个像素采集第一次V/(U)，最终相邻四个Y分量共用一组UV分量，而且是按照 2*2 的小方格的形式分布。\n\n#### 图示：\n\n![](3.png)\n\n黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量。\n\t\tYUV 4:4:4采样，每一个Y对应一组UV分量。\n\t\tYUV 4:2:2采样，每两个Y共用一组UV分量。\n\t\tYUV 4:2:0采样，每四个Y共用一组UV分量，如图中的红色部分。\n\n### 3)图像大小计算\n\n假设一幅图像，像素大小为1280*720\n\nYUV 4:4:4采样，(1280 * 720 * 3) / 1024 / 1024 ≈2.64M\n\nYUV 4:2:2采样，(1280 * 720 * 2) / 1024 / 1024 ≈1.76M\n\nYUV 4:2:0采样，(1280 * 720 * 3 / 2) / 1024 / 1024 ≈1.32M\n\n### 4）存储格式\n\n#### planar\n\n平面格式：指连续存储所有像素点的Y分量，然后存储U分量，最后是V分量，3个plane。\n\n#### packed \n\n打包模式：指每个像素点的Y、U、V分量是连续交叉存储的，1个plane。\n\n#### semi-planar:\n\nY连续存储，U、V交叉存储，如NV21、NV12，即2个plane。\n\n#### 图示：\n\n| YUV444 | YUV422         | YUV420         | YUV411 |\n| ------ | -------------- | -------------- | ------ |\n|        | YU16(YUV422P)  | YU12(YUV420P)  |        |\n|        | YV16(YUV422P)  | YV12(YUV420P)  |        |\n|        | NV16(YUV422SP) | NV12(YUV420SP) |        |\n|        | NV61(YUV422SP) | NV21(YUV420SP) |        |\n|        | YUYV422        |                |        |\n|        | UYVY           |                |        |\n\n# 二、图像格式介绍\n\n## 1.RGB\n\n### 1.RGB555(高彩色)\n\n​    RGB555是一种16位的RGB格式，R、G、B分量都用5位来表示，剩下的一位不用，存储格式如下图：\n\n![](4.png)\n\n```c\n//假设计算机中存储某一个像素点的变量为color, 数据类型为short.，那么则有：\n\nR = color & 0x7C00, (获取高字节的5个bit)\nG = color & 0x03E0, (获取中间5个bit)\nB = color & 0x001F, (获取低字节5个bit)\n```\n\n### 2.RGB565(高彩色)\n\n   RGB565同样是一种16位的RGB格式，R和B分量用5位来表示，G分量用6位标志。存储格式如下图：\n\n![](5.png)\n\n```c\n//假设计算机中存储某一个像素点的变量为color, 数据类型为short， 那么则有：\n\nR = color & 0xF800, (获取高字节的5个bit)\nG = color & 0x07E0, (获取中间6个bit)\nB = color & 0x001F, (获取低字节5个bit)\n```\n\n### 3.RGB24(真彩色)\n\nRGB24是一种24位的RGB格式，R、G、B分量都用8位来表示，每位取值范围都为0-255。存储格式如下图：\n\n![](6.png)\n\n```c\n//假设计算机中存储某一个像素点的变量为color, 数据类型为int， 那么则有：\n    \nR = color & 0x000000FF,\nG = color & 0x0000FF00,\nB = color & 0x00FF0000,\n```\n\n### 4.RGB32(真彩色)\n\n  RGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha通道或者不用。Alpha通道是一个8位的灰度通道，该通道用256级灰度来记录图像中的透明度信息，定义透明、不透明和半透明区域，其中白表示不透明，黑表示透明，灰表示半透明。其结构如下：\n\n![](7.png)\n\n```c\n//假设计算机中存储某一个像素点的变量为color, 数据类型为int，那么则有:\na、低8位保留\nR = color & 0x0000FF00\nG = color & 0x00FF0000,\nB = color & 0xFF000000,\nb、低8位为ALPHA值\nR = color & 0x0000FF00,\nG = color & 0x00FF0000,\nB = color & 0xFF000000,\nA = color & 0x000000FF,\n```\n\n\n\n## 2.YUV\n\n### 1.YUV420SP\n\n#### 1.NV12 \n\nNV21图像格式属于 YUV颜色空间中的YUV420SP格式，每四个Y分量共用一组U分量和V分量，Y连续排序，U与V交叉排序。\n\n```c\n//排列方式如：\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\n\nV U   V U   V U  V U\nV U   V U   V U  V U\n```\n\n####  2.NV21\n\nNV12图像格式属于 YUV颜色空间中的YUV420SP格式，每四个Y分量共用一组U分量和V分量，Y连续排序，U与V交叉排序（NV12和NV21只是U与V的位置相反）。\n\n```c\n//排列方式如：\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\n\nU V   U V   U V  U V\nU V   U V   U V  U V\n```\n\n```c\n//NV12: YYYYYYYY UVUV =>YUV420SP\n//NV21: YYYYYYYY VUVU =>YUV420SP\n```\n\n### 2.YUV420P\n\n#### 1.YU12\n\nYU12图像格式属于 YUV颜色空间中的YUV420P格式，每四个Y分量共用一组U分量和V分量，Y、U、V各自连续排序。\n\n```c\n//排列方式如：\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\n\nU     U     U     U\nU     U     U     U\n\nV     V     V     V\nV     V     V     V\n```\n\n#### 2.YV12\n\nYV12图像格式属于 YUV颜色空间中的YUV420P格式，每四个Y分量共用一组U分量和V分量，Y、U、V各自连续排序（YV12和I420只是U与V的位置相反）。\n\n```c\n//排列方式如：\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\n\nV     V     V     V\nV     V     V     V\n\nU     U     U     U\nU     U     U     U\n```\n\n```c\n//YU12: YYYYYYYY UU VV =>YUV420P\n//YV12: YYYYYYYY VV UU =>YUV420P\n```\n\n### 3．YUYV图像格式（打包格式存储）\n\nYUYV图像格式属于 YUV颜色空间中的YUV422格式，每两个Y分量共用一组U分量和V分量，Y、U、V交叉排序。\n\n```c\n//排列方式如：\nY U Y V   Y U Y V   Y U Y V   Y U Y V\n\nY U Y V   Y U Y V   Y U Y V   Y U Y V\n\nY U Y V   Y U Y V   Y U Y V   Y U Y V\n\nY U Y V   Y U Y V   Y U Y V   Y U Y V\n```\n\n\n\n# 三、RGB与YUV的格式转换\n\n图像显示器——通过RGB模型显示图像\n\n传输图像数据——通过YUV模型传输 （YUV 模型可以节省带宽）\n\n![](8.png)\n\n## 转换公式：\n\n1.小数形式, YUV  ( U∈[-0.5-0.5] ,  R，G，B∈[0,1] )\n\n```c\nY =  0.299*R + 0.587*G + 0.114*B;\nU = -0.169*R - 0.331*G + 0.5  *B ;\nV =  0.5  *R - 0.419*G - 0.081*B;\n```\n\n```c\nR = Y + 1.4075 * V;  \nG = Y - 0.3455 * U - 0.7169*V;  \nB = Y + 1.779 * U; \n```\n\n# 四：一图看RGB与YUV\n\n## RGB格式\n\n ![](9.jpg)\n\n## YUV格式\n\n![](10.jpg)\n\n## YUV存储格式\n\n![](11.jpg)\n\n## ARGB\n\n![](12.jpg)\n\n...\n\n...","source":"_posts/2-YUV&RGB.md","raw":"---\ntitle: 图像格式之 YUV & RGB\ndate: 2023-4-13 12:56:11\ncategories: 笔记\ntags: 嵌入式\ncomments: false\ndescription:\ntypora-root-url: 2-YUV&RGB\n---\n\n<div align = \"center\">图像格式之 YUV & RGB</div>\n\n# 一、图像颜色空间介绍\n\n## 1.RGB\n\n采样与编码格式\n\nR、G、B分别代表red、green、blue，三原色。将他们按照不同比例叠加，可得到更多不同颜色。\n\n![](1.png)\n\n每个像素点的颜色由R、G、B三原色表示。每一个颜色通道（原色）包含2^8= 256种不同的红/绿/蓝（八位二进制），占用8bit，也就是一字节，那么一个像素点也就占用了3字节。\n\n<!--more-->\n\n图片大小计算：一张 1280 * 720 大小的图片，就占用 1280 * 720 * 3 / 1024 / 1024 = 2.63 MB 存储空间。\n\n```c\n//RGB常见的的几种格式和描述：\nRGB565 每个像素用16位表示，RGB分量各使用5位、6位、5位；\nRGB555 每个像素用16位表示，RGB分量都使用5位（剩下1位不用）；\nRGB24 每个像素用24位表示，RGB分量各使用8位；\nRGB32 每个像素用32位表示，RGB分量各使用8位（剩下8位不用）；\nARGB32 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha(透明度)通道值）；\n```\n\n常见的RGB格式有：RGB_565、RGB_888、ARGB_8888、ARGB_4444等。但是也有列外，尤其是搞安卓的同学要特别注意，谷歌在这里给我们挖了一个坑，那就是，ARGB_8888和ARGB_4444实际上在底层对应的是 RGBA_8888和RGBA_4444，例如ARGB_8888图像，其像素数据在内存中其实是以R G B A R G B A …的顺序排布的。\n\n## 2.YUV\n\n简介：与我们熟知的RGB类似，YUV也是一种颜色编码方法；主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，\n\n这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。\n\n### 1）颜色空间\n\n在YUV颜色空间中，YUV（YCbCr ）格式也包含三个分量：\n\t\tY——明亮度（Luma），也成灰阶，没有UV分量也可成像，图像是黑白的（基础信号）\n\t\tUV——色度（Chroma）：色彩+色彩饱和度（正交调制信号）\n\n每个 Y 分量可以都有自己对应的 UV 分量，也可以几个 Y 分量共用 UV 分量，这就是为何会有YUV4:4:4、YUV4:2:2、YUV4:2:0采样格式出现，用于减小图像包含的数据量大小，便于传输和存储。\n\n![](2.png)\n\n```c\n//YUV种类分为很多，可以理解是一个二维的，即空间间，和空间内，这样的表述，借鉴了h264中的帧间和帧内的思想。\n空间-间：不同空间，即描述一个像素的bit数不同，比如yuv444，yuv422，yuv411，yuv420\n空间-内：相同空间，即描述一个像素的bit数相同，但是存储方式不同，比如对于yuv420而言，又可细分为yuv420p，yuv420sp，nv21，nv12，yv12，yu12，I420\n//为什么yuv444，yuv420，yuv422，yuv411都是用的4呢？\n-->因为用到了共享的思想，这是yuv和rgb的本质区别.\nrgb是一个像素是一个家庭，家庭成员是r，g，b，但是yuv是若干像素是一个家庭，不同像素的y共享同一个u和v，这样，引入了共享的思想，虽然最小单位是一个字节，但实际上描述一个像素点的字节，不一定是字节的整数倍\n```\n\n### 2）采样格式\n\n#### YUV 444\n\nYUV三个信道的信号全采样，每个像素的三个分量信息完整（每个分量一般用8bit），因此每个像素经量化后，未经压缩，占用3字节。\n\n```c\n[yuv][yuv][yuv][yuv]\n[yuv][yuv][yuv][yuv]\n[yuv][yuv][yuv][yuv]\n[yuv][yuv][yuv][yuv]\n//一个家庭成员是[yuv]，每个Y对应一组UV，一个YUV占24bits 3个字节；\n\n//假设四个像素为:\t[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]\n//存放的码流为:\tY0 U0 V0 Y1 U1 V1Y2 U2 V2Y3 U3 V3\n```\n\n\n\n#### YUV 422\n\n亮度Y分量保持不变；对UV分量进行采样，数据量减小一半。\n\n```c\n[yu][yv][yu][yv]\n[yv][yu][yv][yu]\n[yu][yv][yu][yv]\n[yv][yu][yv][yu]\n//一个家庭成员是[yu] [yv]，也就是2个Y公用一个UV，一个YUV占8+4+4=16bits 2个节。\n\n//假设四个像素为:[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]\n//采样码流为：[Y0 U0 ] [Y1 V1] [Y2 U2 ] [Y3 V3]\n```\n\n隔行扫描，行1出U分量，那么下一行行2则出V分量（即UV分量按照1:1的比例进行采样），最终相邻两个Y分量共用一组UV分量。\n\n#### YUV 420\n\n亮度Y分量保持不变；对UV分量进行采样，数据量只有1/4\n\n``` c\n//吐槽:yuv420的意思似乎是在yuv422的基础上，再拿掉两个v，这样不就没有v了吗？其实yuv420的取名方式不是很高明，更确切的命名为yuv420yuv402也就是第一行只有两个u，而第二行只有两个v，如下图；\n```\n\n```c\n[yu][y][yu][y]\n[yv][y][yv][y]\n[yu][y][yu][y]\n[yv][y][yv][y]\n//一个家庭成员是[yu][y],4个Y公用一组UV，每个YUV占用8+2+2=12bits，1.5个字节；\n//\t\t\t  [yv][y]\n//假设八个像素为:[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]\n//\t\t\t   [Y5 U5 V5] [Y6 U6 V6] [Y7 U7 V7] [Y8 U8 V8]\n//采样码流为：[Y0 U0 ] [Y1 ] [Y2 U2 ] [Y3 ]\n//\t\t\t[Y5 V5] [Y6 ] [Y7 V7] [Y8 ]\n//存放的码流为:\n//\t\t\t[Y0 U0 V5] [Y1 U0 V5] [Y2 U2 V7] [Y3 U2 V7]\n//\t\t\t[Y5 U0 V5] [Y6 U0 V5] [Y7 U2 V7] [Y8 U2 V7]\n```\n\n隔行扫描，且UV分量按照2:1的比例进行采样，第一个像素保留一半U/(V)数据，相邻第二个像素U和V分量全舍弃，第三个像素采集第二次U/(V)数据，第四个像素U和V分量全舍弃，第五个像素采集第一次V/(U)，最终相邻四个Y分量共用一组UV分量，而且是按照 2*2 的小方格的形式分布。\n\n#### 图示：\n\n![](3.png)\n\n黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量。\n\t\tYUV 4:4:4采样，每一个Y对应一组UV分量。\n\t\tYUV 4:2:2采样，每两个Y共用一组UV分量。\n\t\tYUV 4:2:0采样，每四个Y共用一组UV分量，如图中的红色部分。\n\n### 3)图像大小计算\n\n假设一幅图像，像素大小为1280*720\n\nYUV 4:4:4采样，(1280 * 720 * 3) / 1024 / 1024 ≈2.64M\n\nYUV 4:2:2采样，(1280 * 720 * 2) / 1024 / 1024 ≈1.76M\n\nYUV 4:2:0采样，(1280 * 720 * 3 / 2) / 1024 / 1024 ≈1.32M\n\n### 4）存储格式\n\n#### planar\n\n平面格式：指连续存储所有像素点的Y分量，然后存储U分量，最后是V分量，3个plane。\n\n#### packed \n\n打包模式：指每个像素点的Y、U、V分量是连续交叉存储的，1个plane。\n\n#### semi-planar:\n\nY连续存储，U、V交叉存储，如NV21、NV12，即2个plane。\n\n#### 图示：\n\n| YUV444 | YUV422         | YUV420         | YUV411 |\n| ------ | -------------- | -------------- | ------ |\n|        | YU16(YUV422P)  | YU12(YUV420P)  |        |\n|        | YV16(YUV422P)  | YV12(YUV420P)  |        |\n|        | NV16(YUV422SP) | NV12(YUV420SP) |        |\n|        | NV61(YUV422SP) | NV21(YUV420SP) |        |\n|        | YUYV422        |                |        |\n|        | UYVY           |                |        |\n\n# 二、图像格式介绍\n\n## 1.RGB\n\n### 1.RGB555(高彩色)\n\n​    RGB555是一种16位的RGB格式，R、G、B分量都用5位来表示，剩下的一位不用，存储格式如下图：\n\n![](4.png)\n\n```c\n//假设计算机中存储某一个像素点的变量为color, 数据类型为short.，那么则有：\n\nR = color & 0x7C00, (获取高字节的5个bit)\nG = color & 0x03E0, (获取中间5个bit)\nB = color & 0x001F, (获取低字节5个bit)\n```\n\n### 2.RGB565(高彩色)\n\n   RGB565同样是一种16位的RGB格式，R和B分量用5位来表示，G分量用6位标志。存储格式如下图：\n\n![](5.png)\n\n```c\n//假设计算机中存储某一个像素点的变量为color, 数据类型为short， 那么则有：\n\nR = color & 0xF800, (获取高字节的5个bit)\nG = color & 0x07E0, (获取中间6个bit)\nB = color & 0x001F, (获取低字节5个bit)\n```\n\n### 3.RGB24(真彩色)\n\nRGB24是一种24位的RGB格式，R、G、B分量都用8位来表示，每位取值范围都为0-255。存储格式如下图：\n\n![](6.png)\n\n```c\n//假设计算机中存储某一个像素点的变量为color, 数据类型为int， 那么则有：\n    \nR = color & 0x000000FF,\nG = color & 0x0000FF00,\nB = color & 0x00FF0000,\n```\n\n### 4.RGB32(真彩色)\n\n  RGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha通道或者不用。Alpha通道是一个8位的灰度通道，该通道用256级灰度来记录图像中的透明度信息，定义透明、不透明和半透明区域，其中白表示不透明，黑表示透明，灰表示半透明。其结构如下：\n\n![](7.png)\n\n```c\n//假设计算机中存储某一个像素点的变量为color, 数据类型为int，那么则有:\na、低8位保留\nR = color & 0x0000FF00\nG = color & 0x00FF0000,\nB = color & 0xFF000000,\nb、低8位为ALPHA值\nR = color & 0x0000FF00,\nG = color & 0x00FF0000,\nB = color & 0xFF000000,\nA = color & 0x000000FF,\n```\n\n\n\n## 2.YUV\n\n### 1.YUV420SP\n\n#### 1.NV12 \n\nNV21图像格式属于 YUV颜色空间中的YUV420SP格式，每四个Y分量共用一组U分量和V分量，Y连续排序，U与V交叉排序。\n\n```c\n//排列方式如：\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\n\nV U   V U   V U  V U\nV U   V U   V U  V U\n```\n\n####  2.NV21\n\nNV12图像格式属于 YUV颜色空间中的YUV420SP格式，每四个Y分量共用一组U分量和V分量，Y连续排序，U与V交叉排序（NV12和NV21只是U与V的位置相反）。\n\n```c\n//排列方式如：\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\n\nU V   U V   U V  U V\nU V   U V   U V  U V\n```\n\n```c\n//NV12: YYYYYYYY UVUV =>YUV420SP\n//NV21: YYYYYYYY VUVU =>YUV420SP\n```\n\n### 2.YUV420P\n\n#### 1.YU12\n\nYU12图像格式属于 YUV颜色空间中的YUV420P格式，每四个Y分量共用一组U分量和V分量，Y、U、V各自连续排序。\n\n```c\n//排列方式如：\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\n\nU     U     U     U\nU     U     U     U\n\nV     V     V     V\nV     V     V     V\n```\n\n#### 2.YV12\n\nYV12图像格式属于 YUV颜色空间中的YUV420P格式，每四个Y分量共用一组U分量和V分量，Y、U、V各自连续排序（YV12和I420只是U与V的位置相反）。\n\n```c\n//排列方式如：\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\nY Y   Y Y   Y Y   Y Y\n\nV     V     V     V\nV     V     V     V\n\nU     U     U     U\nU     U     U     U\n```\n\n```c\n//YU12: YYYYYYYY UU VV =>YUV420P\n//YV12: YYYYYYYY VV UU =>YUV420P\n```\n\n### 3．YUYV图像格式（打包格式存储）\n\nYUYV图像格式属于 YUV颜色空间中的YUV422格式，每两个Y分量共用一组U分量和V分量，Y、U、V交叉排序。\n\n```c\n//排列方式如：\nY U Y V   Y U Y V   Y U Y V   Y U Y V\n\nY U Y V   Y U Y V   Y U Y V   Y U Y V\n\nY U Y V   Y U Y V   Y U Y V   Y U Y V\n\nY U Y V   Y U Y V   Y U Y V   Y U Y V\n```\n\n\n\n# 三、RGB与YUV的格式转换\n\n图像显示器——通过RGB模型显示图像\n\n传输图像数据——通过YUV模型传输 （YUV 模型可以节省带宽）\n\n![](8.png)\n\n## 转换公式：\n\n1.小数形式, YUV  ( U∈[-0.5-0.5] ,  R，G，B∈[0,1] )\n\n```c\nY =  0.299*R + 0.587*G + 0.114*B;\nU = -0.169*R - 0.331*G + 0.5  *B ;\nV =  0.5  *R - 0.419*G - 0.081*B;\n```\n\n```c\nR = Y + 1.4075 * V;  \nG = Y - 0.3455 * U - 0.7169*V;  \nB = Y + 1.779 * U; \n```\n\n# 四：一图看RGB与YUV\n\n## RGB格式\n\n ![](9.jpg)\n\n## YUV格式\n\n![](10.jpg)\n\n## YUV存储格式\n\n![](11.jpg)\n\n## ARGB\n\n![](12.jpg)\n\n...\n\n...","slug":"2-YUV&RGB","published":1,"updated":"2023-04-13T04:59:18.240Z","_id":"clgeng1v90000vwobec6993p8","layout":"post","photos":[],"link":"","content":"<div align = \"center\">图像格式之 YUV & RGB</div>\n\n<h1 id=\"一、图像颜色空间介绍\"><a href=\"#一、图像颜色空间介绍\" class=\"headerlink\" title=\"一、图像颜色空间介绍\"></a>一、图像颜色空间介绍</h1><h2 id=\"1-RGB\"><a href=\"#1-RGB\" class=\"headerlink\" title=\"1.RGB\"></a>1.RGB</h2><p>采样与编码格式</p>\n<p>R、G、B分别代表red、green、blue，三原色。将他们按照不同比例叠加，可得到更多不同颜色。</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/1.png\"></p>\n<p>每个像素点的颜色由R、G、B三原色表示。每一个颜色通道（原色）包含2^8&#x3D; 256种不同的红&#x2F;绿&#x2F;蓝（八位二进制），占用8bit，也就是一字节，那么一个像素点也就占用了3字节。</p>\n<span id=\"more\"></span>\n\n<p>图片大小计算：一张 1280 * 720 大小的图片，就占用 1280 * 720 * 3 &#x2F; 1024 &#x2F; 1024 &#x3D; 2.63 MB 存储空间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//RGB常见的的几种格式和描述：</span></span><br><span class=\"line\">RGB565 每个像素用<span class=\"number\">16</span>位表示，RGB分量各使用<span class=\"number\">5</span>位、<span class=\"number\">6</span>位、<span class=\"number\">5</span>位；</span><br><span class=\"line\">RGB555 每个像素用<span class=\"number\">16</span>位表示，RGB分量都使用<span class=\"number\">5</span>位（剩下<span class=\"number\">1</span>位不用）；</span><br><span class=\"line\">RGB24 每个像素用<span class=\"number\">24</span>位表示，RGB分量各使用<span class=\"number\">8</span>位；</span><br><span class=\"line\">RGB32 每个像素用<span class=\"number\">32</span>位表示，RGB分量各使用<span class=\"number\">8</span>位（剩下<span class=\"number\">8</span>位不用）；</span><br><span class=\"line\">ARGB32 每个像素用<span class=\"number\">32</span>位表示，RGB分量各使用<span class=\"number\">8</span>位（剩下的<span class=\"number\">8</span>位用于表示Alpha(透明度)通道值）；</span><br></pre></td></tr></table></figure>\n\n<p>常见的RGB格式有：RGB_565、RGB_888、ARGB_8888、ARGB_4444等。但是也有列外，尤其是搞安卓的同学要特别注意，谷歌在这里给我们挖了一个坑，那就是，ARGB_8888和ARGB_4444实际上在底层对应的是 RGBA_8888和RGBA_4444，例如ARGB_8888图像，其像素数据在内存中其实是以R G B A R G B A …的顺序排布的。</p>\n<h2 id=\"2-YUV\"><a href=\"#2-YUV\" class=\"headerlink\" title=\"2.YUV\"></a>2.YUV</h2><p>简介：与我们熟知的RGB类似，YUV也是一种颜色编码方法；主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，</p>\n<p>这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p>\n<h3 id=\"1）颜色空间\"><a href=\"#1）颜色空间\" class=\"headerlink\" title=\"1）颜色空间\"></a>1）颜色空间</h3><p>在YUV颜色空间中，YUV（YCbCr ）格式也包含三个分量：<br>        Y——明亮度（Luma），也成灰阶，没有UV分量也可成像，图像是黑白的（基础信号）<br>        UV——色度（Chroma）：色彩+色彩饱和度（正交调制信号）</p>\n<p>每个 Y 分量可以都有自己对应的 UV 分量，也可以几个 Y 分量共用 UV 分量，这就是为何会有YUV4:4:4、YUV4:2:2、YUV4:2:0采样格式出现，用于减小图像包含的数据量大小，便于传输和存储。</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/2.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//YUV种类分为很多，可以理解是一个二维的，即空间间，和空间内，这样的表述，借鉴了h264中的帧间和帧内的思想。</span></span><br><span class=\"line\">空间-间：不同空间，即描述一个像素的bit数不同，比如yuv444，yuv422，yuv411，yuv420</span><br><span class=\"line\">空间-内：相同空间，即描述一个像素的bit数相同，但是存储方式不同，比如对于yuv420而言，又可细分为yuv420p，yuv420sp，nv21，nv12，yv12，yu12，I420</span><br><span class=\"line\"><span class=\"comment\">//为什么yuv444，yuv420，yuv422，yuv411都是用的4呢？</span></span><br><span class=\"line\">--&gt;因为用到了共享的思想，这是yuv和rgb的本质区别.</span><br><span class=\"line\">rgb是一个像素是一个家庭，家庭成员是r，g，b，但是yuv是若干像素是一个家庭，不同像素的y共享同一个u和v，这样，引入了共享的思想，虽然最小单位是一个字节，但实际上描述一个像素点的字节，不一定是字节的整数倍</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）采样格式\"><a href=\"#2）采样格式\" class=\"headerlink\" title=\"2）采样格式\"></a>2）采样格式</h3><h4 id=\"YUV-444\"><a href=\"#YUV-444\" class=\"headerlink\" title=\"YUV 444\"></a>YUV 444</h4><p>YUV三个信道的信号全采样，每个像素的三个分量信息完整（每个分量一般用8bit），因此每个像素经量化后，未经压缩，占用3字节。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[yuv][yuv][yuv][yuv]</span><br><span class=\"line\">[yuv][yuv][yuv][yuv]</span><br><span class=\"line\">[yuv][yuv][yuv][yuv]</span><br><span class=\"line\">[yuv][yuv][yuv][yuv]</span><br><span class=\"line\"><span class=\"comment\">//一个家庭成员是[yuv]，每个Y对应一组UV，一个YUV占24bits 3个字节；</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//假设四个像素为:\t[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]</span></span><br><span class=\"line\"><span class=\"comment\">//存放的码流为:\tY0 U0 V0 Y1 U1 V1Y2 U2 V2Y3 U3 V3</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"YUV-422\"><a href=\"#YUV-422\" class=\"headerlink\" title=\"YUV 422\"></a>YUV 422</h4><p>亮度Y分量保持不变；对UV分量进行采样，数据量减小一半。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[yu][yv][yu][yv]</span><br><span class=\"line\">[yv][yu][yv][yu]</span><br><span class=\"line\">[yu][yv][yu][yv]</span><br><span class=\"line\">[yv][yu][yv][yu]</span><br><span class=\"line\"><span class=\"comment\">//一个家庭成员是[yu] [yv]，也就是2个Y公用一个UV，一个YUV占8+4+4=16bits 2个节。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//假设四个像素为:[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]</span></span><br><span class=\"line\"><span class=\"comment\">//采样码流为：[Y0 U0 ] [Y1 V1] [Y2 U2 ] [Y3 V3]</span></span><br></pre></td></tr></table></figure>\n\n<p>隔行扫描，行1出U分量，那么下一行行2则出V分量（即UV分量按照1:1的比例进行采样），最终相邻两个Y分量共用一组UV分量。</p>\n<h4 id=\"YUV-420\"><a href=\"#YUV-420\" class=\"headerlink\" title=\"YUV 420\"></a>YUV 420</h4><p>亮度Y分量保持不变；对UV分量进行采样，数据量只有1&#x2F;4</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//吐槽:yuv420的意思似乎是在yuv422的基础上，再拿掉两个v，这样不就没有v了吗？其实yuv420的取名方式不是很高明，更确切的命名为yuv420yuv402也就是第一行只有两个u，而第二行只有两个v，如下图；</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[yu][y][yu][y]</span><br><span class=\"line\">[yv][y][yv][y]</span><br><span class=\"line\">[yu][y][yu][y]</span><br><span class=\"line\">[yv][y][yv][y]</span><br><span class=\"line\"><span class=\"comment\">//一个家庭成员是[yu][y],4个Y公用一组UV，每个YUV占用8+2+2=12bits，1.5个字节；</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t  [yv][y]</span></span><br><span class=\"line\"><span class=\"comment\">//假设八个像素为:[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t   [Y5 U5 V5] [Y6 U6 V6] [Y7 U7 V7] [Y8 U8 V8]</span></span><br><span class=\"line\"><span class=\"comment\">//采样码流为：[Y0 U0 ] [Y1 ] [Y2 U2 ] [Y3 ]</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t[Y5 V5] [Y6 ] [Y7 V7] [Y8 ]</span></span><br><span class=\"line\"><span class=\"comment\">//存放的码流为:</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t[Y0 U0 V5] [Y1 U0 V5] [Y2 U2 V7] [Y3 U2 V7]</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t[Y5 U0 V5] [Y6 U0 V5] [Y7 U2 V7] [Y8 U2 V7]</span></span><br></pre></td></tr></table></figure>\n\n<p>隔行扫描，且UV分量按照2:1的比例进行采样，第一个像素保留一半U&#x2F;(V)数据，相邻第二个像素U和V分量全舍弃，第三个像素采集第二次U&#x2F;(V)数据，第四个像素U和V分量全舍弃，第五个像素采集第一次V&#x2F;(U)，最终相邻四个Y分量共用一组UV分量，而且是按照 2*2 的小方格的形式分布。</p>\n<h4 id=\"图示：\"><a href=\"#图示：\" class=\"headerlink\" title=\"图示：\"></a>图示：</h4><p><img src=\"/2023/04/13/2-YUV&RGB/3.png\"></p>\n<p>黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量。<br>        YUV 4:4:4采样，每一个Y对应一组UV分量。<br>        YUV 4:2:2采样，每两个Y共用一组UV分量。<br>        YUV 4:2:0采样，每四个Y共用一组UV分量，如图中的红色部分。</p>\n<h3 id=\"3-图像大小计算\"><a href=\"#3-图像大小计算\" class=\"headerlink\" title=\"3)图像大小计算\"></a>3)图像大小计算</h3><p>假设一幅图像，像素大小为1280*720</p>\n<p>YUV 4:4:4采样，(1280 * 720 * 3) &#x2F; 1024 &#x2F; 1024 ≈2.64M</p>\n<p>YUV 4:2:2采样，(1280 * 720 * 2) &#x2F; 1024 &#x2F; 1024 ≈1.76M</p>\n<p>YUV 4:2:0采样，(1280 * 720 * 3 &#x2F; 2) &#x2F; 1024 &#x2F; 1024 ≈1.32M</p>\n<h3 id=\"4）存储格式\"><a href=\"#4）存储格式\" class=\"headerlink\" title=\"4）存储格式\"></a>4）存储格式</h3><h4 id=\"planar\"><a href=\"#planar\" class=\"headerlink\" title=\"planar\"></a>planar</h4><p>平面格式：指连续存储所有像素点的Y分量，然后存储U分量，最后是V分量，3个plane。</p>\n<h4 id=\"packed\"><a href=\"#packed\" class=\"headerlink\" title=\"packed\"></a>packed</h4><p>打包模式：指每个像素点的Y、U、V分量是连续交叉存储的，1个plane。</p>\n<h4 id=\"semi-planar\"><a href=\"#semi-planar\" class=\"headerlink\" title=\"semi-planar:\"></a>semi-planar:</h4><p>Y连续存储，U、V交叉存储，如NV21、NV12，即2个plane。</p>\n<h4 id=\"图示：-1\"><a href=\"#图示：-1\" class=\"headerlink\" title=\"图示：\"></a>图示：</h4><table>\n<thead>\n<tr>\n<th>YUV444</th>\n<th>YUV422</th>\n<th>YUV420</th>\n<th>YUV411</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>YU16(YUV422P)</td>\n<td>YU12(YUV420P)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>YV16(YUV422P)</td>\n<td>YV12(YUV420P)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>NV16(YUV422SP)</td>\n<td>NV12(YUV420SP)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>NV61(YUV422SP)</td>\n<td>NV21(YUV420SP)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>YUYV422</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>UYVY</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"二、图像格式介绍\"><a href=\"#二、图像格式介绍\" class=\"headerlink\" title=\"二、图像格式介绍\"></a>二、图像格式介绍</h1><h2 id=\"1-RGB-1\"><a href=\"#1-RGB-1\" class=\"headerlink\" title=\"1.RGB\"></a>1.RGB</h2><h3 id=\"1-RGB555-高彩色\"><a href=\"#1-RGB555-高彩色\" class=\"headerlink\" title=\"1.RGB555(高彩色)\"></a>1.RGB555(高彩色)</h3><p>​    RGB555是一种16位的RGB格式，R、G、B分量都用5位来表示，剩下的一位不用，存储格式如下图：</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/4.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设计算机中存储某一个像素点的变量为color, 数据类型为short.，那么则有：</span></span><br><span class=\"line\"></span><br><span class=\"line\">R = color &amp; <span class=\"number\">0x7C00</span>, (获取高字节的<span class=\"number\">5</span>个bit)</span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x03E0</span>, (获取中间<span class=\"number\">5</span>个bit)</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0x001F</span>, (获取低字节<span class=\"number\">5</span>个bit)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-RGB565-高彩色\"><a href=\"#2-RGB565-高彩色\" class=\"headerlink\" title=\"2.RGB565(高彩色)\"></a>2.RGB565(高彩色)</h3><p>   RGB565同样是一种16位的RGB格式，R和B分量用5位来表示，G分量用6位标志。存储格式如下图：</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/5.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设计算机中存储某一个像素点的变量为color, 数据类型为short， 那么则有：</span></span><br><span class=\"line\"></span><br><span class=\"line\">R = color &amp; <span class=\"number\">0xF800</span>, (获取高字节的<span class=\"number\">5</span>个bit)</span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x07E0</span>, (获取中间<span class=\"number\">6</span>个bit)</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0x001F</span>, (获取低字节<span class=\"number\">5</span>个bit)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-RGB24-真彩色\"><a href=\"#3-RGB24-真彩色\" class=\"headerlink\" title=\"3.RGB24(真彩色)\"></a>3.RGB24(真彩色)</h3><p>RGB24是一种24位的RGB格式，R、G、B分量都用8位来表示，每位取值范围都为0-255。存储格式如下图：</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/6.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设计算机中存储某一个像素点的变量为color, 数据类型为int， 那么则有：</span></span><br><span class=\"line\">    </span><br><span class=\"line\">R = color &amp; <span class=\"number\">0x000000FF</span>,</span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x0000FF00</span>,</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0x00FF0000</span>,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-RGB32-真彩色\"><a href=\"#4-RGB32-真彩色\" class=\"headerlink\" title=\"4.RGB32(真彩色)\"></a>4.RGB32(真彩色)</h3><p>  RGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha通道或者不用。Alpha通道是一个8位的灰度通道，该通道用256级灰度来记录图像中的透明度信息，定义透明、不透明和半透明区域，其中白表示不透明，黑表示透明，灰表示半透明。其结构如下：</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/7.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设计算机中存储某一个像素点的变量为color, 数据类型为int，那么则有:</span></span><br><span class=\"line\">a、低<span class=\"number\">8</span>位保留</span><br><span class=\"line\">R = color &amp; <span class=\"number\">0x0000FF00</span></span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x00FF0000</span>,</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0xFF000000</span>,</span><br><span class=\"line\">b、低<span class=\"number\">8</span>位为ALPHA值</span><br><span class=\"line\">R = color &amp; <span class=\"number\">0x0000FF00</span>,</span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x00FF0000</span>,</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0xFF000000</span>,</span><br><span class=\"line\">A = color &amp; <span class=\"number\">0x000000FF</span>,</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-YUV-1\"><a href=\"#2-YUV-1\" class=\"headerlink\" title=\"2.YUV\"></a>2.YUV</h2><h3 id=\"1-YUV420SP\"><a href=\"#1-YUV420SP\" class=\"headerlink\" title=\"1.YUV420SP\"></a>1.YUV420SP</h3><h4 id=\"1-NV12\"><a href=\"#1-NV12\" class=\"headerlink\" title=\"1.NV12\"></a>1.NV12</h4><p>NV21图像格式属于 YUV颜色空间中的YUV420SP格式，每四个Y分量共用一组U分量和V分量，Y连续排序，U与V交叉排序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\"></span><br><span class=\"line\">V U   V U   V U  V U</span><br><span class=\"line\">V U   V U   V U  V U</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-NV21\"><a href=\"#2-NV21\" class=\"headerlink\" title=\"2.NV21\"></a>2.NV21</h4><p>NV12图像格式属于 YUV颜色空间中的YUV420SP格式，每四个Y分量共用一组U分量和V分量，Y连续排序，U与V交叉排序（NV12和NV21只是U与V的位置相反）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\"></span><br><span class=\"line\">U V   U V   U V  U V</span><br><span class=\"line\">U V   U V   U V  U V</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NV12: YYYYYYYY UVUV =&gt;YUV420SP</span></span><br><span class=\"line\"><span class=\"comment\">//NV21: YYYYYYYY VUVU =&gt;YUV420SP</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-YUV420P\"><a href=\"#2-YUV420P\" class=\"headerlink\" title=\"2.YUV420P\"></a>2.YUV420P</h3><h4 id=\"1-YU12\"><a href=\"#1-YU12\" class=\"headerlink\" title=\"1.YU12\"></a>1.YU12</h4><p>YU12图像格式属于 YUV颜色空间中的YUV420P格式，每四个Y分量共用一组U分量和V分量，Y、U、V各自连续排序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\"></span><br><span class=\"line\">U     U     U     U</span><br><span class=\"line\">U     U     U     U</span><br><span class=\"line\"></span><br><span class=\"line\">V     V     V     V</span><br><span class=\"line\">V     V     V     V</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-YV12\"><a href=\"#2-YV12\" class=\"headerlink\" title=\"2.YV12\"></a>2.YV12</h4><p>YV12图像格式属于 YUV颜色空间中的YUV420P格式，每四个Y分量共用一组U分量和V分量，Y、U、V各自连续排序（YV12和I420只是U与V的位置相反）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\"></span><br><span class=\"line\">V     V     V     V</span><br><span class=\"line\">V     V     V     V</span><br><span class=\"line\"></span><br><span class=\"line\">U     U     U     U</span><br><span class=\"line\">U     U     U     U</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//YU12: YYYYYYYY UU VV =&gt;YUV420P</span></span><br><span class=\"line\"><span class=\"comment\">//YV12: YYYYYYYY VV UU =&gt;YUV420P</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3．YUYV图像格式（打包格式存储）\"><a href=\"#3．YUYV图像格式（打包格式存储）\" class=\"headerlink\" title=\"3．YUYV图像格式（打包格式存储）\"></a>3．YUYV图像格式（打包格式存储）</h3><p>YUYV图像格式属于 YUV颜色空间中的YUV422格式，每两个Y分量共用一组U分量和V分量，Y、U、V交叉排序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y U Y V   Y U Y V   Y U Y V   Y U Y V</span><br><span class=\"line\"></span><br><span class=\"line\">Y U Y V   Y U Y V   Y U Y V   Y U Y V</span><br><span class=\"line\"></span><br><span class=\"line\">Y U Y V   Y U Y V   Y U Y V   Y U Y V</span><br><span class=\"line\"></span><br><span class=\"line\">Y U Y V   Y U Y V   Y U Y V   Y U Y V</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"三、RGB与YUV的格式转换\"><a href=\"#三、RGB与YUV的格式转换\" class=\"headerlink\" title=\"三、RGB与YUV的格式转换\"></a>三、RGB与YUV的格式转换</h1><p>图像显示器——通过RGB模型显示图像</p>\n<p>传输图像数据——通过YUV模型传输 （YUV 模型可以节省带宽）</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/8.png\"></p>\n<h2 id=\"转换公式：\"><a href=\"#转换公式：\" class=\"headerlink\" title=\"转换公式：\"></a>转换公式：</h2><p>1.小数形式, YUV  ( U∈[-0.5-0.5] ,  R，G，B∈[0,1] )</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y =  <span class=\"number\">0.299</span>*R + <span class=\"number\">0.587</span>*G + <span class=\"number\">0.114</span>*B;</span><br><span class=\"line\">U = <span class=\"number\">-0.169</span>*R - <span class=\"number\">0.331</span>*G + <span class=\"number\">0.5</span>  *B ;</span><br><span class=\"line\">V =  <span class=\"number\">0.5</span>  *R - <span class=\"number\">0.419</span>*G - <span class=\"number\">0.081</span>*B;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R = Y + <span class=\"number\">1.4075</span> * V;  </span><br><span class=\"line\">G = Y - <span class=\"number\">0.3455</span> * U - <span class=\"number\">0.7169</span>*V;  </span><br><span class=\"line\">B = Y + <span class=\"number\">1.779</span> * U; </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四：一图看RGB与YUV\"><a href=\"#四：一图看RGB与YUV\" class=\"headerlink\" title=\"四：一图看RGB与YUV\"></a>四：一图看RGB与YUV</h1><h2 id=\"RGB格式\"><a href=\"#RGB格式\" class=\"headerlink\" title=\"RGB格式\"></a>RGB格式</h2><p> <img src=\"/2023/04/13/2-YUV&RGB/9.jpg\"></p>\n<h2 id=\"YUV格式\"><a href=\"#YUV格式\" class=\"headerlink\" title=\"YUV格式\"></a>YUV格式</h2><p><img src=\"/2023/04/13/2-YUV&RGB/10.jpg\"></p>\n<h2 id=\"YUV存储格式\"><a href=\"#YUV存储格式\" class=\"headerlink\" title=\"YUV存储格式\"></a>YUV存储格式</h2><p><img src=\"/2023/04/13/2-YUV&RGB/11.jpg\"></p>\n<h2 id=\"ARGB\"><a href=\"#ARGB\" class=\"headerlink\" title=\"ARGB\"></a>ARGB</h2><p><img src=\"/2023/04/13/2-YUV&RGB/12.jpg\"></p>\n<p>…</p>\n<p>…</p>\n","site":{"data":{"style":""}},"length":5340,"excerpt":"<div align = \"center\">图像格式之 YUV & RGB</div>\n\n<h1 id=\"一、图像颜色空间介绍\"><a href=\"#一、图像颜色空间介绍\" class=\"headerlink\" title=\"一、图像颜色空间介绍\"></a>一、图像颜色空间介绍</h1><h2 id=\"1-RGB\"><a href=\"#1-RGB\" class=\"headerlink\" title=\"1.RGB\"></a>1.RGB</h2><p>采样与编码格式</p>\n<p>R、G、B分别代表red、green、blue，三原色。将他们按照不同比例叠加，可得到更多不同颜色。</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/1.png\"></p>\n<p>每个像素点的颜色由R、G、B三原色表示。每一个颜色通道（原色）包含2^8&#x3D; 256种不同的红&#x2F;绿&#x2F;蓝（八位二进制），占用8bit，也就是一字节，那么一个像素点也就占用了3字节。</p>","more":"<p>图片大小计算：一张 1280 * 720 大小的图片，就占用 1280 * 720 * 3 &#x2F; 1024 &#x2F; 1024 &#x3D; 2.63 MB 存储空间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//RGB常见的的几种格式和描述：</span></span><br><span class=\"line\">RGB565 每个像素用<span class=\"number\">16</span>位表示，RGB分量各使用<span class=\"number\">5</span>位、<span class=\"number\">6</span>位、<span class=\"number\">5</span>位；</span><br><span class=\"line\">RGB555 每个像素用<span class=\"number\">16</span>位表示，RGB分量都使用<span class=\"number\">5</span>位（剩下<span class=\"number\">1</span>位不用）；</span><br><span class=\"line\">RGB24 每个像素用<span class=\"number\">24</span>位表示，RGB分量各使用<span class=\"number\">8</span>位；</span><br><span class=\"line\">RGB32 每个像素用<span class=\"number\">32</span>位表示，RGB分量各使用<span class=\"number\">8</span>位（剩下<span class=\"number\">8</span>位不用）；</span><br><span class=\"line\">ARGB32 每个像素用<span class=\"number\">32</span>位表示，RGB分量各使用<span class=\"number\">8</span>位（剩下的<span class=\"number\">8</span>位用于表示Alpha(透明度)通道值）；</span><br></pre></td></tr></table></figure>\n\n<p>常见的RGB格式有：RGB_565、RGB_888、ARGB_8888、ARGB_4444等。但是也有列外，尤其是搞安卓的同学要特别注意，谷歌在这里给我们挖了一个坑，那就是，ARGB_8888和ARGB_4444实际上在底层对应的是 RGBA_8888和RGBA_4444，例如ARGB_8888图像，其像素数据在内存中其实是以R G B A R G B A …的顺序排布的。</p>\n<h2 id=\"2-YUV\"><a href=\"#2-YUV\" class=\"headerlink\" title=\"2.YUV\"></a>2.YUV</h2><p>简介：与我们熟知的RGB类似，YUV也是一种颜色编码方法；主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，</p>\n<p>这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p>\n<h3 id=\"1）颜色空间\"><a href=\"#1）颜色空间\" class=\"headerlink\" title=\"1）颜色空间\"></a>1）颜色空间</h3><p>在YUV颜色空间中，YUV（YCbCr ）格式也包含三个分量：<br>        Y——明亮度（Luma），也成灰阶，没有UV分量也可成像，图像是黑白的（基础信号）<br>        UV——色度（Chroma）：色彩+色彩饱和度（正交调制信号）</p>\n<p>每个 Y 分量可以都有自己对应的 UV 分量，也可以几个 Y 分量共用 UV 分量，这就是为何会有YUV4:4:4、YUV4:2:2、YUV4:2:0采样格式出现，用于减小图像包含的数据量大小，便于传输和存储。</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/2.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//YUV种类分为很多，可以理解是一个二维的，即空间间，和空间内，这样的表述，借鉴了h264中的帧间和帧内的思想。</span></span><br><span class=\"line\">空间-间：不同空间，即描述一个像素的bit数不同，比如yuv444，yuv422，yuv411，yuv420</span><br><span class=\"line\">空间-内：相同空间，即描述一个像素的bit数相同，但是存储方式不同，比如对于yuv420而言，又可细分为yuv420p，yuv420sp，nv21，nv12，yv12，yu12，I420</span><br><span class=\"line\"><span class=\"comment\">//为什么yuv444，yuv420，yuv422，yuv411都是用的4呢？</span></span><br><span class=\"line\">--&gt;因为用到了共享的思想，这是yuv和rgb的本质区别.</span><br><span class=\"line\">rgb是一个像素是一个家庭，家庭成员是r，g，b，但是yuv是若干像素是一个家庭，不同像素的y共享同一个u和v，这样，引入了共享的思想，虽然最小单位是一个字节，但实际上描述一个像素点的字节，不一定是字节的整数倍</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2）采样格式\"><a href=\"#2）采样格式\" class=\"headerlink\" title=\"2）采样格式\"></a>2）采样格式</h3><h4 id=\"YUV-444\"><a href=\"#YUV-444\" class=\"headerlink\" title=\"YUV 444\"></a>YUV 444</h4><p>YUV三个信道的信号全采样，每个像素的三个分量信息完整（每个分量一般用8bit），因此每个像素经量化后，未经压缩，占用3字节。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[yuv][yuv][yuv][yuv]</span><br><span class=\"line\">[yuv][yuv][yuv][yuv]</span><br><span class=\"line\">[yuv][yuv][yuv][yuv]</span><br><span class=\"line\">[yuv][yuv][yuv][yuv]</span><br><span class=\"line\"><span class=\"comment\">//一个家庭成员是[yuv]，每个Y对应一组UV，一个YUV占24bits 3个字节；</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//假设四个像素为:\t[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]</span></span><br><span class=\"line\"><span class=\"comment\">//存放的码流为:\tY0 U0 V0 Y1 U1 V1Y2 U2 V2Y3 U3 V3</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"YUV-422\"><a href=\"#YUV-422\" class=\"headerlink\" title=\"YUV 422\"></a>YUV 422</h4><p>亮度Y分量保持不变；对UV分量进行采样，数据量减小一半。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[yu][yv][yu][yv]</span><br><span class=\"line\">[yv][yu][yv][yu]</span><br><span class=\"line\">[yu][yv][yu][yv]</span><br><span class=\"line\">[yv][yu][yv][yu]</span><br><span class=\"line\"><span class=\"comment\">//一个家庭成员是[yu] [yv]，也就是2个Y公用一个UV，一个YUV占8+4+4=16bits 2个节。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//假设四个像素为:[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]</span></span><br><span class=\"line\"><span class=\"comment\">//采样码流为：[Y0 U0 ] [Y1 V1] [Y2 U2 ] [Y3 V3]</span></span><br></pre></td></tr></table></figure>\n\n<p>隔行扫描，行1出U分量，那么下一行行2则出V分量（即UV分量按照1:1的比例进行采样），最终相邻两个Y分量共用一组UV分量。</p>\n<h4 id=\"YUV-420\"><a href=\"#YUV-420\" class=\"headerlink\" title=\"YUV 420\"></a>YUV 420</h4><p>亮度Y分量保持不变；对UV分量进行采样，数据量只有1&#x2F;4</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//吐槽:yuv420的意思似乎是在yuv422的基础上，再拿掉两个v，这样不就没有v了吗？其实yuv420的取名方式不是很高明，更确切的命名为yuv420yuv402也就是第一行只有两个u，而第二行只有两个v，如下图；</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[yu][y][yu][y]</span><br><span class=\"line\">[yv][y][yv][y]</span><br><span class=\"line\">[yu][y][yu][y]</span><br><span class=\"line\">[yv][y][yv][y]</span><br><span class=\"line\"><span class=\"comment\">//一个家庭成员是[yu][y],4个Y公用一组UV，每个YUV占用8+2+2=12bits，1.5个字节；</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t  [yv][y]</span></span><br><span class=\"line\"><span class=\"comment\">//假设八个像素为:[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t   [Y5 U5 V5] [Y6 U6 V6] [Y7 U7 V7] [Y8 U8 V8]</span></span><br><span class=\"line\"><span class=\"comment\">//采样码流为：[Y0 U0 ] [Y1 ] [Y2 U2 ] [Y3 ]</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t[Y5 V5] [Y6 ] [Y7 V7] [Y8 ]</span></span><br><span class=\"line\"><span class=\"comment\">//存放的码流为:</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t[Y0 U0 V5] [Y1 U0 V5] [Y2 U2 V7] [Y3 U2 V7]</span></span><br><span class=\"line\"><span class=\"comment\">//\t\t\t[Y5 U0 V5] [Y6 U0 V5] [Y7 U2 V7] [Y8 U2 V7]</span></span><br></pre></td></tr></table></figure>\n\n<p>隔行扫描，且UV分量按照2:1的比例进行采样，第一个像素保留一半U&#x2F;(V)数据，相邻第二个像素U和V分量全舍弃，第三个像素采集第二次U&#x2F;(V)数据，第四个像素U和V分量全舍弃，第五个像素采集第一次V&#x2F;(U)，最终相邻四个Y分量共用一组UV分量，而且是按照 2*2 的小方格的形式分布。</p>\n<h4 id=\"图示：\"><a href=\"#图示：\" class=\"headerlink\" title=\"图示：\"></a>图示：</h4><p><img src=\"/2023/04/13/2-YUV&RGB/3.png\"></p>\n<p>黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量。<br>        YUV 4:4:4采样，每一个Y对应一组UV分量。<br>        YUV 4:2:2采样，每两个Y共用一组UV分量。<br>        YUV 4:2:0采样，每四个Y共用一组UV分量，如图中的红色部分。</p>\n<h3 id=\"3-图像大小计算\"><a href=\"#3-图像大小计算\" class=\"headerlink\" title=\"3)图像大小计算\"></a>3)图像大小计算</h3><p>假设一幅图像，像素大小为1280*720</p>\n<p>YUV 4:4:4采样，(1280 * 720 * 3) &#x2F; 1024 &#x2F; 1024 ≈2.64M</p>\n<p>YUV 4:2:2采样，(1280 * 720 * 2) &#x2F; 1024 &#x2F; 1024 ≈1.76M</p>\n<p>YUV 4:2:0采样，(1280 * 720 * 3 &#x2F; 2) &#x2F; 1024 &#x2F; 1024 ≈1.32M</p>\n<h3 id=\"4）存储格式\"><a href=\"#4）存储格式\" class=\"headerlink\" title=\"4）存储格式\"></a>4）存储格式</h3><h4 id=\"planar\"><a href=\"#planar\" class=\"headerlink\" title=\"planar\"></a>planar</h4><p>平面格式：指连续存储所有像素点的Y分量，然后存储U分量，最后是V分量，3个plane。</p>\n<h4 id=\"packed\"><a href=\"#packed\" class=\"headerlink\" title=\"packed\"></a>packed</h4><p>打包模式：指每个像素点的Y、U、V分量是连续交叉存储的，1个plane。</p>\n<h4 id=\"semi-planar\"><a href=\"#semi-planar\" class=\"headerlink\" title=\"semi-planar:\"></a>semi-planar:</h4><p>Y连续存储，U、V交叉存储，如NV21、NV12，即2个plane。</p>\n<h4 id=\"图示：-1\"><a href=\"#图示：-1\" class=\"headerlink\" title=\"图示：\"></a>图示：</h4><table>\n<thead>\n<tr>\n<th>YUV444</th>\n<th>YUV422</th>\n<th>YUV420</th>\n<th>YUV411</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>YU16(YUV422P)</td>\n<td>YU12(YUV420P)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>YV16(YUV422P)</td>\n<td>YV12(YUV420P)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>NV16(YUV422SP)</td>\n<td>NV12(YUV420SP)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>NV61(YUV422SP)</td>\n<td>NV21(YUV420SP)</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>YUYV422</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>UYVY</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"二、图像格式介绍\"><a href=\"#二、图像格式介绍\" class=\"headerlink\" title=\"二、图像格式介绍\"></a>二、图像格式介绍</h1><h2 id=\"1-RGB-1\"><a href=\"#1-RGB-1\" class=\"headerlink\" title=\"1.RGB\"></a>1.RGB</h2><h3 id=\"1-RGB555-高彩色\"><a href=\"#1-RGB555-高彩色\" class=\"headerlink\" title=\"1.RGB555(高彩色)\"></a>1.RGB555(高彩色)</h3><p>​    RGB555是一种16位的RGB格式，R、G、B分量都用5位来表示，剩下的一位不用，存储格式如下图：</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/4.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设计算机中存储某一个像素点的变量为color, 数据类型为short.，那么则有：</span></span><br><span class=\"line\"></span><br><span class=\"line\">R = color &amp; <span class=\"number\">0x7C00</span>, (获取高字节的<span class=\"number\">5</span>个bit)</span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x03E0</span>, (获取中间<span class=\"number\">5</span>个bit)</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0x001F</span>, (获取低字节<span class=\"number\">5</span>个bit)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-RGB565-高彩色\"><a href=\"#2-RGB565-高彩色\" class=\"headerlink\" title=\"2.RGB565(高彩色)\"></a>2.RGB565(高彩色)</h3><p>   RGB565同样是一种16位的RGB格式，R和B分量用5位来表示，G分量用6位标志。存储格式如下图：</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/5.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设计算机中存储某一个像素点的变量为color, 数据类型为short， 那么则有：</span></span><br><span class=\"line\"></span><br><span class=\"line\">R = color &amp; <span class=\"number\">0xF800</span>, (获取高字节的<span class=\"number\">5</span>个bit)</span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x07E0</span>, (获取中间<span class=\"number\">6</span>个bit)</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0x001F</span>, (获取低字节<span class=\"number\">5</span>个bit)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-RGB24-真彩色\"><a href=\"#3-RGB24-真彩色\" class=\"headerlink\" title=\"3.RGB24(真彩色)\"></a>3.RGB24(真彩色)</h3><p>RGB24是一种24位的RGB格式，R、G、B分量都用8位来表示，每位取值范围都为0-255。存储格式如下图：</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/6.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设计算机中存储某一个像素点的变量为color, 数据类型为int， 那么则有：</span></span><br><span class=\"line\">    </span><br><span class=\"line\">R = color &amp; <span class=\"number\">0x000000FF</span>,</span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x0000FF00</span>,</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0x00FF0000</span>,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-RGB32-真彩色\"><a href=\"#4-RGB32-真彩色\" class=\"headerlink\" title=\"4.RGB32(真彩色)\"></a>4.RGB32(真彩色)</h3><p>  RGB32使用32位来表示一个像素，RGB分量各用去8位，剩下的8位用作Alpha通道或者不用。Alpha通道是一个8位的灰度通道，该通道用256级灰度来记录图像中的透明度信息，定义透明、不透明和半透明区域，其中白表示不透明，黑表示透明，灰表示半透明。其结构如下：</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/7.png\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//假设计算机中存储某一个像素点的变量为color, 数据类型为int，那么则有:</span></span><br><span class=\"line\">a、低<span class=\"number\">8</span>位保留</span><br><span class=\"line\">R = color &amp; <span class=\"number\">0x0000FF00</span></span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x00FF0000</span>,</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0xFF000000</span>,</span><br><span class=\"line\">b、低<span class=\"number\">8</span>位为ALPHA值</span><br><span class=\"line\">R = color &amp; <span class=\"number\">0x0000FF00</span>,</span><br><span class=\"line\">G = color &amp; <span class=\"number\">0x00FF0000</span>,</span><br><span class=\"line\">B = color &amp; <span class=\"number\">0xFF000000</span>,</span><br><span class=\"line\">A = color &amp; <span class=\"number\">0x000000FF</span>,</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-YUV-1\"><a href=\"#2-YUV-1\" class=\"headerlink\" title=\"2.YUV\"></a>2.YUV</h2><h3 id=\"1-YUV420SP\"><a href=\"#1-YUV420SP\" class=\"headerlink\" title=\"1.YUV420SP\"></a>1.YUV420SP</h3><h4 id=\"1-NV12\"><a href=\"#1-NV12\" class=\"headerlink\" title=\"1.NV12\"></a>1.NV12</h4><p>NV21图像格式属于 YUV颜色空间中的YUV420SP格式，每四个Y分量共用一组U分量和V分量，Y连续排序，U与V交叉排序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\"></span><br><span class=\"line\">V U   V U   V U  V U</span><br><span class=\"line\">V U   V U   V U  V U</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-NV21\"><a href=\"#2-NV21\" class=\"headerlink\" title=\"2.NV21\"></a>2.NV21</h4><p>NV12图像格式属于 YUV颜色空间中的YUV420SP格式，每四个Y分量共用一组U分量和V分量，Y连续排序，U与V交叉排序（NV12和NV21只是U与V的位置相反）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\"></span><br><span class=\"line\">U V   U V   U V  U V</span><br><span class=\"line\">U V   U V   U V  U V</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//NV12: YYYYYYYY UVUV =&gt;YUV420SP</span></span><br><span class=\"line\"><span class=\"comment\">//NV21: YYYYYYYY VUVU =&gt;YUV420SP</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-YUV420P\"><a href=\"#2-YUV420P\" class=\"headerlink\" title=\"2.YUV420P\"></a>2.YUV420P</h3><h4 id=\"1-YU12\"><a href=\"#1-YU12\" class=\"headerlink\" title=\"1.YU12\"></a>1.YU12</h4><p>YU12图像格式属于 YUV颜色空间中的YUV420P格式，每四个Y分量共用一组U分量和V分量，Y、U、V各自连续排序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\"></span><br><span class=\"line\">U     U     U     U</span><br><span class=\"line\">U     U     U     U</span><br><span class=\"line\"></span><br><span class=\"line\">V     V     V     V</span><br><span class=\"line\">V     V     V     V</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-YV12\"><a href=\"#2-YV12\" class=\"headerlink\" title=\"2.YV12\"></a>2.YV12</h4><p>YV12图像格式属于 YUV颜色空间中的YUV420P格式，每四个Y分量共用一组U分量和V分量，Y、U、V各自连续排序（YV12和I420只是U与V的位置相反）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\">Y Y   Y Y   Y Y   Y Y</span><br><span class=\"line\"></span><br><span class=\"line\">V     V     V     V</span><br><span class=\"line\">V     V     V     V</span><br><span class=\"line\"></span><br><span class=\"line\">U     U     U     U</span><br><span class=\"line\">U     U     U     U</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//YU12: YYYYYYYY UU VV =&gt;YUV420P</span></span><br><span class=\"line\"><span class=\"comment\">//YV12: YYYYYYYY VV UU =&gt;YUV420P</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3．YUYV图像格式（打包格式存储）\"><a href=\"#3．YUYV图像格式（打包格式存储）\" class=\"headerlink\" title=\"3．YUYV图像格式（打包格式存储）\"></a>3．YUYV图像格式（打包格式存储）</h3><p>YUYV图像格式属于 YUV颜色空间中的YUV422格式，每两个Y分量共用一组U分量和V分量，Y、U、V交叉排序。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排列方式如：</span></span><br><span class=\"line\">Y U Y V   Y U Y V   Y U Y V   Y U Y V</span><br><span class=\"line\"></span><br><span class=\"line\">Y U Y V   Y U Y V   Y U Y V   Y U Y V</span><br><span class=\"line\"></span><br><span class=\"line\">Y U Y V   Y U Y V   Y U Y V   Y U Y V</span><br><span class=\"line\"></span><br><span class=\"line\">Y U Y V   Y U Y V   Y U Y V   Y U Y V</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"三、RGB与YUV的格式转换\"><a href=\"#三、RGB与YUV的格式转换\" class=\"headerlink\" title=\"三、RGB与YUV的格式转换\"></a>三、RGB与YUV的格式转换</h1><p>图像显示器——通过RGB模型显示图像</p>\n<p>传输图像数据——通过YUV模型传输 （YUV 模型可以节省带宽）</p>\n<p><img src=\"/2023/04/13/2-YUV&RGB/8.png\"></p>\n<h2 id=\"转换公式：\"><a href=\"#转换公式：\" class=\"headerlink\" title=\"转换公式：\"></a>转换公式：</h2><p>1.小数形式, YUV  ( U∈[-0.5-0.5] ,  R，G，B∈[0,1] )</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Y =  <span class=\"number\">0.299</span>*R + <span class=\"number\">0.587</span>*G + <span class=\"number\">0.114</span>*B;</span><br><span class=\"line\">U = <span class=\"number\">-0.169</span>*R - <span class=\"number\">0.331</span>*G + <span class=\"number\">0.5</span>  *B ;</span><br><span class=\"line\">V =  <span class=\"number\">0.5</span>  *R - <span class=\"number\">0.419</span>*G - <span class=\"number\">0.081</span>*B;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R = Y + <span class=\"number\">1.4075</span> * V;  </span><br><span class=\"line\">G = Y - <span class=\"number\">0.3455</span> * U - <span class=\"number\">0.7169</span>*V;  </span><br><span class=\"line\">B = Y + <span class=\"number\">1.779</span> * U; </span><br></pre></td></tr></table></figure>\n\n<h1 id=\"四：一图看RGB与YUV\"><a href=\"#四：一图看RGB与YUV\" class=\"headerlink\" title=\"四：一图看RGB与YUV\"></a>四：一图看RGB与YUV</h1><h2 id=\"RGB格式\"><a href=\"#RGB格式\" class=\"headerlink\" title=\"RGB格式\"></a>RGB格式</h2><p> <img src=\"/2023/04/13/2-YUV&RGB/9.jpg\"></p>\n<h2 id=\"YUV格式\"><a href=\"#YUV格式\" class=\"headerlink\" title=\"YUV格式\"></a>YUV格式</h2><p><img src=\"/2023/04/13/2-YUV&RGB/10.jpg\"></p>\n<h2 id=\"YUV存储格式\"><a href=\"#YUV存储格式\" class=\"headerlink\" title=\"YUV存储格式\"></a>YUV存储格式</h2><p><img src=\"/2023/04/13/2-YUV&RGB/11.jpg\"></p>\n<h2 id=\"ARGB\"><a href=\"#ARGB\" class=\"headerlink\" title=\"ARGB\"></a>ARGB</h2><p><img src=\"/2023/04/13/2-YUV&RGB/12.jpg\"></p>\n<p>…</p>\n<p>…</p>"},{"title":"G2D","date":"2023-04-14T10:08:11.000Z","comments":0,"description":null,"typora-root-url":"G2D","_content":"\n<div align = \"center\">G2D</div>\n\n\n## \t1.什么是跟g2d？\n\n​\tG2D也就是我们说的2d加速。很久以前，绘图工作全部是由我们伟大而神圣的 CPU 来完成的，那时候的显卡，就是真正意义上用来“显示东西的卡”。它的工作就是把 CPU 处理好的数据“搬”到显示器上来。那时候 CPU 的工作可真是辛苦。现在好了，CPU 越来越快，可是做的工作却越来越少了。先来说说图形加速的几个阶段。2D 图像加速，Windows 加速 和 3D 图像加速。\n\n<!--more-->\n\n​\t2D 加速，是早就有的产物了。它的作用是用 显示芯片 来代替 CPU，整块整块的移动显存里的数据。比如，你要移动一个窗口，在没有 2D 加速的时代，CPU 所作的工作：1、找到窗口在显存中的地址，2、把一行数据拷贝到目的地址，3、重复 2 直到拷贝完所有的行。完成。这样一来，当窗口很大的时候，CPU 要处理的数据量就会成倍的增长，导致窗口的移动比蜗牛爬还慢…. 想体验一下吗？好，进入设备管理器，把你的显卡驱动删掉，然后重起…. 好好享受啊！呵呵 \n\n​\t有了 2D 加速呢，CPU 所做的事，减轻了很多，不过还是要指导 显示芯片 来干这搬运工的活。CPU 的工作：1、找到窗口在显存中的地址，2、给 显卡发送 “拷贝这一行到目的地”的命令。3、重复 2 直到拷贝完所有的行。初看起来好像和没有加速以前差不多，可是第 2 步就是关键所在哦。 \n\n​\t现在让我们把第二步分解来看：没有 2D 加速：1、读 32 Bit 数据(入门篇里的哦！)，把这 32 Bit 数据写入目的地。2、重复 1 直到一行所有的像素被处理完。而有了 2D 加速后的工作只有：1、发送命令让显卡去拷贝这一行。这样看来，2D 加速确实能很大程度的释放 CPU 的负担。所以大家现在随便提起一个窗口移动一下，很平滑不是吗？显卡负责了窗口的移动。\n\n\n\n## 2.支持的功能有哪些?\n\n​\t转码，缩放，位块传输......(不同芯片支持的具体功能不尽相同)\n\n![](1.png)\n\n```\n支持图层大小最高至2048*2048像素点\n支持输入/输出格式：YUV422（sp、planner）、YUV420（sp、planer）......\n支持水平和垂直翻转，顺时针 0/90/180/270度 旋转\n```\n\n\n\n## 3.函数接口命令\n\n```cpp\n//fd:G2D设备文件标识符，cmd:命令码，arg:对应结构体指针\nint ioctl(int * fd, int cmd, unsigned long arg);\n//常见cmd功能、与结构体对应关系\nG2D_CMD_BITBLT_H //实现单幅图的缩放，格式转换。实现foreground带缩放的ROP2处理 >> g2d_blt_h\nG2D_CMD_BITBLT //实现两个图层的运算，如：源拷贝到目标；源旋转放入目标；源和目标做alpha blending /colorkey 后拷到目标。>> g2d_blt \nG2D_CMD_STRETCHBLT\t//实现两个图层的运算，如：源缩放到目标大小后拷贝到目标；源缩放到目标大小后旋转放入目标；源缩放到目标大小后和目标做做alpha blending /colorkey 后拷到目标。>> g2d_stretchblt\nG2D_CMD_MEM_REQUEST //为测试程序提供内存申请接口 >>arg为申请buffer的size\nG2D_CMD_MEM_GETADR //为测试程序提供内存物理地址 >>arg为申请buffer的编号（1~10）\nG2D_CMD_MEM_RELEALSE //为测试程序提供内存物理地址 >>arg为申请buffer的编号（1~10）\n```\n\n​\t注意：G2D使用时，传入的地址只能是物理地址，不能是应用空间申请的虚拟地址。所以测试时，需要alloc_mem的方式申请一片内存空间，得到其物理地址，才能进行G2D调用。\n\n## 4.数据结构\n\n### g2d_blt_h\n\n```cpp\ntypedef struct {\n    g2d_blt_flags_h\tflag_h;//blt操作flag标志\n    g2d_image_enh\tsrc_image_h;//源图像信息\n    g2d_image_enh\tdst_image_h;//目标图像信息\n    __u32\t\t\tcolor;//colorkey颜色\n    __u32\t\t\talpha;//面alpha值\n} g2d_blt_h;\n```\n\n### g2d_blt\n\n```cpp\ntypedef struct {\n    g2d_blt_flags\tflag;//blt操作flag标志\n    g2d_image\t\tsrc_image;//源图像信息\n    g2d_rect\t\tsrc_rect;//源矩形信息，x/y/w/h-左上角x/左上角y/宽/高\n    g2d_image\t\tdst_image;//目标图像信息\n    __s32\t\t\tdst_x;//目标矩阵左上角x\n    __s32\t\t\tdst_y;//目标矩阵左上角y\n    __u32\t\t\tcolor;//colorkey颜色\n    __u32\t\t\talpha;//面alpha值\n}g2d_blt;\n```\n\n### g2d_stretchblt\n\n```cpp\ntypedef struct {\n    g2d_blt_flags\tflag;//blt操作flag标志\n    g2d_image\t\tsrc_image;//源图像信息\n    g2d_rect\t\tsrc_rect;//源矩形信息，x/y/w/h-左上角x/左上角y/宽/高\n    g2d_image\t\tdst_image;//目标图像信息\n\tg2d_rect\t\tdst_rect;//目标矩形信息，x/y/w/h-左上角x/左上角y/宽/高\n    __u32\t\t\tcolor;//colorkey颜色\n    __u32\t\t\talpha;//面alpha值\n}g2d_stretchblt;\n```\n\n### g2d_image\n\n主要用于描述image属性信息\n\n```cpp\ntypedef struct {\n    __u32\taddr[3];//图像帧的基地址，对于UV combined ，addr[0,1]有效，planner类型addr[0,1,2]有效，其他addr[0]有效\n    __u32\tw;//图像帧的宽\n    __u32\th;//图像帧的高\n    g2d_data_fmt\tformat;//图像帧buffer的像素格式\n    g2d_pixel_seq\tpixel_seq;//图像帧buffer的像素序列\n}g2d_image;\n```\n\n### g2d_image_enh\n\n​\t主要描述图片的宽高、存放地址、是否做Clip处理，是否为预乘等\n\n```cpp\ntypedef struct {\n    int\t\tbbuff;\n    g2d_fmt_enh\tformat;//图格式\n    __u32\tladdr[3];//起始低位地址\n    __u32\thaddr[3];//起始高位地址\n    __u32\twidth;//图宽\n    __u32\theight;//图高\n    __u32\talign[3];\n    g2d_rect\t\tclip_rect;//ROI矩形\n    __u32\tgamut;//图的色域\n    int\t\tbpremul;//是否为预乘\n    __u8\talpha;//面alpha值\n    g2d_alpha_mode_enh\tmode;//alpha模式设置\n}g2d_image_enh;\n```\n\n​\tladdr以及haddr是针对32为以及64位处理器的一个适配，32位处理器只需要填充laddr，64位则需要填充laddr和haddr\n\n### g2d_blt_flags\n\n```cpp\ntypedef enum{\n    G2D_BLT_NONE\t\t\t= 0x00000000,//纯拷贝\n    G2D_BLT_PIXEL_ALPHA\t\t= 0x00000001,//点alpha标志\n    G2D_BLT_PLANE_ALPHA \t= 0x00000002,//面alpha标志\n    G2D_BLT_MULTI_ALPHA \t=0x00000004,//混合alpha标志\n    G2D_BLT_SRC_COLORKEY \t= 0x00000008,//源colorkey标志\n    G2D_BLT_DST_COLORKEY \t= 0x00000010,//目标colorkey标志\n    G2D_BLT_FLIP_HORIZONTAL = 0x00000020,//水平翻转\n    G2D_BLT_VERTICAL\t\t= 0x00000040,//垂直翻转\n    G2D_BLT_ROTATE90\t\t= 0x00000080,//逆时针旋转90度\n    G2D_BLT_ROTATE180 \t\t= 0x00000100,//逆时针旋转180度\n    G2D_BLT_ROTATE270 \t\t= 0x00000200,//逆时针旋转270度\n    G2D_BLT_MIRROR45 \t\t= 0x00000400,//镜像45度\n    G2D_BLT_MIRROR135\t\t = 0x00000800,//镜像135度\n}g2d_blt_flags\n```\n\n### g2d_blt_flags_h\n\n```\n\n```\n\n\n\n## 5.举例\n\n1.可参考虚拟机中.../sdk_demo/G2dDemo。\n\n2.也可参考全志G2D开发指南\n\n### 1.旋转，缩放与格式转换\n\n```cpp\ng2d_blt_h blit;//实例化一个对象，进行参数填充\n\nblit.flag_h = G2D_BLT_NONE_0;//修改此参数实现旋转。如：G2D_ROT_90旋转90度\nblit.src_image_h.fd = src_buffd;//源图像\n//blit.src_image_h.format = G2D_FORMAT_YUV420_PLANAR;\nblit.src_image_h.format = G2D_FORMAT_ARGB8888;\nblit.src_image_h.mode = G2D_GLOBAL_ALPHA;\nblit.src_image_h.clip_rect.x = 0;\nblit.src_image_h.clip_rect.y = 0;\nblit.src_image_h.clip_rect.w = 320;\nblit.src_image_h.clip_rect.h = 480;\n blit.src_image_h.width = 320;\nblit.src_image_h.height = 480;\nblit.src_image_h.alpha = 0xff;\nblit.dst_image_h.fd = dst_buffd;//目标图像\n//blit.dst_image_h.format = G2D_FORMAT_YUV420_PLANAR;\t\nblit.dst_image_h.format = G2D_FORMAT_ARGB8888;//修改此格式可改变输出格式\nblit.dst_image_h.mode = G2D_GLOBAL_ALPHA;\nblit.dst_image_h.clip_rect.x = 0;\nblit.dst_image_h.clip_rect.y = 0;\nblit.dst_image_h.clip_rect.w = 320;//修改此参数可实现缩放\nblit.dst_image_h.clip_rect.h = 480;//修改此参数可实现缩放\nblit.dst_image_h.alpha = 0xff; \nblit.dst_image_h.width = 320;//与上保持一致\nblit.dst_image_h.height = 480;//与上保持一致\n\nif(ioctl(g2d_fd,  G2D_CMD_BITBLT_H ,(unsigned long)(&blit)) < 0)\n{\n\tprintf(\"[%d][%s][%s]G2D_CMD_BITBLT_H failure!\\n\",__LINE__, __FILE__,__FUNCTION__);\n\treturn -1;\n}\n```\n\n### 2.输入输出\n\n```cpp\ng2d_blt blit;\n//设置BITBLT flag标志位\nblit.color = 0xff;\nblit.alpha = 0xff;\nblit.flag = G2D_BLT_NONE;//纯拷贝\n//设置源image和rect\nblit.src_image.addr[0] = memin;\nblit.src_image.w = 800;\nblit.src_image.h = 480;\nblit.src_image.format = G2D_FMT_RGBA8888;\t\nblit.src_image.pixel_seq = G2D_SEQ_NORMAL;\nblit.src_rect.x = 0;\nblit.src_rect.y = 0;\nblit.src_rect.w = 480;\nblit.src_rect.h = 272;\n//设置目标image和rect\nblit.dst_image.addr[0] = memout;\nblit.dst_image.w = 800;\nblit.dst_image.h = 480;\nblit.dst_image.format = G2D_FMT_RGBA8888;\nblit.dst_image.pixel_seq = G2D_SEQ_NORMAL;\nblit.dst_x = 0;\nblit.dst_y = 0;\n\nif(ioctl(g2d_fd, G2D_CMD_BITBLT, &blit_para) < 0)\n{\n\tprint(\"G2D_CMD_BITBLT failure!\\n\");\n\treturn -1;\n}\n```\n\n### 3.缩放\n\n```cpp\ng2d_stretchblt scale;\n\tint retval = -1;\n\n\tscale.flag = G2D_BLT_NONE;\n\tscale.src_image.addr[0] = (unsigned long)psrc;\n\t//scale.src_image.addr[1] = (unsigned long)psrc + src_w * src_h;\n\tscale.src_image.w = src_w;\n\tscale.src_image.h = src_h;\n\t//scale.src_image.format = G2D_FMT_PYUV420UVC;\n\tscale.src_image.format = G2D_FMT_XRGB8888;\n\tscale.src_image.pixel_seq = G2D_SEQ_NORMAL;\n\tscale.src_rect.x = src_crop_x;\n\tscale.src_rect.y = src_crop_y;\n\tscale.src_rect.w = src_crop_w;\n\tscale.src_rect.h = src_crop_h;\n\tscale.dst_image.addr[0] = (unsigned long)pdst;\n\t//scale.dst_image.addr[1] = (unsigned long)pdst + dst_w * dst_h;\n\tscale.dst_image.w = dst_w;\n\tscale.dst_image.h = dst_h;\n\t//scale.dst_image.format = G2D_FMT_PYUV420UVC;\t\n\tscale.dst_image.format = G2D_FMT_XRGB8888;\n\tscale.dst_image.pixel_seq = G2D_SEQ_NORMAL;\n\tscale.dst_rect.x = dst_crop_x;\n\tscale.dst_rect.y = dst_crop_y;\n\tscale.dst_rect.w = dst_crop_w;\n\tscale.dst_rect.h = dst_crop_h;\n\tscale.color = 0xff;\n\tscale.alpha = 0xff;\t\n\t\n\tif(ioctl(g2d_fd,  G2D_CMD_STRETCHBLT ,(unsigned long)(&scale)) < 0)\n\t{\n\t\tprintf(\"[%d][%s][%s]G2D_CMD_STRETCHBLT failure!\\n\",\n\t\t\t__LINE__, __FILE__,__FUNCTION__);\n\t\treturn -1;\n\t}\n```\n\n## 6.应用层申请内核地址的办法\n\n### 1.G2D命令码\n\n```cpp\nG2D_CMD_MEM_REQUEST //为测试程序提供内存申请接口 >>arg为申请buffer的size\nG2D_CMD_MEM_GETADR //为测试程序提供内存物理地址 >>arg为申请buffer的编号（1~10）\nG2D_CMD_MEM_RELEALSE //为测试程序提供内存物理地址 >>arg为申请buffer的编号（1~10）\n```\n\n### 2.alloc_mem\n\n```c\n//如：****alloc_buffer->phy = 0xfa200000,alloc_buffer->vir = 0x7f71081000\n```\n\n参考：\n\n```cpp\n#include \"sunxiMemInterface.h\"\n#include \"G2dApi.h\"\n\nVTint32 VTG2D_ClipByFd(VTint32 src_buffd, VTint32 dst_buffd,VTint32 dst_x,VTint32 dst_y)\n{\n\tg2d_blt_h blit;\n\n\tblit.flag_h = G2D_ROT_0;//G2D_BLT_NONE_H\n\tblit.src_image_h.fd = src_buffd;\n\tblit.src_image_h.format = G2D_FORMAT_YUV420UVC_U1V1U0V0;//NV12\n\tblit.src_image_h.mode = G2D_GLOBAL_ALPHA;\n\tblit.src_image_h.clip_rect.x = 0;\n\tblit.src_image_h.clip_rect.y = 0;\n\tblit.src_image_h.clip_rect.w = 1280;\n\tblit.src_image_h.clip_rect.h = 720;\n\tblit.src_image_h.width = 1280;\n\tblit.src_image_h.height = 720;\n\tblit.src_image_h.alpha = 0xff; \n\n\tblit.src_image_h.fd = dst_buffd;\n\tblit.dst_image_h.format = G2D_FORMAT_YUV420UVC_U1V1U0V0;\t\n\tblit.dst_image_h.mode = G2D_GLOBAL_ALPHA;\n\tblit.dst_image_h.clip_rect.x = dst_x;\n\tblit.dst_image_h.clip_rect.y = dst_y;\n\tblit.dst_image_h.clip_rect.w = 1280;\n\tblit.dst_image_h.clip_rect.h = 720;\n\tblit.dst_image_h.width = 3840;\n\tblit.dst_image_h.height = 1440;\n\tblit.dst_image_h.alpha = 0xff; \n\n\tif(ioctl(g2d_fd,  G2D_CMD_BITBLT_H ,(unsigned long)(&blit)) < 0)\n\t{\n\t\tprintf(\"[%d][%s][%s]G2D_CMD_BITBLT_H failure!\\n\",\n\t\t\t__LINE__, __FILE__,__FUNCTION__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nint allocPicMem(paramStruct_t*pops,int size)\n{\n    int iRet = 0;\n\n    iRet = allocOpen(MEM_TYPE_CDX_NEW, pops, NULL);\n    if (iRet < 0) {\n        printf(\"ion_alloc_open failed\\n\");\n        return iRet;\n    }\n    pops->size =size;\n    iRet = allocAlloc(MEM_TYPE_CDX_NEW, pops, NULL);\n    if(iRet < 0) {\n        printf(\"allocAlloc failed\\n\");\n        return iRet;\n    }\n\n    return 0;\n}\nint freePicMem(paramStruct_t*pops)\n{\n\tint iRet = 0;\n\tallocFree(MEM_TYPE_CDX_NEW, pops, NULL);\n\n    return 0;\n}\nint ReadPicFileContent(char *pPicPath,paramStruct_t*pops,int size)\n{\n    allocPicMem(pops,size);\n\n    FILE *fpff = fopen(pPicPath, \"rb\");\n    if(NULL == fpff) {\n        fpff = fopen(pPicPath, \"rb\");\n        if(NULL == fpff) {\n            printf(\"fopen %s ERR \\n\", pPicPath);\n            allocFree(MEM_TYPE_CDX_NEW, pops, NULL);\n            return -1;\n        } else {\n            printf(\"fopen %s OK \\n\", pPicPath);\n            fread((void *)pops->vir, 1, size, fpff);\n            fclose(fpff);\n        }\n    } else {\n        printf(\"fopen %s OK \\n\", pPicPath);\n        fread((void *)pops->vir, 1, size, fpff);\n        fclose(fpff);\n    }\n\tflushCache(MEM_TYPE_CDX_NEW,pops, NULL);\n\n    return 0;\n}\nint WritePicFileContent(char *pPicPath,paramStruct_t*pops,int size)\n{\n    int iRet = 0;\n\tprintf(\"WritePicFileContent size=%d \\n\",size);\n\tflushCache(MEM_TYPE_CDX_NEW,pops, NULL);\n\n    FILE *fpff = fopen(pPicPath, \"wb\");\n    if(NULL == fpff) {\n        fpff = fopen(pPicPath, \"wb\");\n        if(NULL == fpff) {\n            printf(\"fopen %s ERR \\n\", pPicPath);\n            allocFree(MEM_TYPE_CDX_NEW, pops, NULL);\n            return -1;\n        } else {\n            printf(\"fopen %s OK \\n\", pPicPath);\n            fwrite((void *)pops->vir, 1, size, fpff);\n            fclose(fpff);\n        }\n    } else {\n        printf(\"fopen %s OK \\n\", pPicPath);\n        fwrite((void *)pops->vir, 1, size, fpff);\n        fclose(fpff);\n    }\n    return 0;\n}\nint VT_G2D_6in1compose(int iSubWidth,int iSubHeight,int iWidth,int iHeight)\n{\n\tparamStruct_t m_DispMemOps;\n\tparamStruct_t m_DispMemOps0;\n\tparamStruct_t m_DispMemOps1;\n\tparamStruct_t m_DispMemOps2;\n\tparamStruct_t m_DispMemOps3;\n\tparamStruct_t m_DispMemOps4;\n\tparamStruct_t m_DispMemOps5;\n\tchar *pcompPicPath0=\"cvideo.yuv\";\n\tchar *pPicPath0=\"Video[0]_picture0.yuv\";\n\tchar *pPicPath1=\"Video[1]_picture0.yuv\";\n\tchar *pPicPath2=\"Video[2]_picture0.yuv\";\n\tchar *pPicPath3=\"Video[3]_picture0.yuv\";\n\tchar *pPicPath4=\"Video[4]_picture0.yuv\";\n\tchar *pPicPath5=\"Video[5]_picture0.yuv\";\n\n\t\tReadPicFileContent(pPicPath0,&m_DispMemOps0,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath1,&m_DispMemOps1,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath2,&m_DispMemOps2,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath3,&m_DispMemOps3,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath4,&m_DispMemOps4,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath5,&m_DispMemOps5,iSubWidth*iSubHeight*3/2);\n\n\t\tallocPicMem(&m_DispMemOps,iWidth*iHeight*3/2);\n\t\tint outfd = m_DispMemOps.ion_buffer.fd_data.aw_fd;\n\t\tint infd[6];\n\t\tinfd[0] = m_DispMemOps0.ion_buffer.fd_data.aw_fd;\n\t\tinfd[1] = m_DispMemOps1.ion_buffer.fd_data.aw_fd;\n\t\tinfd[2] = m_DispMemOps2.ion_buffer.fd_data.aw_fd;\n\t\tinfd[3] = m_DispMemOps3.ion_buffer.fd_data.aw_fd;\n\t\tinfd[4] = m_DispMemOps4.ion_buffer.fd_data.aw_fd;\n\t\tinfd[5] = m_DispMemOps5.ion_buffer.fd_data.aw_fd;\n\t\tint ret = -1;\n\t\tret  = VTG2D_ClipByFd(infd[0],outfd,0,0);\n\t\tg2dClipByFd();\n\t\tret |= VTG2D_ClipByFd(infd[1],outfd,iSubWidth,0);\n\t\tret |= VTG2D_ClipByFd(infd[2],outfd,iSubWidth*2,0);\n\t\tret |= VTG2D_ClipByFd(infd[3],outfd,0,iSubHeight);\n\t\tret |= VTG2D_ClipByFd(infd[4],outfd,iSubWidth,iSubHeight);\n\t\tret |= VTG2D_ClipByFd(infd[5],outfd,iSubWidth*2,iSubHeight);\n\t\tWritePicFileContent(pcompPicPath0,&m_DispMemOps,iWidth*iHeight*3/2);\n\t\tfreePicMem(&m_DispMemOps);\n\t\tfreePicMem(&m_DispMemOps0);\n\t\tfreePicMem(&m_DispMemOps1);\n\t\tfreePicMem(&m_DispMemOps2);\n\t\tfreePicMem(&m_DispMemOps3);\n\t\tfreePicMem(&m_DispMemOps4);\n\t\tfreePicMem(&m_DispMemOps5);\n\treturn 1;\n}\n```\n\n注意：T5中不能进行缩放和格式转换。而且要求目标图像和源图像的分辨率必须相同。","source":"_posts/3-G2D.md","raw":"---\ntitle: G2D\ndate: 2023-4-14 18:08:11\ncategories: 笔记\ntags: 嵌入式\ncomments: false\ndescription:\ntypora-root-url: G2D\n---\n\n<div align = \"center\">G2D</div>\n\n\n## \t1.什么是跟g2d？\n\n​\tG2D也就是我们说的2d加速。很久以前，绘图工作全部是由我们伟大而神圣的 CPU 来完成的，那时候的显卡，就是真正意义上用来“显示东西的卡”。它的工作就是把 CPU 处理好的数据“搬”到显示器上来。那时候 CPU 的工作可真是辛苦。现在好了，CPU 越来越快，可是做的工作却越来越少了。先来说说图形加速的几个阶段。2D 图像加速，Windows 加速 和 3D 图像加速。\n\n<!--more-->\n\n​\t2D 加速，是早就有的产物了。它的作用是用 显示芯片 来代替 CPU，整块整块的移动显存里的数据。比如，你要移动一个窗口，在没有 2D 加速的时代，CPU 所作的工作：1、找到窗口在显存中的地址，2、把一行数据拷贝到目的地址，3、重复 2 直到拷贝完所有的行。完成。这样一来，当窗口很大的时候，CPU 要处理的数据量就会成倍的增长，导致窗口的移动比蜗牛爬还慢…. 想体验一下吗？好，进入设备管理器，把你的显卡驱动删掉，然后重起…. 好好享受啊！呵呵 \n\n​\t有了 2D 加速呢，CPU 所做的事，减轻了很多，不过还是要指导 显示芯片 来干这搬运工的活。CPU 的工作：1、找到窗口在显存中的地址，2、给 显卡发送 “拷贝这一行到目的地”的命令。3、重复 2 直到拷贝完所有的行。初看起来好像和没有加速以前差不多，可是第 2 步就是关键所在哦。 \n\n​\t现在让我们把第二步分解来看：没有 2D 加速：1、读 32 Bit 数据(入门篇里的哦！)，把这 32 Bit 数据写入目的地。2、重复 1 直到一行所有的像素被处理完。而有了 2D 加速后的工作只有：1、发送命令让显卡去拷贝这一行。这样看来，2D 加速确实能很大程度的释放 CPU 的负担。所以大家现在随便提起一个窗口移动一下，很平滑不是吗？显卡负责了窗口的移动。\n\n\n\n## 2.支持的功能有哪些?\n\n​\t转码，缩放，位块传输......(不同芯片支持的具体功能不尽相同)\n\n![](1.png)\n\n```\n支持图层大小最高至2048*2048像素点\n支持输入/输出格式：YUV422（sp、planner）、YUV420（sp、planer）......\n支持水平和垂直翻转，顺时针 0/90/180/270度 旋转\n```\n\n\n\n## 3.函数接口命令\n\n```cpp\n//fd:G2D设备文件标识符，cmd:命令码，arg:对应结构体指针\nint ioctl(int * fd, int cmd, unsigned long arg);\n//常见cmd功能、与结构体对应关系\nG2D_CMD_BITBLT_H //实现单幅图的缩放，格式转换。实现foreground带缩放的ROP2处理 >> g2d_blt_h\nG2D_CMD_BITBLT //实现两个图层的运算，如：源拷贝到目标；源旋转放入目标；源和目标做alpha blending /colorkey 后拷到目标。>> g2d_blt \nG2D_CMD_STRETCHBLT\t//实现两个图层的运算，如：源缩放到目标大小后拷贝到目标；源缩放到目标大小后旋转放入目标；源缩放到目标大小后和目标做做alpha blending /colorkey 后拷到目标。>> g2d_stretchblt\nG2D_CMD_MEM_REQUEST //为测试程序提供内存申请接口 >>arg为申请buffer的size\nG2D_CMD_MEM_GETADR //为测试程序提供内存物理地址 >>arg为申请buffer的编号（1~10）\nG2D_CMD_MEM_RELEALSE //为测试程序提供内存物理地址 >>arg为申请buffer的编号（1~10）\n```\n\n​\t注意：G2D使用时，传入的地址只能是物理地址，不能是应用空间申请的虚拟地址。所以测试时，需要alloc_mem的方式申请一片内存空间，得到其物理地址，才能进行G2D调用。\n\n## 4.数据结构\n\n### g2d_blt_h\n\n```cpp\ntypedef struct {\n    g2d_blt_flags_h\tflag_h;//blt操作flag标志\n    g2d_image_enh\tsrc_image_h;//源图像信息\n    g2d_image_enh\tdst_image_h;//目标图像信息\n    __u32\t\t\tcolor;//colorkey颜色\n    __u32\t\t\talpha;//面alpha值\n} g2d_blt_h;\n```\n\n### g2d_blt\n\n```cpp\ntypedef struct {\n    g2d_blt_flags\tflag;//blt操作flag标志\n    g2d_image\t\tsrc_image;//源图像信息\n    g2d_rect\t\tsrc_rect;//源矩形信息，x/y/w/h-左上角x/左上角y/宽/高\n    g2d_image\t\tdst_image;//目标图像信息\n    __s32\t\t\tdst_x;//目标矩阵左上角x\n    __s32\t\t\tdst_y;//目标矩阵左上角y\n    __u32\t\t\tcolor;//colorkey颜色\n    __u32\t\t\talpha;//面alpha值\n}g2d_blt;\n```\n\n### g2d_stretchblt\n\n```cpp\ntypedef struct {\n    g2d_blt_flags\tflag;//blt操作flag标志\n    g2d_image\t\tsrc_image;//源图像信息\n    g2d_rect\t\tsrc_rect;//源矩形信息，x/y/w/h-左上角x/左上角y/宽/高\n    g2d_image\t\tdst_image;//目标图像信息\n\tg2d_rect\t\tdst_rect;//目标矩形信息，x/y/w/h-左上角x/左上角y/宽/高\n    __u32\t\t\tcolor;//colorkey颜色\n    __u32\t\t\talpha;//面alpha值\n}g2d_stretchblt;\n```\n\n### g2d_image\n\n主要用于描述image属性信息\n\n```cpp\ntypedef struct {\n    __u32\taddr[3];//图像帧的基地址，对于UV combined ，addr[0,1]有效，planner类型addr[0,1,2]有效，其他addr[0]有效\n    __u32\tw;//图像帧的宽\n    __u32\th;//图像帧的高\n    g2d_data_fmt\tformat;//图像帧buffer的像素格式\n    g2d_pixel_seq\tpixel_seq;//图像帧buffer的像素序列\n}g2d_image;\n```\n\n### g2d_image_enh\n\n​\t主要描述图片的宽高、存放地址、是否做Clip处理，是否为预乘等\n\n```cpp\ntypedef struct {\n    int\t\tbbuff;\n    g2d_fmt_enh\tformat;//图格式\n    __u32\tladdr[3];//起始低位地址\n    __u32\thaddr[3];//起始高位地址\n    __u32\twidth;//图宽\n    __u32\theight;//图高\n    __u32\talign[3];\n    g2d_rect\t\tclip_rect;//ROI矩形\n    __u32\tgamut;//图的色域\n    int\t\tbpremul;//是否为预乘\n    __u8\talpha;//面alpha值\n    g2d_alpha_mode_enh\tmode;//alpha模式设置\n}g2d_image_enh;\n```\n\n​\tladdr以及haddr是针对32为以及64位处理器的一个适配，32位处理器只需要填充laddr，64位则需要填充laddr和haddr\n\n### g2d_blt_flags\n\n```cpp\ntypedef enum{\n    G2D_BLT_NONE\t\t\t= 0x00000000,//纯拷贝\n    G2D_BLT_PIXEL_ALPHA\t\t= 0x00000001,//点alpha标志\n    G2D_BLT_PLANE_ALPHA \t= 0x00000002,//面alpha标志\n    G2D_BLT_MULTI_ALPHA \t=0x00000004,//混合alpha标志\n    G2D_BLT_SRC_COLORKEY \t= 0x00000008,//源colorkey标志\n    G2D_BLT_DST_COLORKEY \t= 0x00000010,//目标colorkey标志\n    G2D_BLT_FLIP_HORIZONTAL = 0x00000020,//水平翻转\n    G2D_BLT_VERTICAL\t\t= 0x00000040,//垂直翻转\n    G2D_BLT_ROTATE90\t\t= 0x00000080,//逆时针旋转90度\n    G2D_BLT_ROTATE180 \t\t= 0x00000100,//逆时针旋转180度\n    G2D_BLT_ROTATE270 \t\t= 0x00000200,//逆时针旋转270度\n    G2D_BLT_MIRROR45 \t\t= 0x00000400,//镜像45度\n    G2D_BLT_MIRROR135\t\t = 0x00000800,//镜像135度\n}g2d_blt_flags\n```\n\n### g2d_blt_flags_h\n\n```\n\n```\n\n\n\n## 5.举例\n\n1.可参考虚拟机中.../sdk_demo/G2dDemo。\n\n2.也可参考全志G2D开发指南\n\n### 1.旋转，缩放与格式转换\n\n```cpp\ng2d_blt_h blit;//实例化一个对象，进行参数填充\n\nblit.flag_h = G2D_BLT_NONE_0;//修改此参数实现旋转。如：G2D_ROT_90旋转90度\nblit.src_image_h.fd = src_buffd;//源图像\n//blit.src_image_h.format = G2D_FORMAT_YUV420_PLANAR;\nblit.src_image_h.format = G2D_FORMAT_ARGB8888;\nblit.src_image_h.mode = G2D_GLOBAL_ALPHA;\nblit.src_image_h.clip_rect.x = 0;\nblit.src_image_h.clip_rect.y = 0;\nblit.src_image_h.clip_rect.w = 320;\nblit.src_image_h.clip_rect.h = 480;\n blit.src_image_h.width = 320;\nblit.src_image_h.height = 480;\nblit.src_image_h.alpha = 0xff;\nblit.dst_image_h.fd = dst_buffd;//目标图像\n//blit.dst_image_h.format = G2D_FORMAT_YUV420_PLANAR;\t\nblit.dst_image_h.format = G2D_FORMAT_ARGB8888;//修改此格式可改变输出格式\nblit.dst_image_h.mode = G2D_GLOBAL_ALPHA;\nblit.dst_image_h.clip_rect.x = 0;\nblit.dst_image_h.clip_rect.y = 0;\nblit.dst_image_h.clip_rect.w = 320;//修改此参数可实现缩放\nblit.dst_image_h.clip_rect.h = 480;//修改此参数可实现缩放\nblit.dst_image_h.alpha = 0xff; \nblit.dst_image_h.width = 320;//与上保持一致\nblit.dst_image_h.height = 480;//与上保持一致\n\nif(ioctl(g2d_fd,  G2D_CMD_BITBLT_H ,(unsigned long)(&blit)) < 0)\n{\n\tprintf(\"[%d][%s][%s]G2D_CMD_BITBLT_H failure!\\n\",__LINE__, __FILE__,__FUNCTION__);\n\treturn -1;\n}\n```\n\n### 2.输入输出\n\n```cpp\ng2d_blt blit;\n//设置BITBLT flag标志位\nblit.color = 0xff;\nblit.alpha = 0xff;\nblit.flag = G2D_BLT_NONE;//纯拷贝\n//设置源image和rect\nblit.src_image.addr[0] = memin;\nblit.src_image.w = 800;\nblit.src_image.h = 480;\nblit.src_image.format = G2D_FMT_RGBA8888;\t\nblit.src_image.pixel_seq = G2D_SEQ_NORMAL;\nblit.src_rect.x = 0;\nblit.src_rect.y = 0;\nblit.src_rect.w = 480;\nblit.src_rect.h = 272;\n//设置目标image和rect\nblit.dst_image.addr[0] = memout;\nblit.dst_image.w = 800;\nblit.dst_image.h = 480;\nblit.dst_image.format = G2D_FMT_RGBA8888;\nblit.dst_image.pixel_seq = G2D_SEQ_NORMAL;\nblit.dst_x = 0;\nblit.dst_y = 0;\n\nif(ioctl(g2d_fd, G2D_CMD_BITBLT, &blit_para) < 0)\n{\n\tprint(\"G2D_CMD_BITBLT failure!\\n\");\n\treturn -1;\n}\n```\n\n### 3.缩放\n\n```cpp\ng2d_stretchblt scale;\n\tint retval = -1;\n\n\tscale.flag = G2D_BLT_NONE;\n\tscale.src_image.addr[0] = (unsigned long)psrc;\n\t//scale.src_image.addr[1] = (unsigned long)psrc + src_w * src_h;\n\tscale.src_image.w = src_w;\n\tscale.src_image.h = src_h;\n\t//scale.src_image.format = G2D_FMT_PYUV420UVC;\n\tscale.src_image.format = G2D_FMT_XRGB8888;\n\tscale.src_image.pixel_seq = G2D_SEQ_NORMAL;\n\tscale.src_rect.x = src_crop_x;\n\tscale.src_rect.y = src_crop_y;\n\tscale.src_rect.w = src_crop_w;\n\tscale.src_rect.h = src_crop_h;\n\tscale.dst_image.addr[0] = (unsigned long)pdst;\n\t//scale.dst_image.addr[1] = (unsigned long)pdst + dst_w * dst_h;\n\tscale.dst_image.w = dst_w;\n\tscale.dst_image.h = dst_h;\n\t//scale.dst_image.format = G2D_FMT_PYUV420UVC;\t\n\tscale.dst_image.format = G2D_FMT_XRGB8888;\n\tscale.dst_image.pixel_seq = G2D_SEQ_NORMAL;\n\tscale.dst_rect.x = dst_crop_x;\n\tscale.dst_rect.y = dst_crop_y;\n\tscale.dst_rect.w = dst_crop_w;\n\tscale.dst_rect.h = dst_crop_h;\n\tscale.color = 0xff;\n\tscale.alpha = 0xff;\t\n\t\n\tif(ioctl(g2d_fd,  G2D_CMD_STRETCHBLT ,(unsigned long)(&scale)) < 0)\n\t{\n\t\tprintf(\"[%d][%s][%s]G2D_CMD_STRETCHBLT failure!\\n\",\n\t\t\t__LINE__, __FILE__,__FUNCTION__);\n\t\treturn -1;\n\t}\n```\n\n## 6.应用层申请内核地址的办法\n\n### 1.G2D命令码\n\n```cpp\nG2D_CMD_MEM_REQUEST //为测试程序提供内存申请接口 >>arg为申请buffer的size\nG2D_CMD_MEM_GETADR //为测试程序提供内存物理地址 >>arg为申请buffer的编号（1~10）\nG2D_CMD_MEM_RELEALSE //为测试程序提供内存物理地址 >>arg为申请buffer的编号（1~10）\n```\n\n### 2.alloc_mem\n\n```c\n//如：****alloc_buffer->phy = 0xfa200000,alloc_buffer->vir = 0x7f71081000\n```\n\n参考：\n\n```cpp\n#include \"sunxiMemInterface.h\"\n#include \"G2dApi.h\"\n\nVTint32 VTG2D_ClipByFd(VTint32 src_buffd, VTint32 dst_buffd,VTint32 dst_x,VTint32 dst_y)\n{\n\tg2d_blt_h blit;\n\n\tblit.flag_h = G2D_ROT_0;//G2D_BLT_NONE_H\n\tblit.src_image_h.fd = src_buffd;\n\tblit.src_image_h.format = G2D_FORMAT_YUV420UVC_U1V1U0V0;//NV12\n\tblit.src_image_h.mode = G2D_GLOBAL_ALPHA;\n\tblit.src_image_h.clip_rect.x = 0;\n\tblit.src_image_h.clip_rect.y = 0;\n\tblit.src_image_h.clip_rect.w = 1280;\n\tblit.src_image_h.clip_rect.h = 720;\n\tblit.src_image_h.width = 1280;\n\tblit.src_image_h.height = 720;\n\tblit.src_image_h.alpha = 0xff; \n\n\tblit.src_image_h.fd = dst_buffd;\n\tblit.dst_image_h.format = G2D_FORMAT_YUV420UVC_U1V1U0V0;\t\n\tblit.dst_image_h.mode = G2D_GLOBAL_ALPHA;\n\tblit.dst_image_h.clip_rect.x = dst_x;\n\tblit.dst_image_h.clip_rect.y = dst_y;\n\tblit.dst_image_h.clip_rect.w = 1280;\n\tblit.dst_image_h.clip_rect.h = 720;\n\tblit.dst_image_h.width = 3840;\n\tblit.dst_image_h.height = 1440;\n\tblit.dst_image_h.alpha = 0xff; \n\n\tif(ioctl(g2d_fd,  G2D_CMD_BITBLT_H ,(unsigned long)(&blit)) < 0)\n\t{\n\t\tprintf(\"[%d][%s][%s]G2D_CMD_BITBLT_H failure!\\n\",\n\t\t\t__LINE__, __FILE__,__FUNCTION__);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\nint allocPicMem(paramStruct_t*pops,int size)\n{\n    int iRet = 0;\n\n    iRet = allocOpen(MEM_TYPE_CDX_NEW, pops, NULL);\n    if (iRet < 0) {\n        printf(\"ion_alloc_open failed\\n\");\n        return iRet;\n    }\n    pops->size =size;\n    iRet = allocAlloc(MEM_TYPE_CDX_NEW, pops, NULL);\n    if(iRet < 0) {\n        printf(\"allocAlloc failed\\n\");\n        return iRet;\n    }\n\n    return 0;\n}\nint freePicMem(paramStruct_t*pops)\n{\n\tint iRet = 0;\n\tallocFree(MEM_TYPE_CDX_NEW, pops, NULL);\n\n    return 0;\n}\nint ReadPicFileContent(char *pPicPath,paramStruct_t*pops,int size)\n{\n    allocPicMem(pops,size);\n\n    FILE *fpff = fopen(pPicPath, \"rb\");\n    if(NULL == fpff) {\n        fpff = fopen(pPicPath, \"rb\");\n        if(NULL == fpff) {\n            printf(\"fopen %s ERR \\n\", pPicPath);\n            allocFree(MEM_TYPE_CDX_NEW, pops, NULL);\n            return -1;\n        } else {\n            printf(\"fopen %s OK \\n\", pPicPath);\n            fread((void *)pops->vir, 1, size, fpff);\n            fclose(fpff);\n        }\n    } else {\n        printf(\"fopen %s OK \\n\", pPicPath);\n        fread((void *)pops->vir, 1, size, fpff);\n        fclose(fpff);\n    }\n\tflushCache(MEM_TYPE_CDX_NEW,pops, NULL);\n\n    return 0;\n}\nint WritePicFileContent(char *pPicPath,paramStruct_t*pops,int size)\n{\n    int iRet = 0;\n\tprintf(\"WritePicFileContent size=%d \\n\",size);\n\tflushCache(MEM_TYPE_CDX_NEW,pops, NULL);\n\n    FILE *fpff = fopen(pPicPath, \"wb\");\n    if(NULL == fpff) {\n        fpff = fopen(pPicPath, \"wb\");\n        if(NULL == fpff) {\n            printf(\"fopen %s ERR \\n\", pPicPath);\n            allocFree(MEM_TYPE_CDX_NEW, pops, NULL);\n            return -1;\n        } else {\n            printf(\"fopen %s OK \\n\", pPicPath);\n            fwrite((void *)pops->vir, 1, size, fpff);\n            fclose(fpff);\n        }\n    } else {\n        printf(\"fopen %s OK \\n\", pPicPath);\n        fwrite((void *)pops->vir, 1, size, fpff);\n        fclose(fpff);\n    }\n    return 0;\n}\nint VT_G2D_6in1compose(int iSubWidth,int iSubHeight,int iWidth,int iHeight)\n{\n\tparamStruct_t m_DispMemOps;\n\tparamStruct_t m_DispMemOps0;\n\tparamStruct_t m_DispMemOps1;\n\tparamStruct_t m_DispMemOps2;\n\tparamStruct_t m_DispMemOps3;\n\tparamStruct_t m_DispMemOps4;\n\tparamStruct_t m_DispMemOps5;\n\tchar *pcompPicPath0=\"cvideo.yuv\";\n\tchar *pPicPath0=\"Video[0]_picture0.yuv\";\n\tchar *pPicPath1=\"Video[1]_picture0.yuv\";\n\tchar *pPicPath2=\"Video[2]_picture0.yuv\";\n\tchar *pPicPath3=\"Video[3]_picture0.yuv\";\n\tchar *pPicPath4=\"Video[4]_picture0.yuv\";\n\tchar *pPicPath5=\"Video[5]_picture0.yuv\";\n\n\t\tReadPicFileContent(pPicPath0,&m_DispMemOps0,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath1,&m_DispMemOps1,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath2,&m_DispMemOps2,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath3,&m_DispMemOps3,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath4,&m_DispMemOps4,iSubWidth*iSubHeight*3/2);\n\t\tReadPicFileContent(pPicPath5,&m_DispMemOps5,iSubWidth*iSubHeight*3/2);\n\n\t\tallocPicMem(&m_DispMemOps,iWidth*iHeight*3/2);\n\t\tint outfd = m_DispMemOps.ion_buffer.fd_data.aw_fd;\n\t\tint infd[6];\n\t\tinfd[0] = m_DispMemOps0.ion_buffer.fd_data.aw_fd;\n\t\tinfd[1] = m_DispMemOps1.ion_buffer.fd_data.aw_fd;\n\t\tinfd[2] = m_DispMemOps2.ion_buffer.fd_data.aw_fd;\n\t\tinfd[3] = m_DispMemOps3.ion_buffer.fd_data.aw_fd;\n\t\tinfd[4] = m_DispMemOps4.ion_buffer.fd_data.aw_fd;\n\t\tinfd[5] = m_DispMemOps5.ion_buffer.fd_data.aw_fd;\n\t\tint ret = -1;\n\t\tret  = VTG2D_ClipByFd(infd[0],outfd,0,0);\n\t\tg2dClipByFd();\n\t\tret |= VTG2D_ClipByFd(infd[1],outfd,iSubWidth,0);\n\t\tret |= VTG2D_ClipByFd(infd[2],outfd,iSubWidth*2,0);\n\t\tret |= VTG2D_ClipByFd(infd[3],outfd,0,iSubHeight);\n\t\tret |= VTG2D_ClipByFd(infd[4],outfd,iSubWidth,iSubHeight);\n\t\tret |= VTG2D_ClipByFd(infd[5],outfd,iSubWidth*2,iSubHeight);\n\t\tWritePicFileContent(pcompPicPath0,&m_DispMemOps,iWidth*iHeight*3/2);\n\t\tfreePicMem(&m_DispMemOps);\n\t\tfreePicMem(&m_DispMemOps0);\n\t\tfreePicMem(&m_DispMemOps1);\n\t\tfreePicMem(&m_DispMemOps2);\n\t\tfreePicMem(&m_DispMemOps3);\n\t\tfreePicMem(&m_DispMemOps4);\n\t\tfreePicMem(&m_DispMemOps5);\n\treturn 1;\n}\n```\n\n注意：T5中不能进行缩放和格式转换。而且要求目标图像和源图像的分辨率必须相同。","slug":"3-G2D","published":1,"updated":"2023-04-14T10:20:11.322Z","_id":"clggksiep0007n0obbpfcealk","layout":"post","photos":[],"link":"","content":"<div align = \"center\">G2D</div>\n\n\n<h2 id=\"1-什么是跟g2d？\"><a href=\"#1-什么是跟g2d？\" class=\"headerlink\" title=\"1.什么是跟g2d？\"></a>1.什么是跟g2d？</h2><p>​\tG2D也就是我们说的2d加速。很久以前，绘图工作全部是由我们伟大而神圣的 CPU 来完成的，那时候的显卡，就是真正意义上用来“显示东西的卡”。它的工作就是把 CPU 处理好的数据“搬”到显示器上来。那时候 CPU 的工作可真是辛苦。现在好了，CPU 越来越快，可是做的工作却越来越少了。先来说说图形加速的几个阶段。2D 图像加速，Windows 加速 和 3D 图像加速。</p>\n<span id=\"more\"></span>\n\n<p>​\t2D 加速，是早就有的产物了。它的作用是用 显示芯片 来代替 CPU，整块整块的移动显存里的数据。比如，你要移动一个窗口，在没有 2D 加速的时代，CPU 所作的工作：1、找到窗口在显存中的地址，2、把一行数据拷贝到目的地址，3、重复 2 直到拷贝完所有的行。完成。这样一来，当窗口很大的时候，CPU 要处理的数据量就会成倍的增长，导致窗口的移动比蜗牛爬还慢…. 想体验一下吗？好，进入设备管理器，把你的显卡驱动删掉，然后重起…. 好好享受啊！呵呵 </p>\n<p>​\t有了 2D 加速呢，CPU 所做的事，减轻了很多，不过还是要指导 显示芯片 来干这搬运工的活。CPU 的工作：1、找到窗口在显存中的地址，2、给 显卡发送 “拷贝这一行到目的地”的命令。3、重复 2 直到拷贝完所有的行。初看起来好像和没有加速以前差不多，可是第 2 步就是关键所在哦。 </p>\n<p>​\t现在让我们把第二步分解来看：没有 2D 加速：1、读 32 Bit 数据(入门篇里的哦！)，把这 32 Bit 数据写入目的地。2、重复 1 直到一行所有的像素被处理完。而有了 2D 加速后的工作只有：1、发送命令让显卡去拷贝这一行。这样看来，2D 加速确实能很大程度的释放 CPU 的负担。所以大家现在随便提起一个窗口移动一下，很平滑不是吗？显卡负责了窗口的移动。</p>\n<h2 id=\"2-支持的功能有哪些\"><a href=\"#2-支持的功能有哪些\" class=\"headerlink\" title=\"2.支持的功能有哪些?\"></a>2.支持的功能有哪些?</h2><p>​\t转码，缩放，位块传输……(不同芯片支持的具体功能不尽相同)</p>\n<p><img src=\"/2023/04/14/3-G2D/1.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">支持图层大小最高至2048*2048像素点</span><br><span class=\"line\">支持输入/输出格式：YUV422（sp、planner）、YUV420（sp、planer）......</span><br><span class=\"line\">支持水平和垂直翻转，顺时针 0/90/180/270度 旋转</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-函数接口命令\"><a href=\"#3-函数接口命令\" class=\"headerlink\" title=\"3.函数接口命令\"></a>3.函数接口命令</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//fd:G2D设备文件标识符，cmd:命令码，arg:对应结构体指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ioctl</span><span class=\"params\">(<span class=\"type\">int</span> * fd, <span class=\"type\">int</span> cmd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//常见cmd功能、与结构体对应关系</span></span><br><span class=\"line\">G2D_CMD_BITBLT_H <span class=\"comment\">//实现单幅图的缩放，格式转换。实现foreground带缩放的ROP2处理 &gt;&gt; g2d_blt_h</span></span><br><span class=\"line\">G2D_CMD_BITBLT <span class=\"comment\">//实现两个图层的运算，如：源拷贝到目标；源旋转放入目标；源和目标做alpha blending /colorkey 后拷到目标。&gt;&gt; g2d_blt </span></span><br><span class=\"line\">G2D_CMD_STRETCHBLT\t<span class=\"comment\">//实现两个图层的运算，如：源缩放到目标大小后拷贝到目标；源缩放到目标大小后旋转放入目标；源缩放到目标大小后和目标做做alpha blending /colorkey 后拷到目标。&gt;&gt; g2d_stretchblt</span></span><br><span class=\"line\">G2D_CMD_MEM_REQUEST <span class=\"comment\">//为测试程序提供内存申请接口 &gt;&gt;arg为申请buffer的size</span></span><br><span class=\"line\">G2D_CMD_MEM_GETADR <span class=\"comment\">//为测试程序提供内存物理地址 &gt;&gt;arg为申请buffer的编号（1~10）</span></span><br><span class=\"line\">G2D_CMD_MEM_RELEALSE <span class=\"comment\">//为测试程序提供内存物理地址 &gt;&gt;arg为申请buffer的编号（1~10）</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t注意：G2D使用时，传入的地址只能是物理地址，不能是应用空间申请的虚拟地址。所以测试时，需要alloc_mem的方式申请一片内存空间，得到其物理地址，才能进行G2D调用。</p>\n<h2 id=\"4-数据结构\"><a href=\"#4-数据结构\" class=\"headerlink\" title=\"4.数据结构\"></a>4.数据结构</h2><h3 id=\"g2d-blt-h\"><a href=\"#g2d-blt-h\" class=\"headerlink\" title=\"g2d_blt_h\"></a>g2d_blt_h</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    g2d_blt_flags_h\tflag_h;<span class=\"comment\">//blt操作flag标志</span></span><br><span class=\"line\">    g2d_image_enh\tsrc_image_h;<span class=\"comment\">//源图像信息</span></span><br><span class=\"line\">    g2d_image_enh\tdst_image_h;<span class=\"comment\">//目标图像信息</span></span><br><span class=\"line\">    __u32\t\t\tcolor;<span class=\"comment\">//colorkey颜色</span></span><br><span class=\"line\">    __u32\t\t\talpha;<span class=\"comment\">//面alpha值</span></span><br><span class=\"line\">&#125; g2d_blt_h;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-blt\"><a href=\"#g2d-blt\" class=\"headerlink\" title=\"g2d_blt\"></a>g2d_blt</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    g2d_blt_flags\tflag;<span class=\"comment\">//blt操作flag标志</span></span><br><span class=\"line\">    g2d_image\t\tsrc_image;<span class=\"comment\">//源图像信息</span></span><br><span class=\"line\">    g2d_rect\t\tsrc_rect;<span class=\"comment\">//源矩形信息，x/y/w/h-左上角x/左上角y/宽/高</span></span><br><span class=\"line\">    g2d_image\t\tdst_image;<span class=\"comment\">//目标图像信息</span></span><br><span class=\"line\">    __s32\t\t\tdst_x;<span class=\"comment\">//目标矩阵左上角x</span></span><br><span class=\"line\">    __s32\t\t\tdst_y;<span class=\"comment\">//目标矩阵左上角y</span></span><br><span class=\"line\">    __u32\t\t\tcolor;<span class=\"comment\">//colorkey颜色</span></span><br><span class=\"line\">    __u32\t\t\talpha;<span class=\"comment\">//面alpha值</span></span><br><span class=\"line\">&#125;g2d_blt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-stretchblt\"><a href=\"#g2d-stretchblt\" class=\"headerlink\" title=\"g2d_stretchblt\"></a>g2d_stretchblt</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    g2d_blt_flags\tflag;<span class=\"comment\">//blt操作flag标志</span></span><br><span class=\"line\">    g2d_image\t\tsrc_image;<span class=\"comment\">//源图像信息</span></span><br><span class=\"line\">    g2d_rect\t\tsrc_rect;<span class=\"comment\">//源矩形信息，x/y/w/h-左上角x/左上角y/宽/高</span></span><br><span class=\"line\">    g2d_image\t\tdst_image;<span class=\"comment\">//目标图像信息</span></span><br><span class=\"line\">\tg2d_rect\t\tdst_rect;<span class=\"comment\">//目标矩形信息，x/y/w/h-左上角x/左上角y/宽/高</span></span><br><span class=\"line\">    __u32\t\t\tcolor;<span class=\"comment\">//colorkey颜色</span></span><br><span class=\"line\">    __u32\t\t\talpha;<span class=\"comment\">//面alpha值</span></span><br><span class=\"line\">&#125;g2d_stretchblt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-image\"><a href=\"#g2d-image\" class=\"headerlink\" title=\"g2d_image\"></a>g2d_image</h3><p>主要用于描述image属性信息</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    __u32\taddr[<span class=\"number\">3</span>];<span class=\"comment\">//图像帧的基地址，对于UV combined ，addr[0,1]有效，planner类型addr[0,1,2]有效，其他addr[0]有效</span></span><br><span class=\"line\">    __u32\tw;<span class=\"comment\">//图像帧的宽</span></span><br><span class=\"line\">    __u32\th;<span class=\"comment\">//图像帧的高</span></span><br><span class=\"line\">    g2d_data_fmt\tformat;<span class=\"comment\">//图像帧buffer的像素格式</span></span><br><span class=\"line\">    g2d_pixel_seq\tpixel_seq;<span class=\"comment\">//图像帧buffer的像素序列</span></span><br><span class=\"line\">&#125;g2d_image;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-image-enh\"><a href=\"#g2d-image-enh\" class=\"headerlink\" title=\"g2d_image_enh\"></a>g2d_image_enh</h3><p>​\t主要描述图片的宽高、存放地址、是否做Clip处理，是否为预乘等</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>\t\tbbuff;</span><br><span class=\"line\">    g2d_fmt_enh\tformat;<span class=\"comment\">//图格式</span></span><br><span class=\"line\">    __u32\tladdr[<span class=\"number\">3</span>];<span class=\"comment\">//起始低位地址</span></span><br><span class=\"line\">    __u32\thaddr[<span class=\"number\">3</span>];<span class=\"comment\">//起始高位地址</span></span><br><span class=\"line\">    __u32\twidth;<span class=\"comment\">//图宽</span></span><br><span class=\"line\">    __u32\theight;<span class=\"comment\">//图高</span></span><br><span class=\"line\">    __u32\talign[<span class=\"number\">3</span>];</span><br><span class=\"line\">    g2d_rect\t\tclip_rect;<span class=\"comment\">//ROI矩形</span></span><br><span class=\"line\">    __u32\tgamut;<span class=\"comment\">//图的色域</span></span><br><span class=\"line\">    <span class=\"type\">int</span>\t\tbpremul;<span class=\"comment\">//是否为预乘</span></span><br><span class=\"line\">    __u8\talpha;<span class=\"comment\">//面alpha值</span></span><br><span class=\"line\">    g2d_alpha_mode_enh\tmode;<span class=\"comment\">//alpha模式设置</span></span><br><span class=\"line\">&#125;g2d_image_enh;</span><br></pre></td></tr></table></figure>\n\n<p>​\tladdr以及haddr是针对32为以及64位处理器的一个适配，32位处理器只需要填充laddr，64位则需要填充laddr和haddr</p>\n<h3 id=\"g2d-blt-flags\"><a href=\"#g2d-blt-flags\" class=\"headerlink\" title=\"g2d_blt_flags\"></a>g2d_blt_flags</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</span><br><span class=\"line\">    G2D_BLT_NONE\t\t\t= <span class=\"number\">0x00000000</span>,<span class=\"comment\">//纯拷贝</span></span><br><span class=\"line\">    G2D_BLT_PIXEL_ALPHA\t\t= <span class=\"number\">0x00000001</span>,<span class=\"comment\">//点alpha标志</span></span><br><span class=\"line\">    G2D_BLT_PLANE_ALPHA \t= <span class=\"number\">0x00000002</span>,<span class=\"comment\">//面alpha标志</span></span><br><span class=\"line\">    G2D_BLT_MULTI_ALPHA \t=<span class=\"number\">0x00000004</span>,<span class=\"comment\">//混合alpha标志</span></span><br><span class=\"line\">    G2D_BLT_SRC_COLORKEY \t= <span class=\"number\">0x00000008</span>,<span class=\"comment\">//源colorkey标志</span></span><br><span class=\"line\">    G2D_BLT_DST_COLORKEY \t= <span class=\"number\">0x00000010</span>,<span class=\"comment\">//目标colorkey标志</span></span><br><span class=\"line\">    G2D_BLT_FLIP_HORIZONTAL = <span class=\"number\">0x00000020</span>,<span class=\"comment\">//水平翻转</span></span><br><span class=\"line\">    G2D_BLT_VERTICAL\t\t= <span class=\"number\">0x00000040</span>,<span class=\"comment\">//垂直翻转</span></span><br><span class=\"line\">    G2D_BLT_ROTATE90\t\t= <span class=\"number\">0x00000080</span>,<span class=\"comment\">//逆时针旋转90度</span></span><br><span class=\"line\">    G2D_BLT_ROTATE180 \t\t= <span class=\"number\">0x00000100</span>,<span class=\"comment\">//逆时针旋转180度</span></span><br><span class=\"line\">    G2D_BLT_ROTATE270 \t\t= <span class=\"number\">0x00000200</span>,<span class=\"comment\">//逆时针旋转270度</span></span><br><span class=\"line\">    G2D_BLT_MIRROR45 \t\t= <span class=\"number\">0x00000400</span>,<span class=\"comment\">//镜像45度</span></span><br><span class=\"line\">    G2D_BLT_MIRROR135\t\t = <span class=\"number\">0x00000800</span>,<span class=\"comment\">//镜像135度</span></span><br><span class=\"line\">&#125;g2d_blt_flags</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-blt-flags-h\"><a href=\"#g2d-blt-flags-h\" class=\"headerlink\" title=\"g2d_blt_flags_h\"></a>g2d_blt_flags_h</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-举例\"><a href=\"#5-举例\" class=\"headerlink\" title=\"5.举例\"></a>5.举例</h2><p>1.可参考虚拟机中…&#x2F;sdk_demo&#x2F;G2dDemo。</p>\n<p>2.也可参考全志G2D开发指南</p>\n<h3 id=\"1-旋转，缩放与格式转换\"><a href=\"#1-旋转，缩放与格式转换\" class=\"headerlink\" title=\"1.旋转，缩放与格式转换\"></a>1.旋转，缩放与格式转换</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g2d_blt_h blit;<span class=\"comment\">//实例化一个对象，进行参数填充</span></span><br><span class=\"line\"></span><br><span class=\"line\">blit.flag_h = G2D_BLT_NONE_0;<span class=\"comment\">//修改此参数实现旋转。如：G2D_ROT_90旋转90度</span></span><br><span class=\"line\">blit.src_image_h.fd = src_buffd;<span class=\"comment\">//源图像</span></span><br><span class=\"line\"><span class=\"comment\">//blit.src_image_h.format = G2D_FORMAT_YUV420_PLANAR;</span></span><br><span class=\"line\">blit.src_image_h.format = G2D_FORMAT_ARGB8888;</span><br><span class=\"line\">blit.src_image_h.mode = G2D_GLOBAL_ALPHA;</span><br><span class=\"line\">blit.src_image_h.clip_rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.src_image_h.clip_rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.src_image_h.clip_rect.w = <span class=\"number\">320</span>;</span><br><span class=\"line\">blit.src_image_h.clip_rect.h = <span class=\"number\">480</span>;</span><br><span class=\"line\"> blit.src_image_h.width = <span class=\"number\">320</span>;</span><br><span class=\"line\">blit.src_image_h.height = <span class=\"number\">480</span>;</span><br><span class=\"line\">blit.src_image_h.alpha = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">blit.dst_image_h.fd = dst_buffd;<span class=\"comment\">//目标图像</span></span><br><span class=\"line\"><span class=\"comment\">//blit.dst_image_h.format = G2D_FORMAT_YUV420_PLANAR;\t</span></span><br><span class=\"line\">blit.dst_image_h.format = G2D_FORMAT_ARGB8888;<span class=\"comment\">//修改此格式可改变输出格式</span></span><br><span class=\"line\">blit.dst_image_h.mode = G2D_GLOBAL_ALPHA;</span><br><span class=\"line\">blit.dst_image_h.clip_rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.dst_image_h.clip_rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.dst_image_h.clip_rect.w = <span class=\"number\">320</span>;<span class=\"comment\">//修改此参数可实现缩放</span></span><br><span class=\"line\">blit.dst_image_h.clip_rect.h = <span class=\"number\">480</span>;<span class=\"comment\">//修改此参数可实现缩放</span></span><br><span class=\"line\">blit.dst_image_h.alpha = <span class=\"number\">0xff</span>; </span><br><span class=\"line\">blit.dst_image_h.width = <span class=\"number\">320</span>;<span class=\"comment\">//与上保持一致</span></span><br><span class=\"line\">blit.dst_image_h.height = <span class=\"number\">480</span>;<span class=\"comment\">//与上保持一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">ioctl</span>(g2d_fd,  G2D_CMD_BITBLT_H ,(<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(&amp;blit)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%d][%s][%s]G2D_CMD_BITBLT_H failure!\\n&quot;</span>,__LINE__, __FILE__,__FUNCTION__);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-输入输出\"><a href=\"#2-输入输出\" class=\"headerlink\" title=\"2.输入输出\"></a>2.输入输出</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g2d_blt blit;</span><br><span class=\"line\"><span class=\"comment\">//设置BITBLT flag标志位</span></span><br><span class=\"line\">blit.color = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">blit.alpha = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">blit.flag = G2D_BLT_NONE;<span class=\"comment\">//纯拷贝</span></span><br><span class=\"line\"><span class=\"comment\">//设置源image和rect</span></span><br><span class=\"line\">blit.src_image.addr[<span class=\"number\">0</span>] = memin;</span><br><span class=\"line\">blit.src_image.w = <span class=\"number\">800</span>;</span><br><span class=\"line\">blit.src_image.h = <span class=\"number\">480</span>;</span><br><span class=\"line\">blit.src_image.format = G2D_FMT_RGBA8888;\t</span><br><span class=\"line\">blit.src_image.pixel_seq = G2D_SEQ_NORMAL;</span><br><span class=\"line\">blit.src_rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.src_rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.src_rect.w = <span class=\"number\">480</span>;</span><br><span class=\"line\">blit.src_rect.h = <span class=\"number\">272</span>;</span><br><span class=\"line\"><span class=\"comment\">//设置目标image和rect</span></span><br><span class=\"line\">blit.dst_image.addr[<span class=\"number\">0</span>] = memout;</span><br><span class=\"line\">blit.dst_image.w = <span class=\"number\">800</span>;</span><br><span class=\"line\">blit.dst_image.h = <span class=\"number\">480</span>;</span><br><span class=\"line\">blit.dst_image.format = G2D_FMT_RGBA8888;</span><br><span class=\"line\">blit.dst_image.pixel_seq = G2D_SEQ_NORMAL;</span><br><span class=\"line\">blit.dst_x = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.dst_y = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">ioctl</span>(g2d_fd, G2D_CMD_BITBLT, &amp;blit_para) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;G2D_CMD_BITBLT failure!\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-缩放\"><a href=\"#3-缩放\" class=\"headerlink\" title=\"3.缩放\"></a>3.缩放</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g2d_stretchblt scale;</span><br><span class=\"line\">\t<span class=\"type\">int</span> retval = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tscale.flag = G2D_BLT_NONE;</span><br><span class=\"line\">\tscale.src_image.addr[<span class=\"number\">0</span>] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)psrc;</span><br><span class=\"line\">\t<span class=\"comment\">//scale.src_image.addr[1] = (unsigned long)psrc + src_w * src_h;</span></span><br><span class=\"line\">\tscale.src_image.w = src_w;</span><br><span class=\"line\">\tscale.src_image.h = src_h;</span><br><span class=\"line\">\t<span class=\"comment\">//scale.src_image.format = G2D_FMT_PYUV420UVC;</span></span><br><span class=\"line\">\tscale.src_image.format = G2D_FMT_XRGB8888;</span><br><span class=\"line\">\tscale.src_image.pixel_seq = G2D_SEQ_NORMAL;</span><br><span class=\"line\">\tscale.src_rect.x = src_crop_x;</span><br><span class=\"line\">\tscale.src_rect.y = src_crop_y;</span><br><span class=\"line\">\tscale.src_rect.w = src_crop_w;</span><br><span class=\"line\">\tscale.src_rect.h = src_crop_h;</span><br><span class=\"line\">\tscale.dst_image.addr[<span class=\"number\">0</span>] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)pdst;</span><br><span class=\"line\">\t<span class=\"comment\">//scale.dst_image.addr[1] = (unsigned long)pdst + dst_w * dst_h;</span></span><br><span class=\"line\">\tscale.dst_image.w = dst_w;</span><br><span class=\"line\">\tscale.dst_image.h = dst_h;</span><br><span class=\"line\">\t<span class=\"comment\">//scale.dst_image.format = G2D_FMT_PYUV420UVC;\t</span></span><br><span class=\"line\">\tscale.dst_image.format = G2D_FMT_XRGB8888;</span><br><span class=\"line\">\tscale.dst_image.pixel_seq = G2D_SEQ_NORMAL;</span><br><span class=\"line\">\tscale.dst_rect.x = dst_crop_x;</span><br><span class=\"line\">\tscale.dst_rect.y = dst_crop_y;</span><br><span class=\"line\">\tscale.dst_rect.w = dst_crop_w;</span><br><span class=\"line\">\tscale.dst_rect.h = dst_crop_h;</span><br><span class=\"line\">\tscale.color = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">\tscale.alpha = <span class=\"number\">0xff</span>;\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ioctl</span>(g2d_fd,  G2D_CMD_STRETCHBLT ,(<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(&amp;scale)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%d][%s][%s]G2D_CMD_STRETCHBLT failure!\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t__LINE__, __FILE__,__FUNCTION__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-应用层申请内核地址的办法\"><a href=\"#6-应用层申请内核地址的办法\" class=\"headerlink\" title=\"6.应用层申请内核地址的办法\"></a>6.应用层申请内核地址的办法</h2><h3 id=\"1-G2D命令码\"><a href=\"#1-G2D命令码\" class=\"headerlink\" title=\"1.G2D命令码\"></a>1.G2D命令码</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">G2D_CMD_MEM_REQUEST <span class=\"comment\">//为测试程序提供内存申请接口 &gt;&gt;arg为申请buffer的size</span></span><br><span class=\"line\">G2D_CMD_MEM_GETADR <span class=\"comment\">//为测试程序提供内存物理地址 &gt;&gt;arg为申请buffer的编号（1~10）</span></span><br><span class=\"line\">G2D_CMD_MEM_RELEALSE <span class=\"comment\">//为测试程序提供内存物理地址 &gt;&gt;arg为申请buffer的编号（1~10）</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-alloc-mem\"><a href=\"#2-alloc-mem\" class=\"headerlink\" title=\"2.alloc_mem\"></a>2.alloc_mem</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如：****alloc_buffer-&gt;phy = 0xfa200000,alloc_buffer-&gt;vir = 0x7f71081000</span></span><br></pre></td></tr></table></figure>\n\n<p>参考：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;sunxiMemInterface.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;G2dApi.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">VTint32 <span class=\"title\">VTG2D_ClipByFd</span><span class=\"params\">(VTint32 src_buffd, VTint32 dst_buffd,VTint32 dst_x,VTint32 dst_y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tg2d_blt_h blit;</span><br><span class=\"line\"></span><br><span class=\"line\">\tblit.flag_h = G2D_ROT_0;<span class=\"comment\">//G2D_BLT_NONE_H</span></span><br><span class=\"line\">\tblit.src_image_h.fd = src_buffd;</span><br><span class=\"line\">\tblit.src_image_h.format = G2D_FORMAT_YUV420UVC_U1V1U0V0;<span class=\"comment\">//NV12</span></span><br><span class=\"line\">\tblit.src_image_h.mode = G2D_GLOBAL_ALPHA;</span><br><span class=\"line\">\tblit.src_image_h.clip_rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tblit.src_image_h.clip_rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tblit.src_image_h.clip_rect.w = <span class=\"number\">1280</span>;</span><br><span class=\"line\">\tblit.src_image_h.clip_rect.h = <span class=\"number\">720</span>;</span><br><span class=\"line\">\tblit.src_image_h.width = <span class=\"number\">1280</span>;</span><br><span class=\"line\">\tblit.src_image_h.height = <span class=\"number\">720</span>;</span><br><span class=\"line\">\tblit.src_image_h.alpha = <span class=\"number\">0xff</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">\tblit.src_image_h.fd = dst_buffd;</span><br><span class=\"line\">\tblit.dst_image_h.format = G2D_FORMAT_YUV420UVC_U1V1U0V0;\t</span><br><span class=\"line\">\tblit.dst_image_h.mode = G2D_GLOBAL_ALPHA;</span><br><span class=\"line\">\tblit.dst_image_h.clip_rect.x = dst_x;</span><br><span class=\"line\">\tblit.dst_image_h.clip_rect.y = dst_y;</span><br><span class=\"line\">\tblit.dst_image_h.clip_rect.w = <span class=\"number\">1280</span>;</span><br><span class=\"line\">\tblit.dst_image_h.clip_rect.h = <span class=\"number\">720</span>;</span><br><span class=\"line\">\tblit.dst_image_h.width = <span class=\"number\">3840</span>;</span><br><span class=\"line\">\tblit.dst_image_h.height = <span class=\"number\">1440</span>;</span><br><span class=\"line\">\tblit.dst_image_h.alpha = <span class=\"number\">0xff</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ioctl</span>(g2d_fd,  G2D_CMD_BITBLT_H ,(<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(&amp;blit)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%d][%s][%s]G2D_CMD_BITBLT_H failure!\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t__LINE__, __FILE__,__FUNCTION__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">allocPicMem</span><span class=\"params\">(paramStruct_t*pops,<span class=\"type\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> iRet = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    iRet = <span class=\"built_in\">allocOpen</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iRet &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ion_alloc_open failed\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> iRet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pops-&gt;size =size;</span><br><span class=\"line\">    iRet = <span class=\"built_in\">allocAlloc</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(iRet &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;allocAlloc failed\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> iRet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">freePicMem</span><span class=\"params\">(paramStruct_t*pops)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> iRet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">allocFree</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ReadPicFileContent</span><span class=\"params\">(<span class=\"type\">char</span> *pPicPath,paramStruct_t*pops,<span class=\"type\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">allocPicMem</span>(pops,size);</span><br><span class=\"line\"></span><br><span class=\"line\">    FILE *fpff = <span class=\"built_in\">fopen</span>(pPicPath, <span class=\"string\">&quot;rb&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == fpff) &#123;</span><br><span class=\"line\">        fpff = <span class=\"built_in\">fopen</span>(pPicPath, <span class=\"string\">&quot;rb&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == fpff) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s ERR \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">            <span class=\"built_in\">allocFree</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s OK \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">            <span class=\"built_in\">fread</span>((<span class=\"type\">void</span> *)pops-&gt;vir, <span class=\"number\">1</span>, size, fpff);</span><br><span class=\"line\">            <span class=\"built_in\">fclose</span>(fpff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s OK \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">        <span class=\"built_in\">fread</span>((<span class=\"type\">void</span> *)pops-&gt;vir, <span class=\"number\">1</span>, size, fpff);</span><br><span class=\"line\">        <span class=\"built_in\">fclose</span>(fpff);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"built_in\">flushCache</span>(MEM_TYPE_CDX_NEW,pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WritePicFileContent</span><span class=\"params\">(<span class=\"type\">char</span> *pPicPath,paramStruct_t*pops,<span class=\"type\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> iRet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;WritePicFileContent size=%d \\n&quot;</span>,size);</span><br><span class=\"line\">\t<span class=\"built_in\">flushCache</span>(MEM_TYPE_CDX_NEW,pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    FILE *fpff = <span class=\"built_in\">fopen</span>(pPicPath, <span class=\"string\">&quot;wb&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == fpff) &#123;</span><br><span class=\"line\">        fpff = <span class=\"built_in\">fopen</span>(pPicPath, <span class=\"string\">&quot;wb&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == fpff) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s ERR \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">            <span class=\"built_in\">allocFree</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s OK \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">            <span class=\"built_in\">fwrite</span>((<span class=\"type\">void</span> *)pops-&gt;vir, <span class=\"number\">1</span>, size, fpff);</span><br><span class=\"line\">            <span class=\"built_in\">fclose</span>(fpff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s OK \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">        <span class=\"built_in\">fwrite</span>((<span class=\"type\">void</span> *)pops-&gt;vir, <span class=\"number\">1</span>, size, fpff);</span><br><span class=\"line\">        <span class=\"built_in\">fclose</span>(fpff);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">VT_G2D_6in1compose</span><span class=\"params\">(<span class=\"type\">int</span> iSubWidth,<span class=\"type\">int</span> iSubHeight,<span class=\"type\">int</span> iWidth,<span class=\"type\">int</span> iHeight)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps0;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps1;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps2;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps3;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps4;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps5;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pcompPicPath0=<span class=\"string\">&quot;cvideo.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath0=<span class=\"string\">&quot;Video[0]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath1=<span class=\"string\">&quot;Video[1]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath2=<span class=\"string\">&quot;Video[2]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath3=<span class=\"string\">&quot;Video[3]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath4=<span class=\"string\">&quot;Video[4]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath5=<span class=\"string\">&quot;Video[5]_picture0.yuv&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath0,&amp;m_DispMemOps0,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath1,&amp;m_DispMemOps1,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath2,&amp;m_DispMemOps2,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath3,&amp;m_DispMemOps3,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath4,&amp;m_DispMemOps4,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath5,&amp;m_DispMemOps5,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">allocPicMem</span>(&amp;m_DispMemOps,iWidth*iHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> outfd = m_DispMemOps.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> infd[<span class=\"number\">6</span>];</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">0</span>] = m_DispMemOps0.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">1</span>] = m_DispMemOps1.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">2</span>] = m_DispMemOps2.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">3</span>] = m_DispMemOps3.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">4</span>] = m_DispMemOps4.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">5</span>] = m_DispMemOps5.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tret  = <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">0</span>],outfd,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">g2dClipByFd</span>();</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">1</span>],outfd,iSubWidth,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">2</span>],outfd,iSubWidth*<span class=\"number\">2</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">3</span>],outfd,<span class=\"number\">0</span>,iSubHeight);</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">4</span>],outfd,iSubWidth,iSubHeight);</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">5</span>],outfd,iSubWidth*<span class=\"number\">2</span>,iSubHeight);</span><br><span class=\"line\">\t\t<span class=\"built_in\">WritePicFileContent</span>(pcompPicPath0,&amp;m_DispMemOps,iWidth*iHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps0);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps2);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps3);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps4);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps5);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：T5中不能进行缩放和格式转换。而且要求目标图像和源图像的分辨率必须相同。</p>\n","site":{"data":{"style":""}},"length":12020,"excerpt":"<div align = \"center\">G2D</div>\n\n\n<h2 id=\"1-什么是跟g2d？\"><a href=\"#1-什么是跟g2d？\" class=\"headerlink\" title=\"1.什么是跟g2d？\"></a>1.什么是跟g2d？</h2><p>​\tG2D也就是我们说的2d加速。很久以前，绘图工作全部是由我们伟大而神圣的 CPU 来完成的，那时候的显卡，就是真正意义上用来“显示东西的卡”。它的工作就是把 CPU 处理好的数据“搬”到显示器上来。那时候 CPU 的工作可真是辛苦。现在好了，CPU 越来越快，可是做的工作却越来越少了。先来说说图形加速的几个阶段。2D 图像加速，Windows 加速 和 3D 图像加速。</p>","more":"<p>​\t2D 加速，是早就有的产物了。它的作用是用 显示芯片 来代替 CPU，整块整块的移动显存里的数据。比如，你要移动一个窗口，在没有 2D 加速的时代，CPU 所作的工作：1、找到窗口在显存中的地址，2、把一行数据拷贝到目的地址，3、重复 2 直到拷贝完所有的行。完成。这样一来，当窗口很大的时候，CPU 要处理的数据量就会成倍的增长，导致窗口的移动比蜗牛爬还慢…. 想体验一下吗？好，进入设备管理器，把你的显卡驱动删掉，然后重起…. 好好享受啊！呵呵 </p>\n<p>​\t有了 2D 加速呢，CPU 所做的事，减轻了很多，不过还是要指导 显示芯片 来干这搬运工的活。CPU 的工作：1、找到窗口在显存中的地址，2、给 显卡发送 “拷贝这一行到目的地”的命令。3、重复 2 直到拷贝完所有的行。初看起来好像和没有加速以前差不多，可是第 2 步就是关键所在哦。 </p>\n<p>​\t现在让我们把第二步分解来看：没有 2D 加速：1、读 32 Bit 数据(入门篇里的哦！)，把这 32 Bit 数据写入目的地。2、重复 1 直到一行所有的像素被处理完。而有了 2D 加速后的工作只有：1、发送命令让显卡去拷贝这一行。这样看来，2D 加速确实能很大程度的释放 CPU 的负担。所以大家现在随便提起一个窗口移动一下，很平滑不是吗？显卡负责了窗口的移动。</p>\n<h2 id=\"2-支持的功能有哪些\"><a href=\"#2-支持的功能有哪些\" class=\"headerlink\" title=\"2.支持的功能有哪些?\"></a>2.支持的功能有哪些?</h2><p>​\t转码，缩放，位块传输……(不同芯片支持的具体功能不尽相同)</p>\n<p><img src=\"/2023/04/14/3-G2D/1.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">支持图层大小最高至2048*2048像素点</span><br><span class=\"line\">支持输入/输出格式：YUV422（sp、planner）、YUV420（sp、planer）......</span><br><span class=\"line\">支持水平和垂直翻转，顺时针 0/90/180/270度 旋转</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-函数接口命令\"><a href=\"#3-函数接口命令\" class=\"headerlink\" title=\"3.函数接口命令\"></a>3.函数接口命令</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//fd:G2D设备文件标识符，cmd:命令码，arg:对应结构体指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ioctl</span><span class=\"params\">(<span class=\"type\">int</span> * fd, <span class=\"type\">int</span> cmd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> arg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//常见cmd功能、与结构体对应关系</span></span><br><span class=\"line\">G2D_CMD_BITBLT_H <span class=\"comment\">//实现单幅图的缩放，格式转换。实现foreground带缩放的ROP2处理 &gt;&gt; g2d_blt_h</span></span><br><span class=\"line\">G2D_CMD_BITBLT <span class=\"comment\">//实现两个图层的运算，如：源拷贝到目标；源旋转放入目标；源和目标做alpha blending /colorkey 后拷到目标。&gt;&gt; g2d_blt </span></span><br><span class=\"line\">G2D_CMD_STRETCHBLT\t<span class=\"comment\">//实现两个图层的运算，如：源缩放到目标大小后拷贝到目标；源缩放到目标大小后旋转放入目标；源缩放到目标大小后和目标做做alpha blending /colorkey 后拷到目标。&gt;&gt; g2d_stretchblt</span></span><br><span class=\"line\">G2D_CMD_MEM_REQUEST <span class=\"comment\">//为测试程序提供内存申请接口 &gt;&gt;arg为申请buffer的size</span></span><br><span class=\"line\">G2D_CMD_MEM_GETADR <span class=\"comment\">//为测试程序提供内存物理地址 &gt;&gt;arg为申请buffer的编号（1~10）</span></span><br><span class=\"line\">G2D_CMD_MEM_RELEALSE <span class=\"comment\">//为测试程序提供内存物理地址 &gt;&gt;arg为申请buffer的编号（1~10）</span></span><br></pre></td></tr></table></figure>\n\n<p>​\t注意：G2D使用时，传入的地址只能是物理地址，不能是应用空间申请的虚拟地址。所以测试时，需要alloc_mem的方式申请一片内存空间，得到其物理地址，才能进行G2D调用。</p>\n<h2 id=\"4-数据结构\"><a href=\"#4-数据结构\" class=\"headerlink\" title=\"4.数据结构\"></a>4.数据结构</h2><h3 id=\"g2d-blt-h\"><a href=\"#g2d-blt-h\" class=\"headerlink\" title=\"g2d_blt_h\"></a>g2d_blt_h</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    g2d_blt_flags_h\tflag_h;<span class=\"comment\">//blt操作flag标志</span></span><br><span class=\"line\">    g2d_image_enh\tsrc_image_h;<span class=\"comment\">//源图像信息</span></span><br><span class=\"line\">    g2d_image_enh\tdst_image_h;<span class=\"comment\">//目标图像信息</span></span><br><span class=\"line\">    __u32\t\t\tcolor;<span class=\"comment\">//colorkey颜色</span></span><br><span class=\"line\">    __u32\t\t\talpha;<span class=\"comment\">//面alpha值</span></span><br><span class=\"line\">&#125; g2d_blt_h;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-blt\"><a href=\"#g2d-blt\" class=\"headerlink\" title=\"g2d_blt\"></a>g2d_blt</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    g2d_blt_flags\tflag;<span class=\"comment\">//blt操作flag标志</span></span><br><span class=\"line\">    g2d_image\t\tsrc_image;<span class=\"comment\">//源图像信息</span></span><br><span class=\"line\">    g2d_rect\t\tsrc_rect;<span class=\"comment\">//源矩形信息，x/y/w/h-左上角x/左上角y/宽/高</span></span><br><span class=\"line\">    g2d_image\t\tdst_image;<span class=\"comment\">//目标图像信息</span></span><br><span class=\"line\">    __s32\t\t\tdst_x;<span class=\"comment\">//目标矩阵左上角x</span></span><br><span class=\"line\">    __s32\t\t\tdst_y;<span class=\"comment\">//目标矩阵左上角y</span></span><br><span class=\"line\">    __u32\t\t\tcolor;<span class=\"comment\">//colorkey颜色</span></span><br><span class=\"line\">    __u32\t\t\talpha;<span class=\"comment\">//面alpha值</span></span><br><span class=\"line\">&#125;g2d_blt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-stretchblt\"><a href=\"#g2d-stretchblt\" class=\"headerlink\" title=\"g2d_stretchblt\"></a>g2d_stretchblt</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    g2d_blt_flags\tflag;<span class=\"comment\">//blt操作flag标志</span></span><br><span class=\"line\">    g2d_image\t\tsrc_image;<span class=\"comment\">//源图像信息</span></span><br><span class=\"line\">    g2d_rect\t\tsrc_rect;<span class=\"comment\">//源矩形信息，x/y/w/h-左上角x/左上角y/宽/高</span></span><br><span class=\"line\">    g2d_image\t\tdst_image;<span class=\"comment\">//目标图像信息</span></span><br><span class=\"line\">\tg2d_rect\t\tdst_rect;<span class=\"comment\">//目标矩形信息，x/y/w/h-左上角x/左上角y/宽/高</span></span><br><span class=\"line\">    __u32\t\t\tcolor;<span class=\"comment\">//colorkey颜色</span></span><br><span class=\"line\">    __u32\t\t\talpha;<span class=\"comment\">//面alpha值</span></span><br><span class=\"line\">&#125;g2d_stretchblt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-image\"><a href=\"#g2d-image\" class=\"headerlink\" title=\"g2d_image\"></a>g2d_image</h3><p>主要用于描述image属性信息</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    __u32\taddr[<span class=\"number\">3</span>];<span class=\"comment\">//图像帧的基地址，对于UV combined ，addr[0,1]有效，planner类型addr[0,1,2]有效，其他addr[0]有效</span></span><br><span class=\"line\">    __u32\tw;<span class=\"comment\">//图像帧的宽</span></span><br><span class=\"line\">    __u32\th;<span class=\"comment\">//图像帧的高</span></span><br><span class=\"line\">    g2d_data_fmt\tformat;<span class=\"comment\">//图像帧buffer的像素格式</span></span><br><span class=\"line\">    g2d_pixel_seq\tpixel_seq;<span class=\"comment\">//图像帧buffer的像素序列</span></span><br><span class=\"line\">&#125;g2d_image;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-image-enh\"><a href=\"#g2d-image-enh\" class=\"headerlink\" title=\"g2d_image_enh\"></a>g2d_image_enh</h3><p>​\t主要描述图片的宽高、存放地址、是否做Clip处理，是否为预乘等</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>\t\tbbuff;</span><br><span class=\"line\">    g2d_fmt_enh\tformat;<span class=\"comment\">//图格式</span></span><br><span class=\"line\">    __u32\tladdr[<span class=\"number\">3</span>];<span class=\"comment\">//起始低位地址</span></span><br><span class=\"line\">    __u32\thaddr[<span class=\"number\">3</span>];<span class=\"comment\">//起始高位地址</span></span><br><span class=\"line\">    __u32\twidth;<span class=\"comment\">//图宽</span></span><br><span class=\"line\">    __u32\theight;<span class=\"comment\">//图高</span></span><br><span class=\"line\">    __u32\talign[<span class=\"number\">3</span>];</span><br><span class=\"line\">    g2d_rect\t\tclip_rect;<span class=\"comment\">//ROI矩形</span></span><br><span class=\"line\">    __u32\tgamut;<span class=\"comment\">//图的色域</span></span><br><span class=\"line\">    <span class=\"type\">int</span>\t\tbpremul;<span class=\"comment\">//是否为预乘</span></span><br><span class=\"line\">    __u8\talpha;<span class=\"comment\">//面alpha值</span></span><br><span class=\"line\">    g2d_alpha_mode_enh\tmode;<span class=\"comment\">//alpha模式设置</span></span><br><span class=\"line\">&#125;g2d_image_enh;</span><br></pre></td></tr></table></figure>\n\n<p>​\tladdr以及haddr是针对32为以及64位处理器的一个适配，32位处理器只需要填充laddr，64位则需要填充laddr和haddr</p>\n<h3 id=\"g2d-blt-flags\"><a href=\"#g2d-blt-flags\" class=\"headerlink\" title=\"g2d_blt_flags\"></a>g2d_blt_flags</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span>&#123;</span><br><span class=\"line\">    G2D_BLT_NONE\t\t\t= <span class=\"number\">0x00000000</span>,<span class=\"comment\">//纯拷贝</span></span><br><span class=\"line\">    G2D_BLT_PIXEL_ALPHA\t\t= <span class=\"number\">0x00000001</span>,<span class=\"comment\">//点alpha标志</span></span><br><span class=\"line\">    G2D_BLT_PLANE_ALPHA \t= <span class=\"number\">0x00000002</span>,<span class=\"comment\">//面alpha标志</span></span><br><span class=\"line\">    G2D_BLT_MULTI_ALPHA \t=<span class=\"number\">0x00000004</span>,<span class=\"comment\">//混合alpha标志</span></span><br><span class=\"line\">    G2D_BLT_SRC_COLORKEY \t= <span class=\"number\">0x00000008</span>,<span class=\"comment\">//源colorkey标志</span></span><br><span class=\"line\">    G2D_BLT_DST_COLORKEY \t= <span class=\"number\">0x00000010</span>,<span class=\"comment\">//目标colorkey标志</span></span><br><span class=\"line\">    G2D_BLT_FLIP_HORIZONTAL = <span class=\"number\">0x00000020</span>,<span class=\"comment\">//水平翻转</span></span><br><span class=\"line\">    G2D_BLT_VERTICAL\t\t= <span class=\"number\">0x00000040</span>,<span class=\"comment\">//垂直翻转</span></span><br><span class=\"line\">    G2D_BLT_ROTATE90\t\t= <span class=\"number\">0x00000080</span>,<span class=\"comment\">//逆时针旋转90度</span></span><br><span class=\"line\">    G2D_BLT_ROTATE180 \t\t= <span class=\"number\">0x00000100</span>,<span class=\"comment\">//逆时针旋转180度</span></span><br><span class=\"line\">    G2D_BLT_ROTATE270 \t\t= <span class=\"number\">0x00000200</span>,<span class=\"comment\">//逆时针旋转270度</span></span><br><span class=\"line\">    G2D_BLT_MIRROR45 \t\t= <span class=\"number\">0x00000400</span>,<span class=\"comment\">//镜像45度</span></span><br><span class=\"line\">    G2D_BLT_MIRROR135\t\t = <span class=\"number\">0x00000800</span>,<span class=\"comment\">//镜像135度</span></span><br><span class=\"line\">&#125;g2d_blt_flags</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"g2d-blt-flags-h\"><a href=\"#g2d-blt-flags-h\" class=\"headerlink\" title=\"g2d_blt_flags_h\"></a>g2d_blt_flags_h</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"5-举例\"><a href=\"#5-举例\" class=\"headerlink\" title=\"5.举例\"></a>5.举例</h2><p>1.可参考虚拟机中…&#x2F;sdk_demo&#x2F;G2dDemo。</p>\n<p>2.也可参考全志G2D开发指南</p>\n<h3 id=\"1-旋转，缩放与格式转换\"><a href=\"#1-旋转，缩放与格式转换\" class=\"headerlink\" title=\"1.旋转，缩放与格式转换\"></a>1.旋转，缩放与格式转换</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g2d_blt_h blit;<span class=\"comment\">//实例化一个对象，进行参数填充</span></span><br><span class=\"line\"></span><br><span class=\"line\">blit.flag_h = G2D_BLT_NONE_0;<span class=\"comment\">//修改此参数实现旋转。如：G2D_ROT_90旋转90度</span></span><br><span class=\"line\">blit.src_image_h.fd = src_buffd;<span class=\"comment\">//源图像</span></span><br><span class=\"line\"><span class=\"comment\">//blit.src_image_h.format = G2D_FORMAT_YUV420_PLANAR;</span></span><br><span class=\"line\">blit.src_image_h.format = G2D_FORMAT_ARGB8888;</span><br><span class=\"line\">blit.src_image_h.mode = G2D_GLOBAL_ALPHA;</span><br><span class=\"line\">blit.src_image_h.clip_rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.src_image_h.clip_rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.src_image_h.clip_rect.w = <span class=\"number\">320</span>;</span><br><span class=\"line\">blit.src_image_h.clip_rect.h = <span class=\"number\">480</span>;</span><br><span class=\"line\"> blit.src_image_h.width = <span class=\"number\">320</span>;</span><br><span class=\"line\">blit.src_image_h.height = <span class=\"number\">480</span>;</span><br><span class=\"line\">blit.src_image_h.alpha = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">blit.dst_image_h.fd = dst_buffd;<span class=\"comment\">//目标图像</span></span><br><span class=\"line\"><span class=\"comment\">//blit.dst_image_h.format = G2D_FORMAT_YUV420_PLANAR;\t</span></span><br><span class=\"line\">blit.dst_image_h.format = G2D_FORMAT_ARGB8888;<span class=\"comment\">//修改此格式可改变输出格式</span></span><br><span class=\"line\">blit.dst_image_h.mode = G2D_GLOBAL_ALPHA;</span><br><span class=\"line\">blit.dst_image_h.clip_rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.dst_image_h.clip_rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.dst_image_h.clip_rect.w = <span class=\"number\">320</span>;<span class=\"comment\">//修改此参数可实现缩放</span></span><br><span class=\"line\">blit.dst_image_h.clip_rect.h = <span class=\"number\">480</span>;<span class=\"comment\">//修改此参数可实现缩放</span></span><br><span class=\"line\">blit.dst_image_h.alpha = <span class=\"number\">0xff</span>; </span><br><span class=\"line\">blit.dst_image_h.width = <span class=\"number\">320</span>;<span class=\"comment\">//与上保持一致</span></span><br><span class=\"line\">blit.dst_image_h.height = <span class=\"number\">480</span>;<span class=\"comment\">//与上保持一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">ioctl</span>(g2d_fd,  G2D_CMD_BITBLT_H ,(<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(&amp;blit)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%d][%s][%s]G2D_CMD_BITBLT_H failure!\\n&quot;</span>,__LINE__, __FILE__,__FUNCTION__);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-输入输出\"><a href=\"#2-输入输出\" class=\"headerlink\" title=\"2.输入输出\"></a>2.输入输出</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g2d_blt blit;</span><br><span class=\"line\"><span class=\"comment\">//设置BITBLT flag标志位</span></span><br><span class=\"line\">blit.color = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">blit.alpha = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">blit.flag = G2D_BLT_NONE;<span class=\"comment\">//纯拷贝</span></span><br><span class=\"line\"><span class=\"comment\">//设置源image和rect</span></span><br><span class=\"line\">blit.src_image.addr[<span class=\"number\">0</span>] = memin;</span><br><span class=\"line\">blit.src_image.w = <span class=\"number\">800</span>;</span><br><span class=\"line\">blit.src_image.h = <span class=\"number\">480</span>;</span><br><span class=\"line\">blit.src_image.format = G2D_FMT_RGBA8888;\t</span><br><span class=\"line\">blit.src_image.pixel_seq = G2D_SEQ_NORMAL;</span><br><span class=\"line\">blit.src_rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.src_rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.src_rect.w = <span class=\"number\">480</span>;</span><br><span class=\"line\">blit.src_rect.h = <span class=\"number\">272</span>;</span><br><span class=\"line\"><span class=\"comment\">//设置目标image和rect</span></span><br><span class=\"line\">blit.dst_image.addr[<span class=\"number\">0</span>] = memout;</span><br><span class=\"line\">blit.dst_image.w = <span class=\"number\">800</span>;</span><br><span class=\"line\">blit.dst_image.h = <span class=\"number\">480</span>;</span><br><span class=\"line\">blit.dst_image.format = G2D_FMT_RGBA8888;</span><br><span class=\"line\">blit.dst_image.pixel_seq = G2D_SEQ_NORMAL;</span><br><span class=\"line\">blit.dst_x = <span class=\"number\">0</span>;</span><br><span class=\"line\">blit.dst_y = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">ioctl</span>(g2d_fd, G2D_CMD_BITBLT, &amp;blit_para) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;G2D_CMD_BITBLT failure!\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-缩放\"><a href=\"#3-缩放\" class=\"headerlink\" title=\"3.缩放\"></a>3.缩放</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g2d_stretchblt scale;</span><br><span class=\"line\">\t<span class=\"type\">int</span> retval = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tscale.flag = G2D_BLT_NONE;</span><br><span class=\"line\">\tscale.src_image.addr[<span class=\"number\">0</span>] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)psrc;</span><br><span class=\"line\">\t<span class=\"comment\">//scale.src_image.addr[1] = (unsigned long)psrc + src_w * src_h;</span></span><br><span class=\"line\">\tscale.src_image.w = src_w;</span><br><span class=\"line\">\tscale.src_image.h = src_h;</span><br><span class=\"line\">\t<span class=\"comment\">//scale.src_image.format = G2D_FMT_PYUV420UVC;</span></span><br><span class=\"line\">\tscale.src_image.format = G2D_FMT_XRGB8888;</span><br><span class=\"line\">\tscale.src_image.pixel_seq = G2D_SEQ_NORMAL;</span><br><span class=\"line\">\tscale.src_rect.x = src_crop_x;</span><br><span class=\"line\">\tscale.src_rect.y = src_crop_y;</span><br><span class=\"line\">\tscale.src_rect.w = src_crop_w;</span><br><span class=\"line\">\tscale.src_rect.h = src_crop_h;</span><br><span class=\"line\">\tscale.dst_image.addr[<span class=\"number\">0</span>] = (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)pdst;</span><br><span class=\"line\">\t<span class=\"comment\">//scale.dst_image.addr[1] = (unsigned long)pdst + dst_w * dst_h;</span></span><br><span class=\"line\">\tscale.dst_image.w = dst_w;</span><br><span class=\"line\">\tscale.dst_image.h = dst_h;</span><br><span class=\"line\">\t<span class=\"comment\">//scale.dst_image.format = G2D_FMT_PYUV420UVC;\t</span></span><br><span class=\"line\">\tscale.dst_image.format = G2D_FMT_XRGB8888;</span><br><span class=\"line\">\tscale.dst_image.pixel_seq = G2D_SEQ_NORMAL;</span><br><span class=\"line\">\tscale.dst_rect.x = dst_crop_x;</span><br><span class=\"line\">\tscale.dst_rect.y = dst_crop_y;</span><br><span class=\"line\">\tscale.dst_rect.w = dst_crop_w;</span><br><span class=\"line\">\tscale.dst_rect.h = dst_crop_h;</span><br><span class=\"line\">\tscale.color = <span class=\"number\">0xff</span>;</span><br><span class=\"line\">\tscale.alpha = <span class=\"number\">0xff</span>;\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ioctl</span>(g2d_fd,  G2D_CMD_STRETCHBLT ,(<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(&amp;scale)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%d][%s][%s]G2D_CMD_STRETCHBLT failure!\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t__LINE__, __FILE__,__FUNCTION__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-应用层申请内核地址的办法\"><a href=\"#6-应用层申请内核地址的办法\" class=\"headerlink\" title=\"6.应用层申请内核地址的办法\"></a>6.应用层申请内核地址的办法</h2><h3 id=\"1-G2D命令码\"><a href=\"#1-G2D命令码\" class=\"headerlink\" title=\"1.G2D命令码\"></a>1.G2D命令码</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">G2D_CMD_MEM_REQUEST <span class=\"comment\">//为测试程序提供内存申请接口 &gt;&gt;arg为申请buffer的size</span></span><br><span class=\"line\">G2D_CMD_MEM_GETADR <span class=\"comment\">//为测试程序提供内存物理地址 &gt;&gt;arg为申请buffer的编号（1~10）</span></span><br><span class=\"line\">G2D_CMD_MEM_RELEALSE <span class=\"comment\">//为测试程序提供内存物理地址 &gt;&gt;arg为申请buffer的编号（1~10）</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-alloc-mem\"><a href=\"#2-alloc-mem\" class=\"headerlink\" title=\"2.alloc_mem\"></a>2.alloc_mem</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如：****alloc_buffer-&gt;phy = 0xfa200000,alloc_buffer-&gt;vir = 0x7f71081000</span></span><br></pre></td></tr></table></figure>\n\n<p>参考：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;sunxiMemInterface.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;G2dApi.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">VTint32 <span class=\"title\">VTG2D_ClipByFd</span><span class=\"params\">(VTint32 src_buffd, VTint32 dst_buffd,VTint32 dst_x,VTint32 dst_y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tg2d_blt_h blit;</span><br><span class=\"line\"></span><br><span class=\"line\">\tblit.flag_h = G2D_ROT_0;<span class=\"comment\">//G2D_BLT_NONE_H</span></span><br><span class=\"line\">\tblit.src_image_h.fd = src_buffd;</span><br><span class=\"line\">\tblit.src_image_h.format = G2D_FORMAT_YUV420UVC_U1V1U0V0;<span class=\"comment\">//NV12</span></span><br><span class=\"line\">\tblit.src_image_h.mode = G2D_GLOBAL_ALPHA;</span><br><span class=\"line\">\tblit.src_image_h.clip_rect.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tblit.src_image_h.clip_rect.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tblit.src_image_h.clip_rect.w = <span class=\"number\">1280</span>;</span><br><span class=\"line\">\tblit.src_image_h.clip_rect.h = <span class=\"number\">720</span>;</span><br><span class=\"line\">\tblit.src_image_h.width = <span class=\"number\">1280</span>;</span><br><span class=\"line\">\tblit.src_image_h.height = <span class=\"number\">720</span>;</span><br><span class=\"line\">\tblit.src_image_h.alpha = <span class=\"number\">0xff</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">\tblit.src_image_h.fd = dst_buffd;</span><br><span class=\"line\">\tblit.dst_image_h.format = G2D_FORMAT_YUV420UVC_U1V1U0V0;\t</span><br><span class=\"line\">\tblit.dst_image_h.mode = G2D_GLOBAL_ALPHA;</span><br><span class=\"line\">\tblit.dst_image_h.clip_rect.x = dst_x;</span><br><span class=\"line\">\tblit.dst_image_h.clip_rect.y = dst_y;</span><br><span class=\"line\">\tblit.dst_image_h.clip_rect.w = <span class=\"number\">1280</span>;</span><br><span class=\"line\">\tblit.dst_image_h.clip_rect.h = <span class=\"number\">720</span>;</span><br><span class=\"line\">\tblit.dst_image_h.width = <span class=\"number\">3840</span>;</span><br><span class=\"line\">\tblit.dst_image_h.height = <span class=\"number\">1440</span>;</span><br><span class=\"line\">\tblit.dst_image_h.alpha = <span class=\"number\">0xff</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"built_in\">ioctl</span>(g2d_fd,  G2D_CMD_BITBLT_H ,(<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)(&amp;blit)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%d][%s][%s]G2D_CMD_BITBLT_H failure!\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t__LINE__, __FILE__,__FUNCTION__);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">allocPicMem</span><span class=\"params\">(paramStruct_t*pops,<span class=\"type\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> iRet = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    iRet = <span class=\"built_in\">allocOpen</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (iRet &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;ion_alloc_open failed\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> iRet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pops-&gt;size =size;</span><br><span class=\"line\">    iRet = <span class=\"built_in\">allocAlloc</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(iRet &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;allocAlloc failed\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> iRet;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">freePicMem</span><span class=\"params\">(paramStruct_t*pops)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> iRet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">allocFree</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">ReadPicFileContent</span><span class=\"params\">(<span class=\"type\">char</span> *pPicPath,paramStruct_t*pops,<span class=\"type\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">allocPicMem</span>(pops,size);</span><br><span class=\"line\"></span><br><span class=\"line\">    FILE *fpff = <span class=\"built_in\">fopen</span>(pPicPath, <span class=\"string\">&quot;rb&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == fpff) &#123;</span><br><span class=\"line\">        fpff = <span class=\"built_in\">fopen</span>(pPicPath, <span class=\"string\">&quot;rb&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == fpff) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s ERR \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">            <span class=\"built_in\">allocFree</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s OK \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">            <span class=\"built_in\">fread</span>((<span class=\"type\">void</span> *)pops-&gt;vir, <span class=\"number\">1</span>, size, fpff);</span><br><span class=\"line\">            <span class=\"built_in\">fclose</span>(fpff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s OK \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">        <span class=\"built_in\">fread</span>((<span class=\"type\">void</span> *)pops-&gt;vir, <span class=\"number\">1</span>, size, fpff);</span><br><span class=\"line\">        <span class=\"built_in\">fclose</span>(fpff);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"built_in\">flushCache</span>(MEM_TYPE_CDX_NEW,pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">WritePicFileContent</span><span class=\"params\">(<span class=\"type\">char</span> *pPicPath,paramStruct_t*pops,<span class=\"type\">int</span> size)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> iRet = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;WritePicFileContent size=%d \\n&quot;</span>,size);</span><br><span class=\"line\">\t<span class=\"built_in\">flushCache</span>(MEM_TYPE_CDX_NEW,pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    FILE *fpff = <span class=\"built_in\">fopen</span>(pPicPath, <span class=\"string\">&quot;wb&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == fpff) &#123;</span><br><span class=\"line\">        fpff = <span class=\"built_in\">fopen</span>(pPicPath, <span class=\"string\">&quot;wb&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">NULL</span> == fpff) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s ERR \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">            <span class=\"built_in\">allocFree</span>(MEM_TYPE_CDX_NEW, pops, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s OK \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">            <span class=\"built_in\">fwrite</span>((<span class=\"type\">void</span> *)pops-&gt;vir, <span class=\"number\">1</span>, size, fpff);</span><br><span class=\"line\">            <span class=\"built_in\">fclose</span>(fpff);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;fopen %s OK \\n&quot;</span>, pPicPath);</span><br><span class=\"line\">        <span class=\"built_in\">fwrite</span>((<span class=\"type\">void</span> *)pops-&gt;vir, <span class=\"number\">1</span>, size, fpff);</span><br><span class=\"line\">        <span class=\"built_in\">fclose</span>(fpff);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">VT_G2D_6in1compose</span><span class=\"params\">(<span class=\"type\">int</span> iSubWidth,<span class=\"type\">int</span> iSubHeight,<span class=\"type\">int</span> iWidth,<span class=\"type\">int</span> iHeight)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps0;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps1;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps2;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps3;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps4;</span><br><span class=\"line\">\tparamStruct_t m_DispMemOps5;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pcompPicPath0=<span class=\"string\">&quot;cvideo.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath0=<span class=\"string\">&quot;Video[0]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath1=<span class=\"string\">&quot;Video[1]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath2=<span class=\"string\">&quot;Video[2]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath3=<span class=\"string\">&quot;Video[3]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath4=<span class=\"string\">&quot;Video[4]_picture0.yuv&quot;</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> *pPicPath5=<span class=\"string\">&quot;Video[5]_picture0.yuv&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath0,&amp;m_DispMemOps0,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath1,&amp;m_DispMemOps1,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath2,&amp;m_DispMemOps2,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath3,&amp;m_DispMemOps3,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath4,&amp;m_DispMemOps4,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">ReadPicFileContent</span>(pPicPath5,&amp;m_DispMemOps5,iSubWidth*iSubHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"built_in\">allocPicMem</span>(&amp;m_DispMemOps,iWidth*iHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> outfd = m_DispMemOps.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> infd[<span class=\"number\">6</span>];</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">0</span>] = m_DispMemOps0.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">1</span>] = m_DispMemOps1.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">2</span>] = m_DispMemOps2.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">3</span>] = m_DispMemOps3.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">4</span>] = m_DispMemOps4.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\tinfd[<span class=\"number\">5</span>] = m_DispMemOps5.ion_buffer.fd_data.aw_fd;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> ret = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tret  = <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">0</span>],outfd,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">g2dClipByFd</span>();</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">1</span>],outfd,iSubWidth,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">2</span>],outfd,iSubWidth*<span class=\"number\">2</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">3</span>],outfd,<span class=\"number\">0</span>,iSubHeight);</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">4</span>],outfd,iSubWidth,iSubHeight);</span><br><span class=\"line\">\t\tret |= <span class=\"built_in\">VTG2D_ClipByFd</span>(infd[<span class=\"number\">5</span>],outfd,iSubWidth*<span class=\"number\">2</span>,iSubHeight);</span><br><span class=\"line\">\t\t<span class=\"built_in\">WritePicFileContent</span>(pcompPicPath0,&amp;m_DispMemOps,iWidth*iHeight*<span class=\"number\">3</span>/<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps0);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps1);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps2);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps3);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps4);</span><br><span class=\"line\">\t\t<span class=\"built_in\">freePicMem</span>(&amp;m_DispMemOps5);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：T5中不能进行缩放和格式转换。而且要求目标图像和源图像的分辨率必须相同。</p>"},{"title":"什么是OpenGL?","date":"2023-04-14T13:29:11.000Z","comments":0,"description":null,"typora-root-url":"4-1-OpenGL","_content":"\n# 一、什么是OpenGL?\n\n## 1.OpenGL简介\n\nOpenGL是渲染2D、3D矢量图形硬件的一种软件接口。本质上说，它是一个3D图形和模型库，具有高度的可移植性，并且具有非常快的渲染速度。OpenGL并不是一种语言，而是更像一个C运行时函数库。它提供了一些预包装的功能，帮助开发人员编写功能强大的三维应用程序。 OpenGL可以再多种操作系统平台上运行，例如各种版本的Windows、UNIX/Linux、Mac OS 和 OS/2等。如今，OpenGL广泛流行于游戏、医学影像、地理信息、气象模拟等领域，是高性能图像和交互性场景处理的工业标准。\n\n<!--more-->\n\nOpenGL的高效实现（利用了图形加速硬件）存在于Windows，部分UNIX平台和Mac OS。这些实现一般由显示设备厂商提供，而且非常依赖于该厂商提供的硬件。\n\n一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范(Specification)。\n\nOpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定（译注：这里开发者是指编写OpenGL库的人）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。\n\n实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。\n\n由于OpenGL的大多数实现都是由显卡厂商编写的，当产生一个bug时通常可以通过升级显卡驱动来解决。这些驱动会包括你的显卡能支持的最新版本的OpenGL，这也是为什么总是建议你偶尔更新一下显卡驱动。\n\n所有版本的OpenGL规范文档都被公开的寄存在Khronos那里。有兴趣的读者可以找到OpenGL3.3（我们将要使用的版本）的规范文档。如果你想深入到OpenGL的细节（只关心函数功能的描述而不是函数的实现），这是个很好的选择。如果你想知道每个函数具体的运作方式，这个规范也是一个很棒的参考。\n\n## 2.核心模式和立即渲染模式\n\n早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少能控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。\n\n当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从OpenGL实际运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。\n\n这也是为什么我们的教程面向OpenGL3.3的核心模式。虽然上手更困难，但这份努力是值得的。\n\n现今，更高版本的OpenGL已经发布（写作时最新版本为4.5），你可能会问：既然OpenGL 4.5 都出来了，为什么我们还要学习OpenGL 3.3？答案很简单，所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代OpenGL版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本OpenGL的新特性。\n\n当使用新版本的OpenGL特性时，只有新一代的显卡能够支持你的应用程序。这也是为什么大多数开发者基于较低版本的OpenGL编写程序，并只提供选项启用新版本的特性。\n\n在有些教程里你会看见更现代的特性，它们同样会以这种红色注释方式标明。\n\n## 3.扩展\n\nOpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。\n\n使用扩展的代码大多看上去如下：\n\n```c\nif(GL_ARB_extension_name)\n{\n    // 使用硬件支持的全新的现代特性\n}\nelse\n{\n    // 不支持此扩展: 用旧的方式去做\n}\n```\n\n 使用OpenGL3.3时，我们很少需要使用扩展来完成大多数功能，当需要的时候，本教程将提供适当的指示。 \n\n## 4.状态机\n\nOpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。\n\n假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。\n\n当使用OpenGL的时候，我们会遇到一些状态设置函数(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。\n\n\n## 5.对象\n\nOpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。\n\n在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)：\n\n```c\nstruct object_name {\n    float  option1;\n    int    option2;\n    char[] name;\n};\n```\n\n在有些教程中一直使用的都是OpenGL的基本类型，但由于作者觉得在本教程系列中并没有一个必须使用它们的原因，所有的类型都改为了自带类型。但是请仍然记住，使用OpenGL的类型的好处是保证了在各平台中每一种类型的大小都是统一的。你也可以使用其它的定宽类型(Fixed-width Type)来实现这一点。\n\n当我们使用一个对象时，通常看起来像如下一样（把OpenGL上下文看作一个大的结构体）：\n\n```c\n// OpenGL的状态\nstruct OpenGL_Context {\n    ...\n    object* object_Window_Target;\n    ...     \n};\n// 创建对象\nunsigned int objectId = 0;\nglGenObject(1, &objectId);\n// 绑定对象至上下文\nglBindObject(GL_WINDOW_TARGET, objectId);\n// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项\nglSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);\nglSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);\n// 将上下文对象设回默认\nglBindObject(GL_WINDOW_TARGET, 0);\n\n```\n\n这一小段代码展现了你以后使用OpenGL时常见的工作流。我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。\n\n目前提供的示例代码只是OpenGL如何操作的一个大致描述，通过阅读以后的教程你会遇到很多实际的例子。\n\n使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。\n\n# 二、开发环境配置\n\n## 1.Ubuntu开发环境配置\n\n```c\n//使用 apt 安装 OpenGL 和开发包\nsudo apt-get install build-essential libgl1-mesa-dev\nsudo apt-get install freeglut3-dev\nsudo apt-get install libglew-dev libsdl2-dev libsdl2-image-dev libglm-dev libfreetype6-dev\n```\n\n## 2.测试程序\n\n 用vim写一段测试程序，测试下开发环境是否安装成功。 \n\n```c\n// test.c\n/* light.c\n此程序利用GLUT绘制一个OpenGL窗口，并显示一个加以光照的球。\n*/\n/* 由于头文件glut.h中已经包含了头文件gl.h和glu.h，所以只需要include 此文件*/\n# include <GL/glut.h>\n# include <stdlib.h>\n    \n/* 初始化材料属性、光源属性、光照模型，打开深度缓冲区 */\nvoid init ( void )\n{\n    GLfloat mat_specular [ ] = { 1.0, 1.0, 1.0, 1.0 };\n    GLfloat mat_shininess [ ] = { 50.0 };\n    GLfloat light_position [ ] = { 1.0, 1.0, 1.0, 0.0 };\n    glClearColor ( 0.0, 0.0, 0.0, 0.0 );\n    glShadeModel ( GL_SMOOTH );\n    glMaterialfv ( GL_FRONT, GL_SPECULAR, mat_specular);\n    glMaterialfv ( GL_FRONT, GL_SHININESS, mat_shininess);\n    glLightfv ( GL_LIGHT0, GL_POSITION, light_position);\n    glEnable (GL_LIGHTING);\n    glEnable (GL_LIGHT0);\n    glEnable (GL_DEPTH_TEST);\n}\n/*调用GLUT函数，绘制一个球*/\nvoid display ( void )\n{\n    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);// 1. 调用glClear()清空窗口\n    glutSolidSphere (1.0, 40, 50);/*调用GLUT函数，绘制一个球*/\n    glFlush ();// 3. 请求将图像绘制到窗口\n}\n // main()函数用于创建窗口,调用init()函数,最后进入到事件循环(event loop).这里仍会看到一些以gl开头的函数,但和上面的有所不同.这些函数来自第三方库,以便我们可以在不同的系统中更方便地使用OpenGL.这里我们使用的是GLUT  \nint main(int argc, char** argv)\n{\n    /* GLUT环境初始化*/\n    glutInit (&argc, argv);\n    /* 显示模式初始化 */\n    glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n    /* 定义窗口大小 */\n    glutInitWindowSize (300, 300);\n    /* 定义窗口位置 */\n    glutInitWindowPosition (100, 100);\n    /* 显示窗口，窗口标题为执行函数名 */\n    glutCreateWindow ( argv [ 0 ] );\n    /* 调用OpenGL初始化函数 */\n    init ( );\n    /* 注册OpenGL绘图函数 */\n    glutDisplayFunc ( display );\n    // /* 进入GLUT消息循环，开始执行程序 */\n    glutMainLoop( );//用于进入事件处理循环，仅退出窗口时，函数返回\n    return 0;\n} \n```\n\n## 3.编译运行\n\n```c\ngcc test.c -o test -lGL -lglut\n./test\n```\n\n## 4.效果图\n\n<img src=\"1.png\" style=\"zoom: 25%;\" />\n\n## 5.附录：\n\n```c++\nvoid glutWireSphere(GLdouble radius, GLint slices, GLint stacks); 线框球\nvoid glutSolidSphere(GLdouble radius, GLint slices, GLint stacks); 实心球\n\nvoid glutWireCube(GLdouble size); 线框立方体\nvoid glutSolidCube(GLdouble size); 实心立方体\n\nvoid glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings); 线框圆环\nvoid glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings); 实心圆环\n\nvoid glutWireIcosahedron(void); 线框20面体\nvoid glutSolidIcosahedron(void); 实心20面体\n\nvoid glutWireOctahedron(void); 线框8面体 \nvoid glutSolidOctahedron(void); 实心8面体\n\nvoid glutWireTetrahedron(void); 线框4面体\nvoid glutSolidTetrahedron(void); 实心4面体\n\nvoid glutWireDodecahedron(GLdouble radius); 线框12面体\nvoid glutSolidDodecahedron(GLdouble radius); 实心12面体\n\nvoid glutWireCone(GLdouble radius, GLdouble height, GLint slices, GLint stacks); 线框圆锥体\nvoid glutSolidCone(GLdouble radius, GLdouble height, GLint slices, GLint stacks); 实心圆锥体\n\nvoid glutWireTeapot(GLdouble size); 线框茶壶\nvoid glutSolidTeapot(GLdouble size); 实心茶壶\n\n函数中，radius表示球体的半径，slices表示球体围绕z轴分割的数目，stacks表示球体沿着z轴分割的数目。\n\n绘制中心在模型坐标原点,半径为radius的球体,球体围绕z轴分割slices次,球体沿着z轴分割stacks次\n```\n\n\n\n# 三、OpenGL流程详细介绍\n\n## 1、简介\n\nOpenGL（Open Graphics Library）是一个跨编程语言、跨平台的编程图形程序接口，它将计算机的资源抽象称为一个个OpenGL的对象，对这些资源的操作抽象为一个个的OpenGL指令。\n\nOpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。\n\n本文介绍的OpenGL版本是基于OpenGL ES 3.0的。这也是目前覆盖率最高的OpenGL版本，被广泛运用在各种终端设备上。\n\n## 2、OpenGL上下文（Context）\n\n在应用程序调用任何OpenGL的指令之前，需要安排首先创建一个OpenGL的上下文。这个上下文是一个非常庞大的状态机，保存了OpenGL中的各种状态，这也是OpenGL指令执行的基础。\n\nOpenGL的函数不管在哪个语言中，都是类似C语言一样的面向过程的函数，本质上都是对OpenGL上下文这个庞大的状态机中的某个状态或者对象进行操作，当然你得首先把这个对象设置为当前对象。因此，通过对OpenGL指令的封装，是可以将OpenGL的相关调用封装成为一个面向对象的图形API的。\n\n由于OpenGL上下文是一个巨大的状态机，切换上下文往往会产生较大的开销，但是不同的绘制模块，可能需要使用完全独立的状态管理。因此，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源。这样的方案，会比反复切换上下文，或者大量修改渲染状态，更加合理高效的。\n\n## 3、帧缓冲区（FrameBuffer）\n\nOpenGL是图形API，因此可以说所有的运算和结果最终都是需要通过图像进行输出的。那么绘图必然就需要有一块画板，而帧缓冲区就是OpenGL中的画板。但是特别需要注意的是，帧缓冲区不是常规意义缓冲区（就像鲸鱼不是鱼一样），它并不是实际存储数据的对象，类似画画的时候，需要在画板上放一块画布，才能实际在画布上进行绘画，这些画布可以是纹理（Texture）或者是渲染缓冲区（RenderBuffer），而放置这些画布的位置被称为帧缓冲区的附着（Attachment）。\n\n### 3.1、附着（Attachment）\n\n附着可以理解为画板上的夹子，夹住了哪个画布，就往对应画布上输出数据。\n\n在帧缓冲区中可以附着3种类型的附着，颜色附着（ColorAttachment），深度附着（DepthAttachment），模板附着（StencilAttachment）。这三种附着对应的存储区域也被称为颜色缓冲区（ColorBuffer），深度缓冲区（DepthBuffer），模板缓冲区（StencilBuffer）。\n\n颜色附着输出绘制图像的颜色数据，也就是平时常见的图像的RGBA数据。如果使用了多渲染目标(Multiple Render Targets)技术，那么颜色附着的数量可能会大于一。\n\n深度附着输出绘制图像的深度数据，深度数据主要在3D渲染中使用，一般用于判断物体的远近来实现遮挡的效果。\n\n模板附着输出模板数据，模板数据是渲染中较为高级的用法，一般用于渲染时进行像素级别的剔除和遮挡效果，常见的应用场景比如三维物体的描边。\n\n## 4、纹理（Texture）和渲染缓冲区（RenderBuffer）\n\n前面已经说过，帧缓冲区并不是实际存储数据的地方，实际存储图像数据数据的对象就是纹理和渲染缓冲区。\n\n他们三者的关系是这样的，纹理或渲染缓冲区作为帧缓冲区的附着。\n\n那么，纹理和渲染缓冲区又有什么关系和区别呢？\n\n纹理和渲染缓冲区同样是存储图像的对象。一般来说，渲染缓冲区对应操作系统提供的窗口，而纹理代表列离屏的图像存储区域。因此，渲染缓冲区都是2D的图像类型，而纹理一般有立方体纹理，1D、2D、3D纹理等类型，同时纹理还额外支持了mipmap等其他特性。\n\n值得注意的是，一般来说渲染缓冲区和纹理不能同时挂载在同一个帧缓冲区上。\n\n## 5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）\n\n准备好了画布之后，就要开始画图了。画图一般是先画好图像的骨架，然后再往骨架里面填充颜色，这对于OpenGL也是一样的。顶点数据就是要画的图像的骨架，和现实中不同的是，OpenGL中的图像都是由图元组成。在OpenGL ES中，有3种类型的图元：点、线、三角形。那这些顶点数据最终是存储在哪里的呢？开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组。而性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区。\n\n## 6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）\n\n其实我觉得索引在OpenGL叫Element确实有点不够贴切，而在DirectX中叫做IndexBuffer更加合适一些。\n\n索引数据的目的主要是为了实现顶点的复用，在绘制图像时，总是会有一些顶点被多个图元共享，而反复对这个顶点进行运算常常是没有必要的（也有某些特殊场景需要）。因此对通过索引数据，指示OpenGL绘制顶点的顺序，不但能防止顶点的重复运算，也能在不修改顶点数据的情况下，一定程度的重新组合图像。\n\n和顶点数据一样，索引数据也可以以索引数组的形式存储在内存当中，调用绘制函数时传入；或者提前分配一块显存，将索引数据存储在这块显存当中，这块显存就被称为索引缓冲区。同样的，使用缓冲区的方式，性能一般会比直接使用索引数组的方式更加高效。\n\nOpenGL ES提供了2种主要的绘制方法：glDrawArrays和glDrawElements。前者对应的就是没有索引数据的情况，后者对应的是有索引数据的情况。\n\n## 7、着色器程序（Shader）\n\n在固定渲染管线时代，这一步并不是必须的。而是由内置的一段包含了光照、坐标变换、裁剪等等诸多功能的固定shader程序来完成。而可自定义shader，可以说是现代图形API最重要的能力了，没有之一。可以说，shader提供对图形运算的精细操作，带来了各式各样的处理能力，极度的丰富了图形API所能实现的效果。\n\nOpenGL和其他主流的图形API早在好几年前，就全面的将固定渲染管线架构变为了可编程渲染管线。因此，OpenGL在实际调用绘制函数之前，还需要指定一个由shader编译成的着色器程序。\n\n常见的着色器主要有顶点着色器（VertexShader），片段着色器（FragmentShader）/像素着色器（PixelShader），几何着色器（GeometryShader），曲面细分着色器（TessellationShader）。片段着色器和像素着色器只是在OpenGL和DX中的不同叫法而已。可惜的是，直到OpenGL ES 3.0，依然只支持了顶点着色器和片段着色器这两个最基础的着色器。\n\nOpenGL在处理shader时，和其他编译器一样。通过编译、链接等步骤，生成了着色器程序（glProgram），着色器程序同时包含了顶点着色器和片段着色器的运算逻辑。在OpenGL进行绘制的时候，首先由顶点着色器对传入的顶点数据进行运算。再通过图元装配，将顶点转换为图元。然后进行光栅化，将图元这种矢量图形，转换为栅格化数据。最后，将栅格化数据传入片段着色器中进行运算。片段着色器会对栅格化数据中的每一个像素进行运算，并决定像素的颜色，也可以在这个阶段将某些像素丢弃。\n\n其中像素的颜色可以是具体的数值或者是由某种算法计算而来的。如果图元有纹理，就必须用纹理来产生图元的二维渲染图象上每个像素的颜色。对于图元在二维屏幕上图象的每个像素来说，都必须从纹理中获得一个颜色值。我们把这一过程称为纹理过滤（texture filtering），纹理过滤根据不同的过滤方式会由一个或多个像素确定最终获得的颜色。表示这个像素位置的数据被称为纹理坐标（TextureCoordinate）而寻找这个纹理中对应像素位置的方法被称为纹理寻址方式或者纹理环绕方式（TextureWrap）。\n\n最终，没有被丢弃的像素，下一步会进入测试阶段。通过了深度测试和模板测试，会和帧缓冲区上的颜色附着（FrameBuffer上的ColorAttachment）上的颜色进行混合，决定最终留在画布上的颜色是什么。\n\n![](2.png)\n\n<img src=\"3.png\" style=\"zoom:50%;\" />\n\n### 7.1、顶点着色器（VertexShader）\n\n顶点着色器是OpenGL中用于计算顶点属性的程序。顶点着色器是逐顶点运算的程序，也就是说每个顶点数据都会执行一次顶点着色器，当然这是并行的，并且顶点着色器运算过程中无法访问其他顶点的数据。\n\n顶点着色器的数据输入主要有两种，统一变量（Uniform）、顶点属性（VertexAttribute）。统一变量在所有顶点运算中是一样的，而顶点属性则是从外部输入的顶点数据中获取，一般在每个顶点运算中都是不同的。\n\n一般来说典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照运算等等。顶点坐标由自身坐标系转换到归一化坐标系的运算，就是在这里发生的。\n\n同时顶点着色器的输出结果，也会作为片段着色器的输入。\n\n![](4.png)\n\n### 7.2、片段着色器（FragmentShader）\n\n片段着色器是OpenGL中用于计算片段（像素）颜色的程序。片段做社区是逐像素运算的程序，也就是说每个像素都会执行一次片段着色器，当然也是并行的。\n\n片段着色器的的数据输入主要有三种种，统一变量（Uniform）、顶点着色器输入变量（也被称为可变变量varying）、采样器（Sampler）。统一变量的值，在同个OpenGL着色器程序中的顶点着色器和片段着色器中是一致的。顶点着色器输入变量在每个像素运算中则一般是不同的，它的值由组成图元的顶点的顶点着色器运算输出的值，根据像素位置进行插值的结果而决定。采样器则是用于从设定好的纹理中，获取纹理的像素颜色的。\n\n在片段着色器中允许丢弃像素，而使得像素不参与后续的运算。\n\n![](5.png)\n\n## 8、逐片段操作（Per-Fragment Operation）\n\n \n\n![](6.png)\n\n \n\n### 8.1、测试（Test）\n\n在着色器程序完成之后，我们得到了像素数据。这些数据必须要通过测试才能最终绘制到画布，也就是帧缓冲上的颜色附着上。\n\n测试主要可以分为像素所有者测试（PixelOwnershipTest）、裁剪测试（ScissorTest）、模板测试（StencilTest）和深度测试（DepthTest），执行的顺序也是按照这个顺序进行执行。\n\n最开始进行的测试是像素所有者测试，主要是剔除不属于当前程序的像素运算。\n\n之后裁剪测试，主要是剔除窗口区域之外的像素。\n\n这两个测试都是由OpenGL内部实现的，无需开发者干预，因此不再进行赘述。\n\n深度测试，主要是通过对像素的运算出来的深度，也就是像素离屏幕的距离进行对比，根据OpenGL设定好的深度测试程序，决定是否最终渲染到画布上。一般默认的程序是将离屏幕较近的像素保留，而将离屏幕较远的像素丢弃。如果像素最终被渲染到画布上，根据设定好的OpenGL深度覆写状态，可能会更新帧缓冲区上深度附着的值，方便进行下一次的比较。\n\n模板测试和深度测试的执行原理一致，但是执行的顺序是在深度测试之前的，放在后面 主要是比深度测试更加难以理解一些，初学者可以暂时跳过这个部分。模板测试同样也是通过模板测试程序去决定最终的像素是否丢弃，同样也是根据OpenGL的模板覆写状态决定是否更新像素的模板值。模板测试给开发者提供了高性能的裁剪方案，三维物体的描边技术，就是模板测试典型的用处之一。\n\n### 8.2、混合（Blending）\n\n在测试阶段之后，如果像素依然没有被剔除，那么像素的颜色将会和帧缓冲区中颜色附着上的颜色进行混合，混合的算法可以通过OpenGL的函数进行指定。但是OpenGL提供的混合算法是有限的，如果需要更加复杂的混合算法，一般可以通过像素着色器进行实现，当然性能会比原生的混合算法差一些。\n\n### 8.3、抖动（Dithering）\n\n在混合阶段过后，根据OpenGL的状态设置，会决定是否有抖动这个阶段。\n\n抖动是一种针对对于可用颜色较少的系统，可以以牺牲分辨率为代价，通过颜色值的抖动来增加可用颜色数量的技术。抖动操作是和硬件相关的，允许程序员所做的操作就只有打开或关闭抖动操作。实际上，若机器的分辨率已经相当高，激活抖动操作根本就没有任何意义。默认情况下，抖动是激活的。\n\n![](7.png)\n\n## 9、渲染到纹理\n\n有些OpenGL程序并不希望渲染出来的图像立即显示在屏幕上，而是需要多次渲染。可能其中一次渲染的结果是下次渲染的输入。因此，如果帧缓冲区的颜色附着设置为一张纹理，那么渲染完成之后，可以重新构造新的帧缓冲区，并将上次渲染出来的纹理作为输入，重新进行前面所述的流程。\n\n## 10、渲染上屏/交换缓冲区(SwapBuffer)\n\n前面已经提过，渲染缓冲区一般映射的是系统的资源比如窗口。如果将图像直接渲染到窗口对应的渲染缓冲区，则可以将图像显示到屏幕上。\n\n但是，值得注意的是，如果每个窗口只有一个缓冲区，那么在绘制过程中屏幕进行了刷新，窗口可能显示出不完整的图像。\n\n为了解决这个问题，常规的OpenGL程序至少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在一个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示。\n\n由于显示器的刷新一般是逐行进行的，因此为了防止交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进行交换，这个信号就被称为垂直同步信号，这个技术被称为垂直同步。\n\n使用了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进行下一帧的渲染，使得帧率无法完全达到硬件允许的最高水平。为了解决这个问题，引入了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，而垂直同步发生时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利用硬件性能的目的。\n\n![](9.jpg)\n\n### 11.顶点数据最终加工成图像的过程\n\n**着色器（shader）**是在GPU上运行的小程序，GPU有成千上万个处理核心，能进行非常多的并行计算，在些计算的逻辑就写在着色器里，上图中蓝色部分就是表示我们可以通过写shader来进行控制的部分\n\n**顶点着色器**先把3D坐标转换成另一种3D坐标，也就是OpenGL世界里的坐标\n\t\t**图元着色器**会把顶点着色器传进来的坐标连接成一个图形\n\t\t**几何着色器**可以进一步构造新的图元或其他形状\n\t\t**光栅化**就是把图元映射成屏幕上对应的像素\n\t\t**片段着色器**用来给物体上色\n\t\t**测试与混合**如果物体对应Alpha值所表示的颜色带有一定的透明，它后面有不完全透明的物体，则要跟后面物体的颜色进行混合，以此达到透明效果，如果被前面物体挡住了，就丢弃被挡住部分的像素\n\n整个流程就像工厂里的流水线一样，把原料（顶点数据）从一头放入，经过一道道工序的处理，最终变成产品，所以这个渲染流程也叫渲染流水线\n\n![](15.png)\n\n# 四、例程\n\n## 1.创建窗口\n\n```cpp\n// System Headers\n#include <glad/glad.h>//函数加载\n#include <GLFW/glfw3.h>//窗口管理\n\n// Standard Headers\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height);//回调函数原型声明\nvoid processInput(GLFWwindow *window);\n\n// settings\nconst unsigned int SCR_WIDTH = 800;\nconst unsigned int SCR_HEIGHT = 600;\n\nint main() {\n    glfwInit();//初始化    \n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);//设置主版本号\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);//设置次版本号\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);//使用核心模式\n    //创建一个窗口对象,参数：窗口宽，窗口高，窗口标题，暂时忽略，暂时忽略\n    GLFWwindow *window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"GLFW 3.3.1\", NULL, NULL);\n    if (window == NULL) {\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();//释放内存\n        return -1;\n    }\n    //通知GLFW将我们窗口的上下文设置为当前线程的主上下文\n    glfwMakeContextCurrent(window);\n    //对窗口注册一个回调函数,每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n    //初始化GLAD用来管理OpenGL的函数指针\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n    //设置视口，OpenGL幕后的坐标转窗口坐标将以此为参考\n    //OpenGL的坐标最大最小值为1和-1\n    //如下x轴-1~1对应窗口坐标0~800,y轴-1～1对应窗口坐标0~600\n    //如OpenGL坐标（0，0）对应窗口坐标（400,300），（-0.5,0.5）对应（200,450）\n    glViewport(0,0,800,600);\n    //渲染循环\n    while(!glfwWindowShouldClose(window)) {\n        //监视键盘 输入\n        processInput(window);\n        // 渲染指令\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);//清除颜色缓冲\n        //GL_COLOR_BUFFER_BIT 颜色缓冲\n        //GL_DEPTH_BUFFER_BIT 深度缓冲\n        //GL_STENCIL+BUFFER_BIT 模板缓冲\n        glClear(GL_COLOR_BUFFER_BIT);\n        //交换颜色缓冲，OpenGL绘图的时候，前缓冲用于显示，后缓冲就在渲染\n        //当后缓冲渲染完毕，前缓冲和后缓冲互换，后缓冲变前缓冲，前缓冲变后缓冲\n        // 检查并调用事件，交换缓冲\n        glfwSwapBuffers(window);//检查触发事件\n        //消息分发函数 检测有没有触发窗口消息，然后调用对应回调函数\n        glfwPollEvents();\n    }\n    //释放/删除之前的分配的所有资源,释放内存\n    glfwTerminate();\n    return EXIT_SUCCESS;\n}\n\n//输入控制，检查用户是否按下了返回键(Esc)\nvoid processInput(GLFWwindow *window) {\n    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {\n        glfwSetWindowShouldClose(window, true);\n    }\n}\n\n// 当用户改变窗口的大小的时候，视口也应该被调整\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height) {\n    // 注意：对于视网膜(Retina)显示屏，width和height都会明显比原输入值更高一点。\n    glViewport(0, 0, width, height);\n}\n```\n\n## 2.能控制移动的彩色矩形\n\n```cpp\n#include<glad/glad.h>\n#include<GLFW/glfw3.h>\n#include<iostream>\n\nusing namespace std;\n\n//顶点着色器\nconst char *vertexShaderSource = \n\"#version 330 core\\n\"\n\"layout (location = 0) in vec3 aPos;\\n\"\n\"layout (location = 1) in vec3 aColor;\\n\"\n\"out vec3 ourColor;\\n\"\n\"uniform vec2 pos;\\n\"\n\"void main(){\\n\"\n\"    gl_Position = vec4(aPos.x+pos.x,aPos.y+pos.y,aPos.z,1.0);\\n\"\n\"    ourColor=aColor;\\n\"\n\"\\n}\";\n\n//片段着色器\nconst char *fragmentShaderSource =\n\"#version 330 core\\n\"\n\"out vec4 FragColor;\\n\"\n\"in vec3 ourColor;\\n\"\n\"void main(){\\n\"\n\"    FragColor = vec4(ourColor,0.8f);\"\n\"}\\n\";\n\n//顶点和颜色数据\nfloat vertices[] = {\n    // 位置              // 颜色\n     0.5f, 0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下\n    -0.5f, 0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下\n     -0.5f,  -0.5f, 0.0f,  0.0f, 0.0f, 1.0f,    // 顶部\n     0.5f,  -0.5f, 0.0f,  0.5f, 0.5f, 0.5f    // 顶部\n};\n//索引\nunsigned int indices[] = { // 注意索引从0开始! \n    0, 1, 3, // 第一个三角形\n    1, 2, 3  // 第二个三角形\n};\n\n//矩形平面坐标\nfloat x=0,y=0,speed=0.02f;\n\n//编译着色器\nint CompileShader(const char* source,int type)\n{\n    int shader=glCreateShader(type);\n    glShaderSource(shader,1,&source,nullptr);\n    glCompileShader(shader);\n\n    int ret=0;\n    char log[512]={0};\n    glGetShaderiv(shader,GL_COMPILE_STATUS,&ret);\n    if(!ret){\n        glGetShaderInfoLog(shader,512,nullptr,log);\n        cout<<\"着色器编译失败：\"<<log<<endl;\n        return 0;\n    }\n    return shader;\n}\n\n//窗口大小变动的回调函数\nvoid framebuffer_size_callback(GLFWwindow* window,int width,int height)\n{\n    glViewport(0,0,width,height);\n}\n\n//如果ESC键按下，则关闭窗口\nvoid processInput(GLFWwindow *window)\n{\n    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS){\n        glfwSetWindowShouldClose(window, true);\n    }\n    if(glfwGetKey(window,GLFW_KEY_D) == GLFW_PRESS){\n        x>=0.5f ? x=0.5f : x+=speed;   \n    } \n    if(glfwGetKey(window,GLFW_KEY_A) == GLFW_PRESS){ \n        x<=-0.5f ? x=-0.5f : x-=speed;\n    }\n    if(glfwGetKey(window,GLFW_KEY_W) == GLFW_PRESS){\n        y>=0.5f ? y=0.5f : y+=speed;\n    } \n    if(glfwGetKey(window,GLFW_KEY_S) == GLFW_PRESS){\n        y<=-0.5f ? y = -0.5f : y-=speed;\n    }\n}\n\nint main()\n{\n    glfwInit();//初始化\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,3); //主版本号\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,3);//次版本号\n    glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);//采用核心模式\n    \n    //参数：窗口宽，窗口高，窗口标题，暂时忽略，暂时忽略\n    GLFWwindow* window = glfwCreateWindow(800,600,\"这是窗口标题\",nullptr,nullptr);\n    if(!window)\n    {\n        cout<<\"创建窗口失败！\"<<endl;\n        glfwTerminate();//释放内存\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n\n    //初始化GLAD，GLAD用于管理函数指针\n    if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){\n        cout<<\"初始化GLAD失败\"<<endl;\n        return -1;\n    }\n    \n    //设置视口，OpenGL幕后的坐标转窗口坐标将以此为参考\n    //OpenGL的坐标最大最小值为1和-1\n    //如下x轴-1~1对应窗口坐标0~800,y轴-1～1对应窗口坐标0~600\n    //如OpenGL坐标（0，0）对应窗口坐标（400,300），（-0.5,0.5）对应（200,450）\n    glViewport(0,0,800,600);\n    \n    //编译着色器\n    int vertexShader=CompileShader(vertexShaderSource, GL_VERTEX_SHADER);\n    if(!vertexShader) return -1;\n    int fragmentShader=CompileShader(fragmentShaderSource, GL_FRAGMENT_SHADER);\n    if(!fragmentShader) return -1;\n    \n    //链接着色器程序\n    int shaderProgram=glCreateProgram();\n    glAttachShader(shaderProgram,vertexShader);\n    glAttachShader(shaderProgram,fragmentShader);\n    glLinkProgram(shaderProgram);\n    glDeleteShader(vertexShader);\n    glDeleteShader(fragmentShader);\n\n    //创建VAO\n    GLuint VAO=0;\n    glGenVertexArrays(1,&VAO);\n    glBindVertexArray(VAO);\n    \n    //创建VBO\n    GLuint VBO=0;\n    glGenBuffers(1,&VBO);\n    glBindBuffer(GL_ARRAY_BUFFER,VBO);\n    glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);\n\n    //创建EBO\n    GLuint EBO=0;\n    glGenBuffers(1,&EBO);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,EBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER,sizeof(indices),indices,GL_STATIC_DRAW);\n\n    //顶点数据 从偏移0 * 6*sizeof(float)处开始拿3个float\n    //之后再从偏移1 * 6*sizeof(float)处开始拿3个float 直到拿完\n    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,6*sizeof(float),(void*)0);\n    glEnableVertexAttribArray(0);\n    //颜色数据同上 不过偏移是从3*sizeof(float)开始，不是从0\n    glVertexAttribPointer(1,3,GL_FLOAT,GL_FALSE,6*sizeof(float),(void*)(3*sizeof(float)));\n    glEnableVertexAttribArray(1);\n\n    int index=glGetUniformLocation(shaderProgram,\"pos\");\n    \n    //注册窗口大小变化回调函数\n    glfwSetFramebufferSizeCallback(window,framebuffer_size_callback);\n\n    //窗口循环 如果窗口被关闭，则退出循环\n    while(!glfwWindowShouldClose(window))\n    {\n        //监视键盘输入\n        processInput(window);\n        \n        //清除颜色缓冲\n        glClearColor(0.2f,0.3f,0.3f,0.8f);\n        //GL_COLOR_BUFFER_BIT 颜色缓冲\n        //GL_DEPTH_BUFFER_BIT 深度缓冲\n        //GL_STENCIL+BUFFER_BIT 模板缓冲\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        glUseProgram(shaderProgram);\n        glBindVertexArray(VAO);\n        glUniform2f(index,x,y);\n        glDrawElements(GL_TRIANGLES,6,GL_UNSIGNED_INT,0);\n\n        //交换颜色缓冲，OpenGL绘图的时候，前缓冲用于显示，后缓冲就在渲染\n        //当后缓冲渲染完毕，前缓冲和后缓冲互换，后缓冲变前缓冲，前缓冲变后缓冲\n        glfwSwapBuffers(window);\n        //消息分发函数 检测有没有触发窗口消息，然后调用对应回调函数\n        glfwPollEvents();\n    }\n\n    glDeleteVertexArrays(1,&VAO);\n    glDeleteBuffers(1,&VBO);\n    glDeleteBuffers(1,&EBO);\n    glfwTerminate();\n\n    return 0;\n}\n\n```\n\n","source":"_posts/4-1-OpenGL.md","raw":"---\ntitle: 什么是OpenGL?\ndate: 2023-4-14 21:29:11\ncategories: 笔记\ntags: [嵌入式,OpenGL]\ncomments: false\ndescription:\ntypora-root-url: 4-1-OpenGL\n\n---\n\n# 一、什么是OpenGL?\n\n## 1.OpenGL简介\n\nOpenGL是渲染2D、3D矢量图形硬件的一种软件接口。本质上说，它是一个3D图形和模型库，具有高度的可移植性，并且具有非常快的渲染速度。OpenGL并不是一种语言，而是更像一个C运行时函数库。它提供了一些预包装的功能，帮助开发人员编写功能强大的三维应用程序。 OpenGL可以再多种操作系统平台上运行，例如各种版本的Windows、UNIX/Linux、Mac OS 和 OS/2等。如今，OpenGL广泛流行于游戏、医学影像、地理信息、气象模拟等领域，是高性能图像和交互性场景处理的工业标准。\n\n<!--more-->\n\nOpenGL的高效实现（利用了图形加速硬件）存在于Windows，部分UNIX平台和Mac OS。这些实现一般由显示设备厂商提供，而且非常依赖于该厂商提供的硬件。\n\n一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范(Specification)。\n\nOpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定（译注：这里开发者是指编写OpenGL库的人）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。\n\n实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。\n\n由于OpenGL的大多数实现都是由显卡厂商编写的，当产生一个bug时通常可以通过升级显卡驱动来解决。这些驱动会包括你的显卡能支持的最新版本的OpenGL，这也是为什么总是建议你偶尔更新一下显卡驱动。\n\n所有版本的OpenGL规范文档都被公开的寄存在Khronos那里。有兴趣的读者可以找到OpenGL3.3（我们将要使用的版本）的规范文档。如果你想深入到OpenGL的细节（只关心函数功能的描述而不是函数的实现），这是个很好的选择。如果你想知道每个函数具体的运作方式，这个规范也是一个很棒的参考。\n\n## 2.核心模式和立即渲染模式\n\n早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少能控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。\n\n当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从OpenGL实际运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。\n\n这也是为什么我们的教程面向OpenGL3.3的核心模式。虽然上手更困难，但这份努力是值得的。\n\n现今，更高版本的OpenGL已经发布（写作时最新版本为4.5），你可能会问：既然OpenGL 4.5 都出来了，为什么我们还要学习OpenGL 3.3？答案很简单，所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代OpenGL版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本OpenGL的新特性。\n\n当使用新版本的OpenGL特性时，只有新一代的显卡能够支持你的应用程序。这也是为什么大多数开发者基于较低版本的OpenGL编写程序，并只提供选项启用新版本的特性。\n\n在有些教程里你会看见更现代的特性，它们同样会以这种红色注释方式标明。\n\n## 3.扩展\n\nOpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。\n\n使用扩展的代码大多看上去如下：\n\n```c\nif(GL_ARB_extension_name)\n{\n    // 使用硬件支持的全新的现代特性\n}\nelse\n{\n    // 不支持此扩展: 用旧的方式去做\n}\n```\n\n 使用OpenGL3.3时，我们很少需要使用扩展来完成大多数功能，当需要的时候，本教程将提供适当的指示。 \n\n## 4.状态机\n\nOpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。\n\n假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。\n\n当使用OpenGL的时候，我们会遇到一些状态设置函数(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。\n\n\n## 5.对象\n\nOpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。\n\n在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)：\n\n```c\nstruct object_name {\n    float  option1;\n    int    option2;\n    char[] name;\n};\n```\n\n在有些教程中一直使用的都是OpenGL的基本类型，但由于作者觉得在本教程系列中并没有一个必须使用它们的原因，所有的类型都改为了自带类型。但是请仍然记住，使用OpenGL的类型的好处是保证了在各平台中每一种类型的大小都是统一的。你也可以使用其它的定宽类型(Fixed-width Type)来实现这一点。\n\n当我们使用一个对象时，通常看起来像如下一样（把OpenGL上下文看作一个大的结构体）：\n\n```c\n// OpenGL的状态\nstruct OpenGL_Context {\n    ...\n    object* object_Window_Target;\n    ...     \n};\n// 创建对象\nunsigned int objectId = 0;\nglGenObject(1, &objectId);\n// 绑定对象至上下文\nglBindObject(GL_WINDOW_TARGET, objectId);\n// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项\nglSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 800);\nglSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);\n// 将上下文对象设回默认\nglBindObject(GL_WINDOW_TARGET, 0);\n\n```\n\n这一小段代码展现了你以后使用OpenGL时常见的工作流。我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。\n\n目前提供的示例代码只是OpenGL如何操作的一个大致描述，通过阅读以后的教程你会遇到很多实际的例子。\n\n使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。\n\n# 二、开发环境配置\n\n## 1.Ubuntu开发环境配置\n\n```c\n//使用 apt 安装 OpenGL 和开发包\nsudo apt-get install build-essential libgl1-mesa-dev\nsudo apt-get install freeglut3-dev\nsudo apt-get install libglew-dev libsdl2-dev libsdl2-image-dev libglm-dev libfreetype6-dev\n```\n\n## 2.测试程序\n\n 用vim写一段测试程序，测试下开发环境是否安装成功。 \n\n```c\n// test.c\n/* light.c\n此程序利用GLUT绘制一个OpenGL窗口，并显示一个加以光照的球。\n*/\n/* 由于头文件glut.h中已经包含了头文件gl.h和glu.h，所以只需要include 此文件*/\n# include <GL/glut.h>\n# include <stdlib.h>\n    \n/* 初始化材料属性、光源属性、光照模型，打开深度缓冲区 */\nvoid init ( void )\n{\n    GLfloat mat_specular [ ] = { 1.0, 1.0, 1.0, 1.0 };\n    GLfloat mat_shininess [ ] = { 50.0 };\n    GLfloat light_position [ ] = { 1.0, 1.0, 1.0, 0.0 };\n    glClearColor ( 0.0, 0.0, 0.0, 0.0 );\n    glShadeModel ( GL_SMOOTH );\n    glMaterialfv ( GL_FRONT, GL_SPECULAR, mat_specular);\n    glMaterialfv ( GL_FRONT, GL_SHININESS, mat_shininess);\n    glLightfv ( GL_LIGHT0, GL_POSITION, light_position);\n    glEnable (GL_LIGHTING);\n    glEnable (GL_LIGHT0);\n    glEnable (GL_DEPTH_TEST);\n}\n/*调用GLUT函数，绘制一个球*/\nvoid display ( void )\n{\n    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);// 1. 调用glClear()清空窗口\n    glutSolidSphere (1.0, 40, 50);/*调用GLUT函数，绘制一个球*/\n    glFlush ();// 3. 请求将图像绘制到窗口\n}\n // main()函数用于创建窗口,调用init()函数,最后进入到事件循环(event loop).这里仍会看到一些以gl开头的函数,但和上面的有所不同.这些函数来自第三方库,以便我们可以在不同的系统中更方便地使用OpenGL.这里我们使用的是GLUT  \nint main(int argc, char** argv)\n{\n    /* GLUT环境初始化*/\n    glutInit (&argc, argv);\n    /* 显示模式初始化 */\n    glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);\n    /* 定义窗口大小 */\n    glutInitWindowSize (300, 300);\n    /* 定义窗口位置 */\n    glutInitWindowPosition (100, 100);\n    /* 显示窗口，窗口标题为执行函数名 */\n    glutCreateWindow ( argv [ 0 ] );\n    /* 调用OpenGL初始化函数 */\n    init ( );\n    /* 注册OpenGL绘图函数 */\n    glutDisplayFunc ( display );\n    // /* 进入GLUT消息循环，开始执行程序 */\n    glutMainLoop( );//用于进入事件处理循环，仅退出窗口时，函数返回\n    return 0;\n} \n```\n\n## 3.编译运行\n\n```c\ngcc test.c -o test -lGL -lglut\n./test\n```\n\n## 4.效果图\n\n<img src=\"1.png\" style=\"zoom: 25%;\" />\n\n## 5.附录：\n\n```c++\nvoid glutWireSphere(GLdouble radius, GLint slices, GLint stacks); 线框球\nvoid glutSolidSphere(GLdouble radius, GLint slices, GLint stacks); 实心球\n\nvoid glutWireCube(GLdouble size); 线框立方体\nvoid glutSolidCube(GLdouble size); 实心立方体\n\nvoid glutWireTorus(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings); 线框圆环\nvoid glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings); 实心圆环\n\nvoid glutWireIcosahedron(void); 线框20面体\nvoid glutSolidIcosahedron(void); 实心20面体\n\nvoid glutWireOctahedron(void); 线框8面体 \nvoid glutSolidOctahedron(void); 实心8面体\n\nvoid glutWireTetrahedron(void); 线框4面体\nvoid glutSolidTetrahedron(void); 实心4面体\n\nvoid glutWireDodecahedron(GLdouble radius); 线框12面体\nvoid glutSolidDodecahedron(GLdouble radius); 实心12面体\n\nvoid glutWireCone(GLdouble radius, GLdouble height, GLint slices, GLint stacks); 线框圆锥体\nvoid glutSolidCone(GLdouble radius, GLdouble height, GLint slices, GLint stacks); 实心圆锥体\n\nvoid glutWireTeapot(GLdouble size); 线框茶壶\nvoid glutSolidTeapot(GLdouble size); 实心茶壶\n\n函数中，radius表示球体的半径，slices表示球体围绕z轴分割的数目，stacks表示球体沿着z轴分割的数目。\n\n绘制中心在模型坐标原点,半径为radius的球体,球体围绕z轴分割slices次,球体沿着z轴分割stacks次\n```\n\n\n\n# 三、OpenGL流程详细介绍\n\n## 1、简介\n\nOpenGL（Open Graphics Library）是一个跨编程语言、跨平台的编程图形程序接口，它将计算机的资源抽象称为一个个OpenGL的对象，对这些资源的操作抽象为一个个的OpenGL指令。\n\nOpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。\n\n本文介绍的OpenGL版本是基于OpenGL ES 3.0的。这也是目前覆盖率最高的OpenGL版本，被广泛运用在各种终端设备上。\n\n## 2、OpenGL上下文（Context）\n\n在应用程序调用任何OpenGL的指令之前，需要安排首先创建一个OpenGL的上下文。这个上下文是一个非常庞大的状态机，保存了OpenGL中的各种状态，这也是OpenGL指令执行的基础。\n\nOpenGL的函数不管在哪个语言中，都是类似C语言一样的面向过程的函数，本质上都是对OpenGL上下文这个庞大的状态机中的某个状态或者对象进行操作，当然你得首先把这个对象设置为当前对象。因此，通过对OpenGL指令的封装，是可以将OpenGL的相关调用封装成为一个面向对象的图形API的。\n\n由于OpenGL上下文是一个巨大的状态机，切换上下文往往会产生较大的开销，但是不同的绘制模块，可能需要使用完全独立的状态管理。因此，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源。这样的方案，会比反复切换上下文，或者大量修改渲染状态，更加合理高效的。\n\n## 3、帧缓冲区（FrameBuffer）\n\nOpenGL是图形API，因此可以说所有的运算和结果最终都是需要通过图像进行输出的。那么绘图必然就需要有一块画板，而帧缓冲区就是OpenGL中的画板。但是特别需要注意的是，帧缓冲区不是常规意义缓冲区（就像鲸鱼不是鱼一样），它并不是实际存储数据的对象，类似画画的时候，需要在画板上放一块画布，才能实际在画布上进行绘画，这些画布可以是纹理（Texture）或者是渲染缓冲区（RenderBuffer），而放置这些画布的位置被称为帧缓冲区的附着（Attachment）。\n\n### 3.1、附着（Attachment）\n\n附着可以理解为画板上的夹子，夹住了哪个画布，就往对应画布上输出数据。\n\n在帧缓冲区中可以附着3种类型的附着，颜色附着（ColorAttachment），深度附着（DepthAttachment），模板附着（StencilAttachment）。这三种附着对应的存储区域也被称为颜色缓冲区（ColorBuffer），深度缓冲区（DepthBuffer），模板缓冲区（StencilBuffer）。\n\n颜色附着输出绘制图像的颜色数据，也就是平时常见的图像的RGBA数据。如果使用了多渲染目标(Multiple Render Targets)技术，那么颜色附着的数量可能会大于一。\n\n深度附着输出绘制图像的深度数据，深度数据主要在3D渲染中使用，一般用于判断物体的远近来实现遮挡的效果。\n\n模板附着输出模板数据，模板数据是渲染中较为高级的用法，一般用于渲染时进行像素级别的剔除和遮挡效果，常见的应用场景比如三维物体的描边。\n\n## 4、纹理（Texture）和渲染缓冲区（RenderBuffer）\n\n前面已经说过，帧缓冲区并不是实际存储数据的地方，实际存储图像数据数据的对象就是纹理和渲染缓冲区。\n\n他们三者的关系是这样的，纹理或渲染缓冲区作为帧缓冲区的附着。\n\n那么，纹理和渲染缓冲区又有什么关系和区别呢？\n\n纹理和渲染缓冲区同样是存储图像的对象。一般来说，渲染缓冲区对应操作系统提供的窗口，而纹理代表列离屏的图像存储区域。因此，渲染缓冲区都是2D的图像类型，而纹理一般有立方体纹理，1D、2D、3D纹理等类型，同时纹理还额外支持了mipmap等其他特性。\n\n值得注意的是，一般来说渲染缓冲区和纹理不能同时挂载在同一个帧缓冲区上。\n\n## 5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）\n\n准备好了画布之后，就要开始画图了。画图一般是先画好图像的骨架，然后再往骨架里面填充颜色，这对于OpenGL也是一样的。顶点数据就是要画的图像的骨架，和现实中不同的是，OpenGL中的图像都是由图元组成。在OpenGL ES中，有3种类型的图元：点、线、三角形。那这些顶点数据最终是存储在哪里的呢？开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组。而性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区。\n\n## 6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）\n\n其实我觉得索引在OpenGL叫Element确实有点不够贴切，而在DirectX中叫做IndexBuffer更加合适一些。\n\n索引数据的目的主要是为了实现顶点的复用，在绘制图像时，总是会有一些顶点被多个图元共享，而反复对这个顶点进行运算常常是没有必要的（也有某些特殊场景需要）。因此对通过索引数据，指示OpenGL绘制顶点的顺序，不但能防止顶点的重复运算，也能在不修改顶点数据的情况下，一定程度的重新组合图像。\n\n和顶点数据一样，索引数据也可以以索引数组的形式存储在内存当中，调用绘制函数时传入；或者提前分配一块显存，将索引数据存储在这块显存当中，这块显存就被称为索引缓冲区。同样的，使用缓冲区的方式，性能一般会比直接使用索引数组的方式更加高效。\n\nOpenGL ES提供了2种主要的绘制方法：glDrawArrays和glDrawElements。前者对应的就是没有索引数据的情况，后者对应的是有索引数据的情况。\n\n## 7、着色器程序（Shader）\n\n在固定渲染管线时代，这一步并不是必须的。而是由内置的一段包含了光照、坐标变换、裁剪等等诸多功能的固定shader程序来完成。而可自定义shader，可以说是现代图形API最重要的能力了，没有之一。可以说，shader提供对图形运算的精细操作，带来了各式各样的处理能力，极度的丰富了图形API所能实现的效果。\n\nOpenGL和其他主流的图形API早在好几年前，就全面的将固定渲染管线架构变为了可编程渲染管线。因此，OpenGL在实际调用绘制函数之前，还需要指定一个由shader编译成的着色器程序。\n\n常见的着色器主要有顶点着色器（VertexShader），片段着色器（FragmentShader）/像素着色器（PixelShader），几何着色器（GeometryShader），曲面细分着色器（TessellationShader）。片段着色器和像素着色器只是在OpenGL和DX中的不同叫法而已。可惜的是，直到OpenGL ES 3.0，依然只支持了顶点着色器和片段着色器这两个最基础的着色器。\n\nOpenGL在处理shader时，和其他编译器一样。通过编译、链接等步骤，生成了着色器程序（glProgram），着色器程序同时包含了顶点着色器和片段着色器的运算逻辑。在OpenGL进行绘制的时候，首先由顶点着色器对传入的顶点数据进行运算。再通过图元装配，将顶点转换为图元。然后进行光栅化，将图元这种矢量图形，转换为栅格化数据。最后，将栅格化数据传入片段着色器中进行运算。片段着色器会对栅格化数据中的每一个像素进行运算，并决定像素的颜色，也可以在这个阶段将某些像素丢弃。\n\n其中像素的颜色可以是具体的数值或者是由某种算法计算而来的。如果图元有纹理，就必须用纹理来产生图元的二维渲染图象上每个像素的颜色。对于图元在二维屏幕上图象的每个像素来说，都必须从纹理中获得一个颜色值。我们把这一过程称为纹理过滤（texture filtering），纹理过滤根据不同的过滤方式会由一个或多个像素确定最终获得的颜色。表示这个像素位置的数据被称为纹理坐标（TextureCoordinate）而寻找这个纹理中对应像素位置的方法被称为纹理寻址方式或者纹理环绕方式（TextureWrap）。\n\n最终，没有被丢弃的像素，下一步会进入测试阶段。通过了深度测试和模板测试，会和帧缓冲区上的颜色附着（FrameBuffer上的ColorAttachment）上的颜色进行混合，决定最终留在画布上的颜色是什么。\n\n![](2.png)\n\n<img src=\"3.png\" style=\"zoom:50%;\" />\n\n### 7.1、顶点着色器（VertexShader）\n\n顶点着色器是OpenGL中用于计算顶点属性的程序。顶点着色器是逐顶点运算的程序，也就是说每个顶点数据都会执行一次顶点着色器，当然这是并行的，并且顶点着色器运算过程中无法访问其他顶点的数据。\n\n顶点着色器的数据输入主要有两种，统一变量（Uniform）、顶点属性（VertexAttribute）。统一变量在所有顶点运算中是一样的，而顶点属性则是从外部输入的顶点数据中获取，一般在每个顶点运算中都是不同的。\n\n一般来说典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照运算等等。顶点坐标由自身坐标系转换到归一化坐标系的运算，就是在这里发生的。\n\n同时顶点着色器的输出结果，也会作为片段着色器的输入。\n\n![](4.png)\n\n### 7.2、片段着色器（FragmentShader）\n\n片段着色器是OpenGL中用于计算片段（像素）颜色的程序。片段做社区是逐像素运算的程序，也就是说每个像素都会执行一次片段着色器，当然也是并行的。\n\n片段着色器的的数据输入主要有三种种，统一变量（Uniform）、顶点着色器输入变量（也被称为可变变量varying）、采样器（Sampler）。统一变量的值，在同个OpenGL着色器程序中的顶点着色器和片段着色器中是一致的。顶点着色器输入变量在每个像素运算中则一般是不同的，它的值由组成图元的顶点的顶点着色器运算输出的值，根据像素位置进行插值的结果而决定。采样器则是用于从设定好的纹理中，获取纹理的像素颜色的。\n\n在片段着色器中允许丢弃像素，而使得像素不参与后续的运算。\n\n![](5.png)\n\n## 8、逐片段操作（Per-Fragment Operation）\n\n \n\n![](6.png)\n\n \n\n### 8.1、测试（Test）\n\n在着色器程序完成之后，我们得到了像素数据。这些数据必须要通过测试才能最终绘制到画布，也就是帧缓冲上的颜色附着上。\n\n测试主要可以分为像素所有者测试（PixelOwnershipTest）、裁剪测试（ScissorTest）、模板测试（StencilTest）和深度测试（DepthTest），执行的顺序也是按照这个顺序进行执行。\n\n最开始进行的测试是像素所有者测试，主要是剔除不属于当前程序的像素运算。\n\n之后裁剪测试，主要是剔除窗口区域之外的像素。\n\n这两个测试都是由OpenGL内部实现的，无需开发者干预，因此不再进行赘述。\n\n深度测试，主要是通过对像素的运算出来的深度，也就是像素离屏幕的距离进行对比，根据OpenGL设定好的深度测试程序，决定是否最终渲染到画布上。一般默认的程序是将离屏幕较近的像素保留，而将离屏幕较远的像素丢弃。如果像素最终被渲染到画布上，根据设定好的OpenGL深度覆写状态，可能会更新帧缓冲区上深度附着的值，方便进行下一次的比较。\n\n模板测试和深度测试的执行原理一致，但是执行的顺序是在深度测试之前的，放在后面 主要是比深度测试更加难以理解一些，初学者可以暂时跳过这个部分。模板测试同样也是通过模板测试程序去决定最终的像素是否丢弃，同样也是根据OpenGL的模板覆写状态决定是否更新像素的模板值。模板测试给开发者提供了高性能的裁剪方案，三维物体的描边技术，就是模板测试典型的用处之一。\n\n### 8.2、混合（Blending）\n\n在测试阶段之后，如果像素依然没有被剔除，那么像素的颜色将会和帧缓冲区中颜色附着上的颜色进行混合，混合的算法可以通过OpenGL的函数进行指定。但是OpenGL提供的混合算法是有限的，如果需要更加复杂的混合算法，一般可以通过像素着色器进行实现，当然性能会比原生的混合算法差一些。\n\n### 8.3、抖动（Dithering）\n\n在混合阶段过后，根据OpenGL的状态设置，会决定是否有抖动这个阶段。\n\n抖动是一种针对对于可用颜色较少的系统，可以以牺牲分辨率为代价，通过颜色值的抖动来增加可用颜色数量的技术。抖动操作是和硬件相关的，允许程序员所做的操作就只有打开或关闭抖动操作。实际上，若机器的分辨率已经相当高，激活抖动操作根本就没有任何意义。默认情况下，抖动是激活的。\n\n![](7.png)\n\n## 9、渲染到纹理\n\n有些OpenGL程序并不希望渲染出来的图像立即显示在屏幕上，而是需要多次渲染。可能其中一次渲染的结果是下次渲染的输入。因此，如果帧缓冲区的颜色附着设置为一张纹理，那么渲染完成之后，可以重新构造新的帧缓冲区，并将上次渲染出来的纹理作为输入，重新进行前面所述的流程。\n\n## 10、渲染上屏/交换缓冲区(SwapBuffer)\n\n前面已经提过，渲染缓冲区一般映射的是系统的资源比如窗口。如果将图像直接渲染到窗口对应的渲染缓冲区，则可以将图像显示到屏幕上。\n\n但是，值得注意的是，如果每个窗口只有一个缓冲区，那么在绘制过程中屏幕进行了刷新，窗口可能显示出不完整的图像。\n\n为了解决这个问题，常规的OpenGL程序至少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在一个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示。\n\n由于显示器的刷新一般是逐行进行的，因此为了防止交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进行交换，这个信号就被称为垂直同步信号，这个技术被称为垂直同步。\n\n使用了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进行下一帧的渲染，使得帧率无法完全达到硬件允许的最高水平。为了解决这个问题，引入了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，而垂直同步发生时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利用硬件性能的目的。\n\n![](9.jpg)\n\n### 11.顶点数据最终加工成图像的过程\n\n**着色器（shader）**是在GPU上运行的小程序，GPU有成千上万个处理核心，能进行非常多的并行计算，在些计算的逻辑就写在着色器里，上图中蓝色部分就是表示我们可以通过写shader来进行控制的部分\n\n**顶点着色器**先把3D坐标转换成另一种3D坐标，也就是OpenGL世界里的坐标\n\t\t**图元着色器**会把顶点着色器传进来的坐标连接成一个图形\n\t\t**几何着色器**可以进一步构造新的图元或其他形状\n\t\t**光栅化**就是把图元映射成屏幕上对应的像素\n\t\t**片段着色器**用来给物体上色\n\t\t**测试与混合**如果物体对应Alpha值所表示的颜色带有一定的透明，它后面有不完全透明的物体，则要跟后面物体的颜色进行混合，以此达到透明效果，如果被前面物体挡住了，就丢弃被挡住部分的像素\n\n整个流程就像工厂里的流水线一样，把原料（顶点数据）从一头放入，经过一道道工序的处理，最终变成产品，所以这个渲染流程也叫渲染流水线\n\n![](15.png)\n\n# 四、例程\n\n## 1.创建窗口\n\n```cpp\n// System Headers\n#include <glad/glad.h>//函数加载\n#include <GLFW/glfw3.h>//窗口管理\n\n// Standard Headers\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height);//回调函数原型声明\nvoid processInput(GLFWwindow *window);\n\n// settings\nconst unsigned int SCR_WIDTH = 800;\nconst unsigned int SCR_HEIGHT = 600;\n\nint main() {\n    glfwInit();//初始化    \n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);//设置主版本号\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);//设置次版本号\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);//使用核心模式\n    //创建一个窗口对象,参数：窗口宽，窗口高，窗口标题，暂时忽略，暂时忽略\n    GLFWwindow *window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"GLFW 3.3.1\", NULL, NULL);\n    if (window == NULL) {\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();//释放内存\n        return -1;\n    }\n    //通知GLFW将我们窗口的上下文设置为当前线程的主上下文\n    glfwMakeContextCurrent(window);\n    //对窗口注册一个回调函数,每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n    //初始化GLAD用来管理OpenGL的函数指针\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n    //设置视口，OpenGL幕后的坐标转窗口坐标将以此为参考\n    //OpenGL的坐标最大最小值为1和-1\n    //如下x轴-1~1对应窗口坐标0~800,y轴-1～1对应窗口坐标0~600\n    //如OpenGL坐标（0，0）对应窗口坐标（400,300），（-0.5,0.5）对应（200,450）\n    glViewport(0,0,800,600);\n    //渲染循环\n    while(!glfwWindowShouldClose(window)) {\n        //监视键盘 输入\n        processInput(window);\n        // 渲染指令\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);//清除颜色缓冲\n        //GL_COLOR_BUFFER_BIT 颜色缓冲\n        //GL_DEPTH_BUFFER_BIT 深度缓冲\n        //GL_STENCIL+BUFFER_BIT 模板缓冲\n        glClear(GL_COLOR_BUFFER_BIT);\n        //交换颜色缓冲，OpenGL绘图的时候，前缓冲用于显示，后缓冲就在渲染\n        //当后缓冲渲染完毕，前缓冲和后缓冲互换，后缓冲变前缓冲，前缓冲变后缓冲\n        // 检查并调用事件，交换缓冲\n        glfwSwapBuffers(window);//检查触发事件\n        //消息分发函数 检测有没有触发窗口消息，然后调用对应回调函数\n        glfwPollEvents();\n    }\n    //释放/删除之前的分配的所有资源,释放内存\n    glfwTerminate();\n    return EXIT_SUCCESS;\n}\n\n//输入控制，检查用户是否按下了返回键(Esc)\nvoid processInput(GLFWwindow *window) {\n    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {\n        glfwSetWindowShouldClose(window, true);\n    }\n}\n\n// 当用户改变窗口的大小的时候，视口也应该被调整\nvoid framebuffer_size_callback(GLFWwindow *window, int width, int height) {\n    // 注意：对于视网膜(Retina)显示屏，width和height都会明显比原输入值更高一点。\n    glViewport(0, 0, width, height);\n}\n```\n\n## 2.能控制移动的彩色矩形\n\n```cpp\n#include<glad/glad.h>\n#include<GLFW/glfw3.h>\n#include<iostream>\n\nusing namespace std;\n\n//顶点着色器\nconst char *vertexShaderSource = \n\"#version 330 core\\n\"\n\"layout (location = 0) in vec3 aPos;\\n\"\n\"layout (location = 1) in vec3 aColor;\\n\"\n\"out vec3 ourColor;\\n\"\n\"uniform vec2 pos;\\n\"\n\"void main(){\\n\"\n\"    gl_Position = vec4(aPos.x+pos.x,aPos.y+pos.y,aPos.z,1.0);\\n\"\n\"    ourColor=aColor;\\n\"\n\"\\n}\";\n\n//片段着色器\nconst char *fragmentShaderSource =\n\"#version 330 core\\n\"\n\"out vec4 FragColor;\\n\"\n\"in vec3 ourColor;\\n\"\n\"void main(){\\n\"\n\"    FragColor = vec4(ourColor,0.8f);\"\n\"}\\n\";\n\n//顶点和颜色数据\nfloat vertices[] = {\n    // 位置              // 颜色\n     0.5f, 0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下\n    -0.5f, 0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下\n     -0.5f,  -0.5f, 0.0f,  0.0f, 0.0f, 1.0f,    // 顶部\n     0.5f,  -0.5f, 0.0f,  0.5f, 0.5f, 0.5f    // 顶部\n};\n//索引\nunsigned int indices[] = { // 注意索引从0开始! \n    0, 1, 3, // 第一个三角形\n    1, 2, 3  // 第二个三角形\n};\n\n//矩形平面坐标\nfloat x=0,y=0,speed=0.02f;\n\n//编译着色器\nint CompileShader(const char* source,int type)\n{\n    int shader=glCreateShader(type);\n    glShaderSource(shader,1,&source,nullptr);\n    glCompileShader(shader);\n\n    int ret=0;\n    char log[512]={0};\n    glGetShaderiv(shader,GL_COMPILE_STATUS,&ret);\n    if(!ret){\n        glGetShaderInfoLog(shader,512,nullptr,log);\n        cout<<\"着色器编译失败：\"<<log<<endl;\n        return 0;\n    }\n    return shader;\n}\n\n//窗口大小变动的回调函数\nvoid framebuffer_size_callback(GLFWwindow* window,int width,int height)\n{\n    glViewport(0,0,width,height);\n}\n\n//如果ESC键按下，则关闭窗口\nvoid processInput(GLFWwindow *window)\n{\n    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS){\n        glfwSetWindowShouldClose(window, true);\n    }\n    if(glfwGetKey(window,GLFW_KEY_D) == GLFW_PRESS){\n        x>=0.5f ? x=0.5f : x+=speed;   \n    } \n    if(glfwGetKey(window,GLFW_KEY_A) == GLFW_PRESS){ \n        x<=-0.5f ? x=-0.5f : x-=speed;\n    }\n    if(glfwGetKey(window,GLFW_KEY_W) == GLFW_PRESS){\n        y>=0.5f ? y=0.5f : y+=speed;\n    } \n    if(glfwGetKey(window,GLFW_KEY_S) == GLFW_PRESS){\n        y<=-0.5f ? y = -0.5f : y-=speed;\n    }\n}\n\nint main()\n{\n    glfwInit();//初始化\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,3); //主版本号\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,3);//次版本号\n    glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);//采用核心模式\n    \n    //参数：窗口宽，窗口高，窗口标题，暂时忽略，暂时忽略\n    GLFWwindow* window = glfwCreateWindow(800,600,\"这是窗口标题\",nullptr,nullptr);\n    if(!window)\n    {\n        cout<<\"创建窗口失败！\"<<endl;\n        glfwTerminate();//释放内存\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n\n    //初始化GLAD，GLAD用于管理函数指针\n    if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){\n        cout<<\"初始化GLAD失败\"<<endl;\n        return -1;\n    }\n    \n    //设置视口，OpenGL幕后的坐标转窗口坐标将以此为参考\n    //OpenGL的坐标最大最小值为1和-1\n    //如下x轴-1~1对应窗口坐标0~800,y轴-1～1对应窗口坐标0~600\n    //如OpenGL坐标（0，0）对应窗口坐标（400,300），（-0.5,0.5）对应（200,450）\n    glViewport(0,0,800,600);\n    \n    //编译着色器\n    int vertexShader=CompileShader(vertexShaderSource, GL_VERTEX_SHADER);\n    if(!vertexShader) return -1;\n    int fragmentShader=CompileShader(fragmentShaderSource, GL_FRAGMENT_SHADER);\n    if(!fragmentShader) return -1;\n    \n    //链接着色器程序\n    int shaderProgram=glCreateProgram();\n    glAttachShader(shaderProgram,vertexShader);\n    glAttachShader(shaderProgram,fragmentShader);\n    glLinkProgram(shaderProgram);\n    glDeleteShader(vertexShader);\n    glDeleteShader(fragmentShader);\n\n    //创建VAO\n    GLuint VAO=0;\n    glGenVertexArrays(1,&VAO);\n    glBindVertexArray(VAO);\n    \n    //创建VBO\n    GLuint VBO=0;\n    glGenBuffers(1,&VBO);\n    glBindBuffer(GL_ARRAY_BUFFER,VBO);\n    glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);\n\n    //创建EBO\n    GLuint EBO=0;\n    glGenBuffers(1,&EBO);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,EBO);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER,sizeof(indices),indices,GL_STATIC_DRAW);\n\n    //顶点数据 从偏移0 * 6*sizeof(float)处开始拿3个float\n    //之后再从偏移1 * 6*sizeof(float)处开始拿3个float 直到拿完\n    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,6*sizeof(float),(void*)0);\n    glEnableVertexAttribArray(0);\n    //颜色数据同上 不过偏移是从3*sizeof(float)开始，不是从0\n    glVertexAttribPointer(1,3,GL_FLOAT,GL_FALSE,6*sizeof(float),(void*)(3*sizeof(float)));\n    glEnableVertexAttribArray(1);\n\n    int index=glGetUniformLocation(shaderProgram,\"pos\");\n    \n    //注册窗口大小变化回调函数\n    glfwSetFramebufferSizeCallback(window,framebuffer_size_callback);\n\n    //窗口循环 如果窗口被关闭，则退出循环\n    while(!glfwWindowShouldClose(window))\n    {\n        //监视键盘输入\n        processInput(window);\n        \n        //清除颜色缓冲\n        glClearColor(0.2f,0.3f,0.3f,0.8f);\n        //GL_COLOR_BUFFER_BIT 颜色缓冲\n        //GL_DEPTH_BUFFER_BIT 深度缓冲\n        //GL_STENCIL+BUFFER_BIT 模板缓冲\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        glUseProgram(shaderProgram);\n        glBindVertexArray(VAO);\n        glUniform2f(index,x,y);\n        glDrawElements(GL_TRIANGLES,6,GL_UNSIGNED_INT,0);\n\n        //交换颜色缓冲，OpenGL绘图的时候，前缓冲用于显示，后缓冲就在渲染\n        //当后缓冲渲染完毕，前缓冲和后缓冲互换，后缓冲变前缓冲，前缓冲变后缓冲\n        glfwSwapBuffers(window);\n        //消息分发函数 检测有没有触发窗口消息，然后调用对应回调函数\n        glfwPollEvents();\n    }\n\n    glDeleteVertexArrays(1,&VAO);\n    glDeleteBuffers(1,&VBO);\n    glDeleteBuffers(1,&EBO);\n    glfwTerminate();\n\n    return 0;\n}\n\n```\n\n","slug":"4-1-OpenGL","published":1,"updated":"2023-04-14T13:30:56.997Z","layout":"post","photos":[],"link":"","_id":"clggl89ar0000y4obh6kl4xmf","content":"<h1 id=\"一、什么是OpenGL\"><a href=\"#一、什么是OpenGL\" class=\"headerlink\" title=\"一、什么是OpenGL?\"></a>一、什么是OpenGL?</h1><h2 id=\"1-OpenGL简介\"><a href=\"#1-OpenGL简介\" class=\"headerlink\" title=\"1.OpenGL简介\"></a>1.OpenGL简介</h2><p>OpenGL是渲染2D、3D矢量图形硬件的一种软件接口。本质上说，它是一个3D图形和模型库，具有高度的可移植性，并且具有非常快的渲染速度。OpenGL并不是一种语言，而是更像一个C运行时函数库。它提供了一些预包装的功能，帮助开发人员编写功能强大的三维应用程序。 OpenGL可以再多种操作系统平台上运行，例如各种版本的Windows、UNIX&#x2F;Linux、Mac OS 和 OS&#x2F;2等。如今，OpenGL广泛流行于游戏、医学影像、地理信息、气象模拟等领域，是高性能图像和交互性场景处理的工业标准。</p>\n<span id=\"more\"></span>\n\n<p>OpenGL的高效实现（利用了图形加速硬件）存在于Windows，部分UNIX平台和Mac OS。这些实现一般由显示设备厂商提供，而且非常依赖于该厂商提供的硬件。</p>\n<p>一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范(Specification)。</p>\n<p>OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定（译注：这里开发者是指编写OpenGL库的人）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。</p>\n<p>实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。</p>\n<p>由于OpenGL的大多数实现都是由显卡厂商编写的，当产生一个bug时通常可以通过升级显卡驱动来解决。这些驱动会包括你的显卡能支持的最新版本的OpenGL，这也是为什么总是建议你偶尔更新一下显卡驱动。</p>\n<p>所有版本的OpenGL规范文档都被公开的寄存在Khronos那里。有兴趣的读者可以找到OpenGL3.3（我们将要使用的版本）的规范文档。如果你想深入到OpenGL的细节（只关心函数功能的描述而不是函数的实现），这是个很好的选择。如果你想知道每个函数具体的运作方式，这个规范也是一个很棒的参考。</p>\n<h2 id=\"2-核心模式和立即渲染模式\"><a href=\"#2-核心模式和立即渲染模式\" class=\"headerlink\" title=\"2.核心模式和立即渲染模式\"></a>2.核心模式和立即渲染模式</h2><p>早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少能控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。</p>\n<p>当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从OpenGL实际运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。</p>\n<p>这也是为什么我们的教程面向OpenGL3.3的核心模式。虽然上手更困难，但这份努力是值得的。</p>\n<p>现今，更高版本的OpenGL已经发布（写作时最新版本为4.5），你可能会问：既然OpenGL 4.5 都出来了，为什么我们还要学习OpenGL 3.3？答案很简单，所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代OpenGL版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本OpenGL的新特性。</p>\n<p>当使用新版本的OpenGL特性时，只有新一代的显卡能够支持你的应用程序。这也是为什么大多数开发者基于较低版本的OpenGL编写程序，并只提供选项启用新版本的特性。</p>\n<p>在有些教程里你会看见更现代的特性，它们同样会以这种红色注释方式标明。</p>\n<h2 id=\"3-扩展\"><a href=\"#3-扩展\" class=\"headerlink\" title=\"3.扩展\"></a>3.扩展</h2><p>OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。</p>\n<p>使用扩展的代码大多看上去如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(GL_ARB_extension_name)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用硬件支持的全新的现代特性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不支持此扩展: 用旧的方式去做</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 使用OpenGL3.3时，我们很少需要使用扩展来完成大多数功能，当需要的时候，本教程将提供适当的指示。 </p>\n<h2 id=\"4-状态机\"><a href=\"#4-状态机\" class=\"headerlink\" title=\"4.状态机\"></a>4.状态机</h2><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。</p>\n<p>假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。</p>\n<p>当使用OpenGL的时候，我们会遇到一些状态设置函数(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。</p>\n<h2 id=\"5-对象\"><a href=\"#5-对象\" class=\"headerlink\" title=\"5.对象\"></a>5.对象</h2><p>OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。</p>\n<p>在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">object_name</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">float</span>  option1;</span><br><span class=\"line\">    <span class=\"type\">int</span>    option2;</span><br><span class=\"line\">    <span class=\"type\">char</span>[] name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在有些教程中一直使用的都是OpenGL的基本类型，但由于作者觉得在本教程系列中并没有一个必须使用它们的原因，所有的类型都改为了自带类型。但是请仍然记住，使用OpenGL的类型的好处是保证了在各平台中每一种类型的大小都是统一的。你也可以使用其它的定宽类型(Fixed-width Type)来实现这一点。</p>\n<p>当我们使用一个对象时，通常看起来像如下一样（把OpenGL上下文看作一个大的结构体）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// OpenGL的状态</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OpenGL_Context</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    object* object_Window_Target;</span><br><span class=\"line\">    ...     </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建对象</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> objectId = <span class=\"number\">0</span>;</span><br><span class=\"line\">glGenObject(<span class=\"number\">1</span>, &amp;objectId);</span><br><span class=\"line\"><span class=\"comment\">// 绑定对象至上下文</span></span><br><span class=\"line\">glBindObject(GL_WINDOW_TARGET, objectId);</span><br><span class=\"line\"><span class=\"comment\">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></span><br><span class=\"line\">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class=\"number\">800</span>);</span><br><span class=\"line\">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class=\"number\">600</span>);</span><br><span class=\"line\"><span class=\"comment\">// 将上下文对象设回默认</span></span><br><span class=\"line\">glBindObject(GL_WINDOW_TARGET, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这一小段代码展现了你以后使用OpenGL时常见的工作流。我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。</p>\n<p>目前提供的示例代码只是OpenGL如何操作的一个大致描述，通过阅读以后的教程你会遇到很多实际的例子。</p>\n<p>使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。</p>\n<h1 id=\"二、开发环境配置\"><a href=\"#二、开发环境配置\" class=\"headerlink\" title=\"二、开发环境配置\"></a>二、开发环境配置</h1><h2 id=\"1-Ubuntu开发环境配置\"><a href=\"#1-Ubuntu开发环境配置\" class=\"headerlink\" title=\"1.Ubuntu开发环境配置\"></a>1.Ubuntu开发环境配置</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用 apt 安装 OpenGL 和开发包</span></span><br><span class=\"line\">sudo apt-get install build-essential libgl1-mesa-dev</span><br><span class=\"line\">sudo apt-get install freeglut3-dev</span><br><span class=\"line\">sudo apt-get install libglew-dev libsdl2-dev libsdl2-image-dev libglm-dev libfreetype6-dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-测试程序\"><a href=\"#2-测试程序\" class=\"headerlink\" title=\"2.测试程序\"></a>2.测试程序</h2><p> 用vim写一段测试程序，测试下开发环境是否安装成功。 </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.c</span></span><br><span class=\"line\"><span class=\"comment\">/* light.c</span></span><br><span class=\"line\"><span class=\"comment\">此程序利用GLUT绘制一个OpenGL窗口，并显示一个加以光照的球。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/* 由于头文件glut.h中已经包含了头文件gl.h和glu.h，所以只需要include 此文件*/</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;GL/glut.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/* 初始化材料属性、光源属性、光照模型，打开深度缓冲区 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">init</span> <span class=\"params\">( <span class=\"type\">void</span> )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GLfloat mat_specular [ ] = &#123; <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span> &#125;;</span><br><span class=\"line\">    GLfloat mat_shininess [ ] = &#123; <span class=\"number\">50.0</span> &#125;;</span><br><span class=\"line\">    GLfloat light_position [ ] = &#123; <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span> &#125;;</span><br><span class=\"line\">    glClearColor ( <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span> );</span><br><span class=\"line\">    glShadeModel ( GL_SMOOTH );</span><br><span class=\"line\">    glMaterialfv ( GL_FRONT, GL_SPECULAR, mat_specular);</span><br><span class=\"line\">    glMaterialfv ( GL_FRONT, GL_SHININESS, mat_shininess);</span><br><span class=\"line\">    glLightfv ( GL_LIGHT0, GL_POSITION, light_position);</span><br><span class=\"line\">    glEnable (GL_LIGHTING);</span><br><span class=\"line\">    glEnable (GL_LIGHT0);</span><br><span class=\"line\">    glEnable (GL_DEPTH_TEST);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*调用GLUT函数，绘制一个球*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">display</span> <span class=\"params\">( <span class=\"type\">void</span> )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class=\"comment\">// 1. 调用glClear()清空窗口</span></span><br><span class=\"line\">    glutSolidSphere (<span class=\"number\">1.0</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>);<span class=\"comment\">/*调用GLUT函数，绘制一个球*/</span></span><br><span class=\"line\">    glFlush ();<span class=\"comment\">// 3. 请求将图像绘制到窗口</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"comment\">// main()函数用于创建窗口,调用init()函数,最后进入到事件循环(event loop).这里仍会看到一些以gl开头的函数,但和上面的有所不同.这些函数来自第三方库,以便我们可以在不同的系统中更方便地使用OpenGL.这里我们使用的是GLUT  </span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* GLUT环境初始化*/</span></span><br><span class=\"line\">    glutInit (&amp;argc, argv);</span><br><span class=\"line\">    <span class=\"comment\">/* 显示模式初始化 */</span></span><br><span class=\"line\">    glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);</span><br><span class=\"line\">    <span class=\"comment\">/* 定义窗口大小 */</span></span><br><span class=\"line\">    glutInitWindowSize (<span class=\"number\">300</span>, <span class=\"number\">300</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 定义窗口位置 */</span></span><br><span class=\"line\">    glutInitWindowPosition (<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 显示窗口，窗口标题为执行函数名 */</span></span><br><span class=\"line\">    glutCreateWindow ( argv [ <span class=\"number\">0</span> ] );</span><br><span class=\"line\">    <span class=\"comment\">/* 调用OpenGL初始化函数 */</span></span><br><span class=\"line\">    init ( );</span><br><span class=\"line\">    <span class=\"comment\">/* 注册OpenGL绘图函数 */</span></span><br><span class=\"line\">    glutDisplayFunc ( display );</span><br><span class=\"line\">    <span class=\"comment\">// /* 进入GLUT消息循环，开始执行程序 */</span></span><br><span class=\"line\">    glutMainLoop( );<span class=\"comment\">//用于进入事件处理循环，仅退出窗口时，函数返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-编译运行\"><a href=\"#3-编译运行\" class=\"headerlink\" title=\"3.编译运行\"></a>3.编译运行</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc test.c -o test -lGL -lglut</span><br><span class=\"line\">./test</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-效果图\"><a href=\"#4-效果图\" class=\"headerlink\" title=\"4.效果图\"></a>4.效果图</h2><img src=\"1.png\" style=\"zoom: 25%;\" />\n\n<h2 id=\"5-附录：\"><a href=\"#5-附录：\" class=\"headerlink\" title=\"5.附录：\"></a>5.附录：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireSphere</span><span class=\"params\">(GLdouble radius, GLint slices, GLint stacks)</span></span>; 线框球</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidSphere</span><span class=\"params\">(GLdouble radius, GLint slices, GLint stacks)</span></span>; 实心球</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireCube</span><span class=\"params\">(GLdouble size)</span></span>; 线框立方体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidCube</span><span class=\"params\">(GLdouble size)</span></span>; 实心立方体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireTorus</span><span class=\"params\">(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings)</span></span>; 线框圆环</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidTorus</span><span class=\"params\">(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings)</span></span>; 实心圆环</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireIcosahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 线框<span class=\"number\">20</span>面体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidIcosahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 实心<span class=\"number\">20</span>面体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireOctahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 线框<span class=\"number\">8</span>面体 </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidOctahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 实心<span class=\"number\">8</span>面体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireTetrahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 线框<span class=\"number\">4</span>面体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidTetrahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 实心<span class=\"number\">4</span>面体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireDodecahedron</span><span class=\"params\">(GLdouble radius)</span></span>; 线框<span class=\"number\">12</span>面体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidDodecahedron</span><span class=\"params\">(GLdouble radius)</span></span>; 实心<span class=\"number\">12</span>面体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireCone</span><span class=\"params\">(GLdouble radius, GLdouble height, GLint slices, GLint stacks)</span></span>; 线框圆锥体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidCone</span><span class=\"params\">(GLdouble radius, GLdouble height, GLint slices, GLint stacks)</span></span>; 实心圆锥体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireTeapot</span><span class=\"params\">(GLdouble size)</span></span>; 线框茶壶</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidTeapot</span><span class=\"params\">(GLdouble size)</span></span>; 实心茶壶</span><br><span class=\"line\"></span><br><span class=\"line\">函数中，radius表示球体的半径，slices表示球体围绕z轴分割的数目，stacks表示球体沿着z轴分割的数目。</span><br><span class=\"line\"></span><br><span class=\"line\">绘制中心在模型坐标原点,半径为radius的球体,球体围绕z轴分割slices次,球体沿着z轴分割stacks次</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"三、OpenGL流程详细介绍\"><a href=\"#三、OpenGL流程详细介绍\" class=\"headerlink\" title=\"三、OpenGL流程详细介绍\"></a>三、OpenGL流程详细介绍</h1><h2 id=\"1、简介\"><a href=\"#1、简介\" class=\"headerlink\" title=\"1、简介\"></a>1、简介</h2><p>OpenGL（Open Graphics Library）是一个跨编程语言、跨平台的编程图形程序接口，它将计算机的资源抽象称为一个个OpenGL的对象，对这些资源的操作抽象为一个个的OpenGL指令。</p>\n<p>OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。</p>\n<p>本文介绍的OpenGL版本是基于OpenGL ES 3.0的。这也是目前覆盖率最高的OpenGL版本，被广泛运用在各种终端设备上。</p>\n<h2 id=\"2、OpenGL上下文（Context）\"><a href=\"#2、OpenGL上下文（Context）\" class=\"headerlink\" title=\"2、OpenGL上下文（Context）\"></a>2、OpenGL上下文（Context）</h2><p>在应用程序调用任何OpenGL的指令之前，需要安排首先创建一个OpenGL的上下文。这个上下文是一个非常庞大的状态机，保存了OpenGL中的各种状态，这也是OpenGL指令执行的基础。</p>\n<p>OpenGL的函数不管在哪个语言中，都是类似C语言一样的面向过程的函数，本质上都是对OpenGL上下文这个庞大的状态机中的某个状态或者对象进行操作，当然你得首先把这个对象设置为当前对象。因此，通过对OpenGL指令的封装，是可以将OpenGL的相关调用封装成为一个面向对象的图形API的。</p>\n<p>由于OpenGL上下文是一个巨大的状态机，切换上下文往往会产生较大的开销，但是不同的绘制模块，可能需要使用完全独立的状态管理。因此，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源。这样的方案，会比反复切换上下文，或者大量修改渲染状态，更加合理高效的。</p>\n<h2 id=\"3、帧缓冲区（FrameBuffer）\"><a href=\"#3、帧缓冲区（FrameBuffer）\" class=\"headerlink\" title=\"3、帧缓冲区（FrameBuffer）\"></a>3、帧缓冲区（FrameBuffer）</h2><p>OpenGL是图形API，因此可以说所有的运算和结果最终都是需要通过图像进行输出的。那么绘图必然就需要有一块画板，而帧缓冲区就是OpenGL中的画板。但是特别需要注意的是，帧缓冲区不是常规意义缓冲区（就像鲸鱼不是鱼一样），它并不是实际存储数据的对象，类似画画的时候，需要在画板上放一块画布，才能实际在画布上进行绘画，这些画布可以是纹理（Texture）或者是渲染缓冲区（RenderBuffer），而放置这些画布的位置被称为帧缓冲区的附着（Attachment）。</p>\n<h3 id=\"3-1、附着（Attachment）\"><a href=\"#3-1、附着（Attachment）\" class=\"headerlink\" title=\"3.1、附着（Attachment）\"></a>3.1、附着（Attachment）</h3><p>附着可以理解为画板上的夹子，夹住了哪个画布，就往对应画布上输出数据。</p>\n<p>在帧缓冲区中可以附着3种类型的附着，颜色附着（ColorAttachment），深度附着（DepthAttachment），模板附着（StencilAttachment）。这三种附着对应的存储区域也被称为颜色缓冲区（ColorBuffer），深度缓冲区（DepthBuffer），模板缓冲区（StencilBuffer）。</p>\n<p>颜色附着输出绘制图像的颜色数据，也就是平时常见的图像的RGBA数据。如果使用了多渲染目标(Multiple Render Targets)技术，那么颜色附着的数量可能会大于一。</p>\n<p>深度附着输出绘制图像的深度数据，深度数据主要在3D渲染中使用，一般用于判断物体的远近来实现遮挡的效果。</p>\n<p>模板附着输出模板数据，模板数据是渲染中较为高级的用法，一般用于渲染时进行像素级别的剔除和遮挡效果，常见的应用场景比如三维物体的描边。</p>\n<h2 id=\"4、纹理（Texture）和渲染缓冲区（RenderBuffer）\"><a href=\"#4、纹理（Texture）和渲染缓冲区（RenderBuffer）\" class=\"headerlink\" title=\"4、纹理（Texture）和渲染缓冲区（RenderBuffer）\"></a>4、纹理（Texture）和渲染缓冲区（RenderBuffer）</h2><p>前面已经说过，帧缓冲区并不是实际存储数据的地方，实际存储图像数据数据的对象就是纹理和渲染缓冲区。</p>\n<p>他们三者的关系是这样的，纹理或渲染缓冲区作为帧缓冲区的附着。</p>\n<p>那么，纹理和渲染缓冲区又有什么关系和区别呢？</p>\n<p>纹理和渲染缓冲区同样是存储图像的对象。一般来说，渲染缓冲区对应操作系统提供的窗口，而纹理代表列离屏的图像存储区域。因此，渲染缓冲区都是2D的图像类型，而纹理一般有立方体纹理，1D、2D、3D纹理等类型，同时纹理还额外支持了mipmap等其他特性。</p>\n<p>值得注意的是，一般来说渲染缓冲区和纹理不能同时挂载在同一个帧缓冲区上。</p>\n<h2 id=\"5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）\"><a href=\"#5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）\" class=\"headerlink\" title=\"5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）\"></a>5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）</h2><p>准备好了画布之后，就要开始画图了。画图一般是先画好图像的骨架，然后再往骨架里面填充颜色，这对于OpenGL也是一样的。顶点数据就是要画的图像的骨架，和现实中不同的是，OpenGL中的图像都是由图元组成。在OpenGL ES中，有3种类型的图元：点、线、三角形。那这些顶点数据最终是存储在哪里的呢？开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组。而性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区。</p>\n<h2 id=\"6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）\"><a href=\"#6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）\" class=\"headerlink\" title=\"6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）\"></a>6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）</h2><p>其实我觉得索引在OpenGL叫Element确实有点不够贴切，而在DirectX中叫做IndexBuffer更加合适一些。</p>\n<p>索引数据的目的主要是为了实现顶点的复用，在绘制图像时，总是会有一些顶点被多个图元共享，而反复对这个顶点进行运算常常是没有必要的（也有某些特殊场景需要）。因此对通过索引数据，指示OpenGL绘制顶点的顺序，不但能防止顶点的重复运算，也能在不修改顶点数据的情况下，一定程度的重新组合图像。</p>\n<p>和顶点数据一样，索引数据也可以以索引数组的形式存储在内存当中，调用绘制函数时传入；或者提前分配一块显存，将索引数据存储在这块显存当中，这块显存就被称为索引缓冲区。同样的，使用缓冲区的方式，性能一般会比直接使用索引数组的方式更加高效。</p>\n<p>OpenGL ES提供了2种主要的绘制方法：glDrawArrays和glDrawElements。前者对应的就是没有索引数据的情况，后者对应的是有索引数据的情况。</p>\n<h2 id=\"7、着色器程序（Shader）\"><a href=\"#7、着色器程序（Shader）\" class=\"headerlink\" title=\"7、着色器程序（Shader）\"></a>7、着色器程序（Shader）</h2><p>在固定渲染管线时代，这一步并不是必须的。而是由内置的一段包含了光照、坐标变换、裁剪等等诸多功能的固定shader程序来完成。而可自定义shader，可以说是现代图形API最重要的能力了，没有之一。可以说，shader提供对图形运算的精细操作，带来了各式各样的处理能力，极度的丰富了图形API所能实现的效果。</p>\n<p>OpenGL和其他主流的图形API早在好几年前，就全面的将固定渲染管线架构变为了可编程渲染管线。因此，OpenGL在实际调用绘制函数之前，还需要指定一个由shader编译成的着色器程序。</p>\n<p>常见的着色器主要有顶点着色器（VertexShader），片段着色器（FragmentShader）&#x2F;像素着色器（PixelShader），几何着色器（GeometryShader），曲面细分着色器（TessellationShader）。片段着色器和像素着色器只是在OpenGL和DX中的不同叫法而已。可惜的是，直到OpenGL ES 3.0，依然只支持了顶点着色器和片段着色器这两个最基础的着色器。</p>\n<p>OpenGL在处理shader时，和其他编译器一样。通过编译、链接等步骤，生成了着色器程序（glProgram），着色器程序同时包含了顶点着色器和片段着色器的运算逻辑。在OpenGL进行绘制的时候，首先由顶点着色器对传入的顶点数据进行运算。再通过图元装配，将顶点转换为图元。然后进行光栅化，将图元这种矢量图形，转换为栅格化数据。最后，将栅格化数据传入片段着色器中进行运算。片段着色器会对栅格化数据中的每一个像素进行运算，并决定像素的颜色，也可以在这个阶段将某些像素丢弃。</p>\n<p>其中像素的颜色可以是具体的数值或者是由某种算法计算而来的。如果图元有纹理，就必须用纹理来产生图元的二维渲染图象上每个像素的颜色。对于图元在二维屏幕上图象的每个像素来说，都必须从纹理中获得一个颜色值。我们把这一过程称为纹理过滤（texture filtering），纹理过滤根据不同的过滤方式会由一个或多个像素确定最终获得的颜色。表示这个像素位置的数据被称为纹理坐标（TextureCoordinate）而寻找这个纹理中对应像素位置的方法被称为纹理寻址方式或者纹理环绕方式（TextureWrap）。</p>\n<p>最终，没有被丢弃的像素，下一步会进入测试阶段。通过了深度测试和模板测试，会和帧缓冲区上的颜色附着（FrameBuffer上的ColorAttachment）上的颜色进行混合，决定最终留在画布上的颜色是什么。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/2.png\"></p>\n<img src=\"3.png\" style=\"zoom:50%;\" />\n\n<h3 id=\"7-1、顶点着色器（VertexShader）\"><a href=\"#7-1、顶点着色器（VertexShader）\" class=\"headerlink\" title=\"7.1、顶点着色器（VertexShader）\"></a>7.1、顶点着色器（VertexShader）</h3><p>顶点着色器是OpenGL中用于计算顶点属性的程序。顶点着色器是逐顶点运算的程序，也就是说每个顶点数据都会执行一次顶点着色器，当然这是并行的，并且顶点着色器运算过程中无法访问其他顶点的数据。</p>\n<p>顶点着色器的数据输入主要有两种，统一变量（Uniform）、顶点属性（VertexAttribute）。统一变量在所有顶点运算中是一样的，而顶点属性则是从外部输入的顶点数据中获取，一般在每个顶点运算中都是不同的。</p>\n<p>一般来说典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照运算等等。顶点坐标由自身坐标系转换到归一化坐标系的运算，就是在这里发生的。</p>\n<p>同时顶点着色器的输出结果，也会作为片段着色器的输入。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/4.png\"></p>\n<h3 id=\"7-2、片段着色器（FragmentShader）\"><a href=\"#7-2、片段着色器（FragmentShader）\" class=\"headerlink\" title=\"7.2、片段着色器（FragmentShader）\"></a>7.2、片段着色器（FragmentShader）</h3><p>片段着色器是OpenGL中用于计算片段（像素）颜色的程序。片段做社区是逐像素运算的程序，也就是说每个像素都会执行一次片段着色器，当然也是并行的。</p>\n<p>片段着色器的的数据输入主要有三种种，统一变量（Uniform）、顶点着色器输入变量（也被称为可变变量varying）、采样器（Sampler）。统一变量的值，在同个OpenGL着色器程序中的顶点着色器和片段着色器中是一致的。顶点着色器输入变量在每个像素运算中则一般是不同的，它的值由组成图元的顶点的顶点着色器运算输出的值，根据像素位置进行插值的结果而决定。采样器则是用于从设定好的纹理中，获取纹理的像素颜色的。</p>\n<p>在片段着色器中允许丢弃像素，而使得像素不参与后续的运算。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/5.png\"></p>\n<h2 id=\"8、逐片段操作（Per-Fragment-Operation）\"><a href=\"#8、逐片段操作（Per-Fragment-Operation）\" class=\"headerlink\" title=\"8、逐片段操作（Per-Fragment Operation）\"></a>8、逐片段操作（Per-Fragment Operation）</h2><p><img src=\"/2023/04/14/4-1-OpenGL/6.png\"></p>\n<h3 id=\"8-1、测试（Test）\"><a href=\"#8-1、测试（Test）\" class=\"headerlink\" title=\"8.1、测试（Test）\"></a>8.1、测试（Test）</h3><p>在着色器程序完成之后，我们得到了像素数据。这些数据必须要通过测试才能最终绘制到画布，也就是帧缓冲上的颜色附着上。</p>\n<p>测试主要可以分为像素所有者测试（PixelOwnershipTest）、裁剪测试（ScissorTest）、模板测试（StencilTest）和深度测试（DepthTest），执行的顺序也是按照这个顺序进行执行。</p>\n<p>最开始进行的测试是像素所有者测试，主要是剔除不属于当前程序的像素运算。</p>\n<p>之后裁剪测试，主要是剔除窗口区域之外的像素。</p>\n<p>这两个测试都是由OpenGL内部实现的，无需开发者干预，因此不再进行赘述。</p>\n<p>深度测试，主要是通过对像素的运算出来的深度，也就是像素离屏幕的距离进行对比，根据OpenGL设定好的深度测试程序，决定是否最终渲染到画布上。一般默认的程序是将离屏幕较近的像素保留，而将离屏幕较远的像素丢弃。如果像素最终被渲染到画布上，根据设定好的OpenGL深度覆写状态，可能会更新帧缓冲区上深度附着的值，方便进行下一次的比较。</p>\n<p>模板测试和深度测试的执行原理一致，但是执行的顺序是在深度测试之前的，放在后面 主要是比深度测试更加难以理解一些，初学者可以暂时跳过这个部分。模板测试同样也是通过模板测试程序去决定最终的像素是否丢弃，同样也是根据OpenGL的模板覆写状态决定是否更新像素的模板值。模板测试给开发者提供了高性能的裁剪方案，三维物体的描边技术，就是模板测试典型的用处之一。</p>\n<h3 id=\"8-2、混合（Blending）\"><a href=\"#8-2、混合（Blending）\" class=\"headerlink\" title=\"8.2、混合（Blending）\"></a>8.2、混合（Blending）</h3><p>在测试阶段之后，如果像素依然没有被剔除，那么像素的颜色将会和帧缓冲区中颜色附着上的颜色进行混合，混合的算法可以通过OpenGL的函数进行指定。但是OpenGL提供的混合算法是有限的，如果需要更加复杂的混合算法，一般可以通过像素着色器进行实现，当然性能会比原生的混合算法差一些。</p>\n<h3 id=\"8-3、抖动（Dithering）\"><a href=\"#8-3、抖动（Dithering）\" class=\"headerlink\" title=\"8.3、抖动（Dithering）\"></a>8.3、抖动（Dithering）</h3><p>在混合阶段过后，根据OpenGL的状态设置，会决定是否有抖动这个阶段。</p>\n<p>抖动是一种针对对于可用颜色较少的系统，可以以牺牲分辨率为代价，通过颜色值的抖动来增加可用颜色数量的技术。抖动操作是和硬件相关的，允许程序员所做的操作就只有打开或关闭抖动操作。实际上，若机器的分辨率已经相当高，激活抖动操作根本就没有任何意义。默认情况下，抖动是激活的。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/7.png\"></p>\n<h2 id=\"9、渲染到纹理\"><a href=\"#9、渲染到纹理\" class=\"headerlink\" title=\"9、渲染到纹理\"></a>9、渲染到纹理</h2><p>有些OpenGL程序并不希望渲染出来的图像立即显示在屏幕上，而是需要多次渲染。可能其中一次渲染的结果是下次渲染的输入。因此，如果帧缓冲区的颜色附着设置为一张纹理，那么渲染完成之后，可以重新构造新的帧缓冲区，并将上次渲染出来的纹理作为输入，重新进行前面所述的流程。</p>\n<h2 id=\"10、渲染上屏-x2F-交换缓冲区-SwapBuffer\"><a href=\"#10、渲染上屏-x2F-交换缓冲区-SwapBuffer\" class=\"headerlink\" title=\"10、渲染上屏&#x2F;交换缓冲区(SwapBuffer)\"></a>10、渲染上屏&#x2F;交换缓冲区(SwapBuffer)</h2><p>前面已经提过，渲染缓冲区一般映射的是系统的资源比如窗口。如果将图像直接渲染到窗口对应的渲染缓冲区，则可以将图像显示到屏幕上。</p>\n<p>但是，值得注意的是，如果每个窗口只有一个缓冲区，那么在绘制过程中屏幕进行了刷新，窗口可能显示出不完整的图像。</p>\n<p>为了解决这个问题，常规的OpenGL程序至少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在一个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示。</p>\n<p>由于显示器的刷新一般是逐行进行的，因此为了防止交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进行交换，这个信号就被称为垂直同步信号，这个技术被称为垂直同步。</p>\n<p>使用了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进行下一帧的渲染，使得帧率无法完全达到硬件允许的最高水平。为了解决这个问题，引入了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，而垂直同步发生时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利用硬件性能的目的。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/9.jpg\"></p>\n<h3 id=\"11-顶点数据最终加工成图像的过程\"><a href=\"#11-顶点数据最终加工成图像的过程\" class=\"headerlink\" title=\"11.顶点数据最终加工成图像的过程\"></a>11.顶点数据最终加工成图像的过程</h3><p><strong>着色器（shader）</strong>是在GPU上运行的小程序，GPU有成千上万个处理核心，能进行非常多的并行计算，在些计算的逻辑就写在着色器里，上图中蓝色部分就是表示我们可以通过写shader来进行控制的部分</p>\n<p><strong>顶点着色器</strong>先把3D坐标转换成另一种3D坐标，也就是OpenGL世界里的坐标<br>        <strong>图元着色器</strong>会把顶点着色器传进来的坐标连接成一个图形<br>        <strong>几何着色器</strong>可以进一步构造新的图元或其他形状<br>        <strong>光栅化</strong>就是把图元映射成屏幕上对应的像素<br>        <strong>片段着色器</strong>用来给物体上色<br>        <strong>测试与混合</strong>如果物体对应Alpha值所表示的颜色带有一定的透明，它后面有不完全透明的物体，则要跟后面物体的颜色进行混合，以此达到透明效果，如果被前面物体挡住了，就丢弃被挡住部分的像素</p>\n<p>整个流程就像工厂里的流水线一样，把原料（顶点数据）从一头放入，经过一道道工序的处理，最终变成产品，所以这个渲染流程也叫渲染流水线</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/15.png\"></p>\n<h1 id=\"四、例程\"><a href=\"#四、例程\" class=\"headerlink\" title=\"四、例程\"></a>四、例程</h1><h2 id=\"1-创建窗口\"><a href=\"#1-创建窗口\" class=\"headerlink\" title=\"1.创建窗口\"></a>1.创建窗口</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// System Headers</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;glad/glad.h&gt;</span><span class=\"comment\">//函数加载</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;GLFW/glfw3.h&gt;</span><span class=\"comment\">//窗口管理</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Standard Headers</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">framebuffer_size_callback</span><span class=\"params\">(GLFWwindow *window, <span class=\"type\">int</span> width, <span class=\"type\">int</span> height)</span></span>;<span class=\"comment\">//回调函数原型声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processInput</span><span class=\"params\">(GLFWwindow *window)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// settings</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> SCR_WIDTH = <span class=\"number\">800</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> SCR_HEIGHT = <span class=\"number\">600</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">glfwInit</span>();<span class=\"comment\">//初始化    </span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class=\"number\">3</span>);<span class=\"comment\">//设置主版本号</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class=\"number\">3</span>);<span class=\"comment\">//设置次版本号</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class=\"comment\">//使用核心模式</span></span><br><span class=\"line\">    <span class=\"comment\">//创建一个窗口对象,参数：窗口宽，窗口高，窗口标题，暂时忽略，暂时忽略</span></span><br><span class=\"line\">    GLFWwindow *window = <span class=\"built_in\">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class=\"string\">&quot;GLFW 3.3.1&quot;</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (window == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"built_in\">glfwTerminate</span>();<span class=\"comment\">//释放内存</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//通知GLFW将我们窗口的上下文设置为当前线程的主上下文</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwMakeContextCurrent</span>(window);</span><br><span class=\"line\">    <span class=\"comment\">//对窗口注册一个回调函数,每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class=\"line\">    <span class=\"comment\">//初始化GLAD用来管理OpenGL的函数指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置视口，OpenGL幕后的坐标转窗口坐标将以此为参考</span></span><br><span class=\"line\">    <span class=\"comment\">//OpenGL的坐标最大最小值为1和-1</span></span><br><span class=\"line\">    <span class=\"comment\">//如下x轴-1~1对应窗口坐标0~800,y轴-1～1对应窗口坐标0~600</span></span><br><span class=\"line\">    <span class=\"comment\">//如OpenGL坐标（0，0）对应窗口坐标（400,300），（-0.5,0.5）对应（200,450）</span></span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">800</span>,<span class=\"number\">600</span>);</span><br><span class=\"line\">    <span class=\"comment\">//渲染循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//监视键盘 输入</span></span><br><span class=\"line\">        <span class=\"built_in\">processInput</span>(window);</span><br><span class=\"line\">        <span class=\"comment\">// 渲染指令</span></span><br><span class=\"line\">        <span class=\"built_in\">glClearColor</span>(<span class=\"number\">0.2f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">1.0f</span>);<span class=\"comment\">//清除颜色缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_COLOR_BUFFER_BIT 颜色缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_DEPTH_BUFFER_BIT 深度缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_STENCIL+BUFFER_BIT 模板缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">        <span class=\"comment\">//交换颜色缓冲，OpenGL绘图的时候，前缓冲用于显示，后缓冲就在渲染</span></span><br><span class=\"line\">        <span class=\"comment\">//当后缓冲渲染完毕，前缓冲和后缓冲互换，后缓冲变前缓冲，前缓冲变后缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">// 检查并调用事件，交换缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glfwSwapBuffers</span>(window);<span class=\"comment\">//检查触发事件</span></span><br><span class=\"line\">        <span class=\"comment\">//消息分发函数 检测有没有触发窗口消息，然后调用对应回调函数</span></span><br><span class=\"line\">        <span class=\"built_in\">glfwPollEvents</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//释放/删除之前的分配的所有资源,释放内存</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwTerminate</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输入控制，检查用户是否按下了返回键(Esc)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processInput</span><span class=\"params\">(GLFWwindow *window)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">glfwSetWindowShouldClose</span>(window, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当用户改变窗口的大小的时候，视口也应该被调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">framebuffer_size_callback</span><span class=\"params\">(GLFWwindow *window, <span class=\"type\">int</span> width, <span class=\"type\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：对于视网膜(Retina)显示屏，width和height都会明显比原输入值更高一点。</span></span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-能控制移动的彩色矩形\"><a href=\"#2-能控制移动的彩色矩形\" class=\"headerlink\" title=\"2.能控制移动的彩色矩形\"></a>2.能控制移动的彩色矩形</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;glad/glad.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//顶点着色器</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *vertexShaderSource = </span><br><span class=\"line\"><span class=\"string\">&quot;#version 330 core\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;layout (location = 0) in vec3 aPos;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;layout (location = 1) in vec3 aColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;out vec3 ourColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;uniform vec2 pos;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;void main()&#123;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;    gl_Position = vec4(aPos.x+pos.x,aPos.y+pos.y,aPos.z,1.0);\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;    ourColor=aColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\n&#125;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//片段着色器</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *fragmentShaderSource =</span><br><span class=\"line\"><span class=\"string\">&quot;#version 330 core\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;out vec4 FragColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;in vec3 ourColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;void main()&#123;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;    FragColor = vec4(ourColor,0.8f);&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#125;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//顶点和颜色数据</span></span><br><span class=\"line\"><span class=\"type\">float</span> vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 位置              // 颜色</span></span><br><span class=\"line\">     <span class=\"number\">0.5f</span>, <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,   <span class=\"comment\">// 右下</span></span><br><span class=\"line\">    <span class=\"number\">-0.5f</span>, <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>,   <span class=\"comment\">// 左下</span></span><br><span class=\"line\">     <span class=\"number\">-0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>,    <span class=\"comment\">// 顶部</span></span><br><span class=\"line\">     <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.5f</span>, <span class=\"number\">0.5f</span>    <span class=\"comment\">// 顶部</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//索引</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> indices[] = &#123; <span class=\"comment\">// 注意索引从0开始! </span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"comment\">// 第一个三角形</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>  <span class=\"comment\">// 第二个三角形</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//矩形平面坐标</span></span><br><span class=\"line\"><span class=\"type\">float</span> x=<span class=\"number\">0</span>,y=<span class=\"number\">0</span>,speed=<span class=\"number\">0.02f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译着色器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CompileShader</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* source,<span class=\"type\">int</span> type)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> shader=<span class=\"built_in\">glCreateShader</span>(type);</span><br><span class=\"line\">    <span class=\"built_in\">glShaderSource</span>(shader,<span class=\"number\">1</span>,&amp;source,<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"built_in\">glCompileShader</span>(shader);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> log[<span class=\"number\">512</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">glGetShaderiv</span>(shader,GL_COMPILE_STATUS,&amp;ret);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!ret)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">glGetShaderInfoLog</span>(shader,<span class=\"number\">512</span>,<span class=\"literal\">nullptr</span>,log);</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;着色器编译失败：&quot;</span>&lt;&lt;log&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shader;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//窗口大小变动的回调函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">framebuffer_size_callback</span><span class=\"params\">(GLFWwindow* window,<span class=\"type\">int</span> width,<span class=\"type\">int</span> height)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,width,height);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果ESC键按下，则关闭窗口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processInput</span><span class=\"params\">(GLFWwindow *window)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">glfwSetWindowShouldClose</span>(window, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window,GLFW_KEY_D) == GLFW_PRESS)&#123;</span><br><span class=\"line\">        x&gt;=<span class=\"number\">0.5f</span> ? x=<span class=\"number\">0.5f</span> : x+=speed;   </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window,GLFW_KEY_A) == GLFW_PRESS)&#123; </span><br><span class=\"line\">        x&lt;=<span class=\"number\">-0.5f</span> ? x=<span class=\"number\">-0.5f</span> : x-=speed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window,GLFW_KEY_W) == GLFW_PRESS)&#123;</span><br><span class=\"line\">        y&gt;=<span class=\"number\">0.5f</span> ? y=<span class=\"number\">0.5f</span> : y+=speed;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window,GLFW_KEY_S) == GLFW_PRESS)&#123;</span><br><span class=\"line\">        y&lt;=<span class=\"number\">-0.5f</span> ? y = <span class=\"number\">-0.5f</span> : y-=speed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">glfwInit</span>();<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR,<span class=\"number\">3</span>); <span class=\"comment\">//主版本号</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR,<span class=\"number\">3</span>);<span class=\"comment\">//次版本号</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);<span class=\"comment\">//采用核心模式</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//参数：窗口宽，窗口高，窗口标题，暂时忽略，暂时忽略</span></span><br><span class=\"line\">    GLFWwindow* window = <span class=\"built_in\">glfwCreateWindow</span>(<span class=\"number\">800</span>,<span class=\"number\">600</span>,<span class=\"string\">&quot;这是窗口标题&quot;</span>,<span class=\"literal\">nullptr</span>,<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!window)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;创建窗口失败！&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"built_in\">glfwTerminate</span>();<span class=\"comment\">//释放内存</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">glfwMakeContextCurrent</span>(window);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化GLAD，GLAD用于管理函数指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"built_in\">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;初始化GLAD失败&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置视口，OpenGL幕后的坐标转窗口坐标将以此为参考</span></span><br><span class=\"line\">    <span class=\"comment\">//OpenGL的坐标最大最小值为1和-1</span></span><br><span class=\"line\">    <span class=\"comment\">//如下x轴-1~1对应窗口坐标0~800,y轴-1～1对应窗口坐标0~600</span></span><br><span class=\"line\">    <span class=\"comment\">//如OpenGL坐标（0，0）对应窗口坐标（400,300），（-0.5,0.5）对应（200,450）</span></span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">800</span>,<span class=\"number\">600</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//编译着色器</span></span><br><span class=\"line\">    <span class=\"type\">int</span> vertexShader=<span class=\"built_in\">CompileShader</span>(vertexShaderSource, GL_VERTEX_SHADER);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!vertexShader) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> fragmentShader=<span class=\"built_in\">CompileShader</span>(fragmentShaderSource, GL_FRAGMENT_SHADER);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!fragmentShader) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//链接着色器程序</span></span><br><span class=\"line\">    <span class=\"type\">int</span> shaderProgram=<span class=\"built_in\">glCreateProgram</span>();</span><br><span class=\"line\">    <span class=\"built_in\">glAttachShader</span>(shaderProgram,vertexShader);</span><br><span class=\"line\">    <span class=\"built_in\">glAttachShader</span>(shaderProgram,fragmentShader);</span><br><span class=\"line\">    <span class=\"built_in\">glLinkProgram</span>(shaderProgram);</span><br><span class=\"line\">    <span class=\"built_in\">glDeleteShader</span>(vertexShader);</span><br><span class=\"line\">    <span class=\"built_in\">glDeleteShader</span>(fragmentShader);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建VAO</span></span><br><span class=\"line\">    GLuint VAO=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">glGenVertexArrays</span>(<span class=\"number\">1</span>,&amp;VAO);</span><br><span class=\"line\">    <span class=\"built_in\">glBindVertexArray</span>(VAO);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建VBO</span></span><br><span class=\"line\">    GLuint VBO=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">glGenBuffers</span>(<span class=\"number\">1</span>,&amp;VBO);</span><br><span class=\"line\">    <span class=\"built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);</span><br><span class=\"line\">    <span class=\"built_in\">glBufferData</span>(GL_ARRAY_BUFFER,<span class=\"built_in\">sizeof</span>(vertices),vertices,GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建EBO</span></span><br><span class=\"line\">    GLuint EBO=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">glGenBuffers</span>(<span class=\"number\">1</span>,&amp;EBO);</span><br><span class=\"line\">    <span class=\"built_in\">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER,EBO);</span><br><span class=\"line\">    <span class=\"built_in\">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER,<span class=\"built_in\">sizeof</span>(indices),indices,GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//顶点数据 从偏移0 * 6*sizeof(float)处开始拿3个float</span></span><br><span class=\"line\">    <span class=\"comment\">//之后再从偏移1 * 6*sizeof(float)处开始拿3个float 直到拿完</span></span><br><span class=\"line\">    <span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">0</span>,<span class=\"number\">3</span>,GL_FLOAT,GL_FALSE,<span class=\"number\">6</span>*<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>),(<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">//颜色数据同上 不过偏移是从3*sizeof(float)开始，不是从0</span></span><br><span class=\"line\">    <span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,GL_FLOAT,GL_FALSE,<span class=\"number\">6</span>*<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>),(<span class=\"type\">void</span>*)(<span class=\"number\">3</span>*<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>)));</span><br><span class=\"line\">    <span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> index=<span class=\"built_in\">glGetUniformLocation</span>(shaderProgram,<span class=\"string\">&quot;pos&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//注册窗口大小变化回调函数</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//窗口循环 如果窗口被关闭，则退出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">glfwWindowShouldClose</span>(window))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//监视键盘输入</span></span><br><span class=\"line\">        <span class=\"built_in\">processInput</span>(window);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//清除颜色缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glClearColor</span>(<span class=\"number\">0.2f</span>,<span class=\"number\">0.3f</span>,<span class=\"number\">0.3f</span>,<span class=\"number\">0.8f</span>);</span><br><span class=\"line\">        <span class=\"comment\">//GL_COLOR_BUFFER_BIT 颜色缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_DEPTH_BUFFER_BIT 深度缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_STENCIL+BUFFER_BIT 模板缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">glUseProgram</span>(shaderProgram);</span><br><span class=\"line\">        <span class=\"built_in\">glBindVertexArray</span>(VAO);</span><br><span class=\"line\">        <span class=\"built_in\">glUniform2f</span>(index,x,y);</span><br><span class=\"line\">        <span class=\"built_in\">glDrawElements</span>(GL_TRIANGLES,<span class=\"number\">6</span>,GL_UNSIGNED_INT,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//交换颜色缓冲，OpenGL绘图的时候，前缓冲用于显示，后缓冲就在渲染</span></span><br><span class=\"line\">        <span class=\"comment\">//当后缓冲渲染完毕，前缓冲和后缓冲互换，后缓冲变前缓冲，前缓冲变后缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glfwSwapBuffers</span>(window);</span><br><span class=\"line\">        <span class=\"comment\">//消息分发函数 检测有没有触发窗口消息，然后调用对应回调函数</span></span><br><span class=\"line\">        <span class=\"built_in\">glfwPollEvents</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">glDeleteVertexArrays</span>(<span class=\"number\">1</span>,&amp;VAO);</span><br><span class=\"line\">    <span class=\"built_in\">glDeleteBuffers</span>(<span class=\"number\">1</span>,&amp;VBO);</span><br><span class=\"line\">    <span class=\"built_in\">glDeleteBuffers</span>(<span class=\"number\">1</span>,&amp;EBO);</span><br><span class=\"line\">    <span class=\"built_in\">glfwTerminate</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"style":""}},"length":20459,"excerpt":"<h1 id=\"一、什么是OpenGL\"><a href=\"#一、什么是OpenGL\" class=\"headerlink\" title=\"一、什么是OpenGL?\"></a>一、什么是OpenGL?</h1><h2 id=\"1-OpenGL简介\"><a href=\"#1-OpenGL简介\" class=\"headerlink\" title=\"1.OpenGL简介\"></a>1.OpenGL简介</h2><p>OpenGL是渲染2D、3D矢量图形硬件的一种软件接口。本质上说，它是一个3D图形和模型库，具有高度的可移植性，并且具有非常快的渲染速度。OpenGL并不是一种语言，而是更像一个C运行时函数库。它提供了一些预包装的功能，帮助开发人员编写功能强大的三维应用程序。 OpenGL可以再多种操作系统平台上运行，例如各种版本的Windows、UNIX&#x2F;Linux、Mac OS 和 OS&#x2F;2等。如今，OpenGL广泛流行于游戏、医学影像、地理信息、气象模拟等领域，是高性能图像和交互性场景处理的工业标准。</p>","more":"<p>OpenGL的高效实现（利用了图形加速硬件）存在于Windows，部分UNIX平台和Mac OS。这些实现一般由显示设备厂商提供，而且非常依赖于该厂商提供的硬件。</p>\n<p>一般它被认为是一个API(Application Programming Interface, 应用程序编程接口)，包含了一系列可以操作图形、图像的函数。然而，OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范(Specification)。</p>\n<p>OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定（译注：这里开发者是指编写OpenGL库的人）。因为OpenGL规范并没有规定实现的细节，具体的OpenGL库允许使用不同的实现，只要其功能和结果与规范相匹配（亦即，作为用户不会感受到功能上的差异）。</p>\n<p>实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的。当你使用Apple系统的时候，OpenGL库是由Apple自身维护的。在Linux下，有显卡生产商提供的OpenGL库，也有一些爱好者改编的版本。这也意味着任何时候OpenGL库表现的行为与规范规定的不一致时，基本都是库的开发者留下的bug。</p>\n<p>由于OpenGL的大多数实现都是由显卡厂商编写的，当产生一个bug时通常可以通过升级显卡驱动来解决。这些驱动会包括你的显卡能支持的最新版本的OpenGL，这也是为什么总是建议你偶尔更新一下显卡驱动。</p>\n<p>所有版本的OpenGL规范文档都被公开的寄存在Khronos那里。有兴趣的读者可以找到OpenGL3.3（我们将要使用的版本）的规范文档。如果你想深入到OpenGL的细节（只关心函数功能的描述而不是函数的实现），这是个很好的选择。如果你想知道每个函数具体的运作方式，这个规范也是一个很棒的参考。</p>\n<h2 id=\"2-核心模式和立即渲染模式\"><a href=\"#2-核心模式和立即渲染模式\" class=\"headerlink\" title=\"2.核心模式和立即渲染模式\"></a>2.核心模式和立即渲染模式</h2><p>早期的OpenGL使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少能控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。</p>\n<p>当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从OpenGL实际运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。</p>\n<p>这也是为什么我们的教程面向OpenGL3.3的核心模式。虽然上手更困难，但这份努力是值得的。</p>\n<p>现今，更高版本的OpenGL已经发布（写作时最新版本为4.5），你可能会问：既然OpenGL 4.5 都出来了，为什么我们还要学习OpenGL 3.3？答案很简单，所有OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。新版本只是引入了一些更有效率或更有用的方式去完成同样的功能。因此，所有的概念和技术在现代OpenGL版本里都保持一致。当你的经验足够，你可以轻松使用来自更高版本OpenGL的新特性。</p>\n<p>当使用新版本的OpenGL特性时，只有新一代的显卡能够支持你的应用程序。这也是为什么大多数开发者基于较低版本的OpenGL编写程序，并只提供选项启用新版本的特性。</p>\n<p>在有些教程里你会看见更现代的特性，它们同样会以这种红色注释方式标明。</p>\n<h2 id=\"3-扩展\"><a href=\"#3-扩展\" class=\"headerlink\" title=\"3.扩展\"></a>3.扩展</h2><p>OpenGL的一大特性就是对扩展(Extension)的支持，当一个显卡公司提出一个新特性或者渲染上的大优化，通常会以扩展的方式在驱动中实现。如果一个程序在支持这个扩展的显卡上运行，开发者可以使用这个扩展提供的一些更先进更有效的图形功能。通过这种方式，开发者不必等待一个新的OpenGL规范面世，就可以使用这些新的渲染特性了，只需要简单地检查一下显卡是否支持此扩展。通常，当一个扩展非常流行或者非常有用的时候，它将最终成为未来的OpenGL规范的一部分。</p>\n<p>使用扩展的代码大多看上去如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(GL_ARB_extension_name)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用硬件支持的全新的现代特性</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不支持此扩展: 用旧的方式去做</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 使用OpenGL3.3时，我们很少需要使用扩展来完成大多数功能，当需要的时候，本教程将提供适当的指示。 </p>\n<h2 id=\"4-状态机\"><a href=\"#4-状态机\" class=\"headerlink\" title=\"4.状态机\"></a>4.状态机</h2><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。</p>\n<p>假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。</p>\n<p>当使用OpenGL的时候，我们会遇到一些状态设置函数(State-changing Function)，这类函数将会改变上下文。以及状态使用函数(State-using Function)，这类函数会根据当前OpenGL的状态执行一些操作。只要你记住OpenGL本质上是个大状态机，就能更容易理解它的大部分特性。</p>\n<h2 id=\"5-对象\"><a href=\"#5-对象\" class=\"headerlink\" title=\"5.对象\"></a>5.对象</h2><p>OpenGL库是用C语言写的，同时也支持多种语言的派生，但其内核仍是一个C库。由于C的一些语言结构不易被翻译到其它的高级语言，因此OpenGL开发的时候引入了一些抽象层。“对象(Object)”就是其中一个。</p>\n<p>在OpenGL中一个对象是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体(Struct)：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">object_name</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">float</span>  option1;</span><br><span class=\"line\">    <span class=\"type\">int</span>    option2;</span><br><span class=\"line\">    <span class=\"type\">char</span>[] name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在有些教程中一直使用的都是OpenGL的基本类型，但由于作者觉得在本教程系列中并没有一个必须使用它们的原因，所有的类型都改为了自带类型。但是请仍然记住，使用OpenGL的类型的好处是保证了在各平台中每一种类型的大小都是统一的。你也可以使用其它的定宽类型(Fixed-width Type)来实现这一点。</p>\n<p>当我们使用一个对象时，通常看起来像如下一样（把OpenGL上下文看作一个大的结构体）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// OpenGL的状态</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OpenGL_Context</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    object* object_Window_Target;</span><br><span class=\"line\">    ...     </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建对象</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> objectId = <span class=\"number\">0</span>;</span><br><span class=\"line\">glGenObject(<span class=\"number\">1</span>, &amp;objectId);</span><br><span class=\"line\"><span class=\"comment\">// 绑定对象至上下文</span></span><br><span class=\"line\">glBindObject(GL_WINDOW_TARGET, objectId);</span><br><span class=\"line\"><span class=\"comment\">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span></span><br><span class=\"line\">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class=\"number\">800</span>);</span><br><span class=\"line\">glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class=\"number\">600</span>);</span><br><span class=\"line\"><span class=\"comment\">// 将上下文对象设回默认</span></span><br><span class=\"line\">glBindObject(GL_WINDOW_TARGET, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这一小段代码展现了你以后使用OpenGL时常见的工作流。我们首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后我们将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）。接下来我们设置窗口的选项。最后我们将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。</p>\n<p>目前提供的示例代码只是OpenGL如何操作的一个大致描述，通过阅读以后的教程你会遇到很多实际的例子。</p>\n<p>使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。拥有数个这样的对象允许我们指定多个模型，在想画其中任何一个的时候，直接将对应的对象绑定上去，便不需要再重复设置选项了。</p>\n<h1 id=\"二、开发环境配置\"><a href=\"#二、开发环境配置\" class=\"headerlink\" title=\"二、开发环境配置\"></a>二、开发环境配置</h1><h2 id=\"1-Ubuntu开发环境配置\"><a href=\"#1-Ubuntu开发环境配置\" class=\"headerlink\" title=\"1.Ubuntu开发环境配置\"></a>1.Ubuntu开发环境配置</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用 apt 安装 OpenGL 和开发包</span></span><br><span class=\"line\">sudo apt-get install build-essential libgl1-mesa-dev</span><br><span class=\"line\">sudo apt-get install freeglut3-dev</span><br><span class=\"line\">sudo apt-get install libglew-dev libsdl2-dev libsdl2-image-dev libglm-dev libfreetype6-dev</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-测试程序\"><a href=\"#2-测试程序\" class=\"headerlink\" title=\"2.测试程序\"></a>2.测试程序</h2><p> 用vim写一段测试程序，测试下开发环境是否安装成功。 </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.c</span></span><br><span class=\"line\"><span class=\"comment\">/* light.c</span></span><br><span class=\"line\"><span class=\"comment\">此程序利用GLUT绘制一个OpenGL窗口，并显示一个加以光照的球。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">/* 由于头文件glut.h中已经包含了头文件gl.h和glu.h，所以只需要include 此文件*/</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;GL/glut.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">/* 初始化材料属性、光源属性、光照模型，打开深度缓冲区 */</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">init</span> <span class=\"params\">( <span class=\"type\">void</span> )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    GLfloat mat_specular [ ] = &#123; <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span> &#125;;</span><br><span class=\"line\">    GLfloat mat_shininess [ ] = &#123; <span class=\"number\">50.0</span> &#125;;</span><br><span class=\"line\">    GLfloat light_position [ ] = &#123; <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span> &#125;;</span><br><span class=\"line\">    glClearColor ( <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span> );</span><br><span class=\"line\">    glShadeModel ( GL_SMOOTH );</span><br><span class=\"line\">    glMaterialfv ( GL_FRONT, GL_SPECULAR, mat_specular);</span><br><span class=\"line\">    glMaterialfv ( GL_FRONT, GL_SHININESS, mat_shininess);</span><br><span class=\"line\">    glLightfv ( GL_LIGHT0, GL_POSITION, light_position);</span><br><span class=\"line\">    glEnable (GL_LIGHTING);</span><br><span class=\"line\">    glEnable (GL_LIGHT0);</span><br><span class=\"line\">    glEnable (GL_DEPTH_TEST);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*调用GLUT函数，绘制一个球*/</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">display</span> <span class=\"params\">( <span class=\"type\">void</span> )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<span class=\"comment\">// 1. 调用glClear()清空窗口</span></span><br><span class=\"line\">    glutSolidSphere (<span class=\"number\">1.0</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>);<span class=\"comment\">/*调用GLUT函数，绘制一个球*/</span></span><br><span class=\"line\">    glFlush ();<span class=\"comment\">// 3. 请求将图像绘制到窗口</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"comment\">// main()函数用于创建窗口,调用init()函数,最后进入到事件循环(event loop).这里仍会看到一些以gl开头的函数,但和上面的有所不同.这些函数来自第三方库,以便我们可以在不同的系统中更方便地使用OpenGL.这里我们使用的是GLUT  </span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span>** argv)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* GLUT环境初始化*/</span></span><br><span class=\"line\">    glutInit (&amp;argc, argv);</span><br><span class=\"line\">    <span class=\"comment\">/* 显示模式初始化 */</span></span><br><span class=\"line\">    glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);</span><br><span class=\"line\">    <span class=\"comment\">/* 定义窗口大小 */</span></span><br><span class=\"line\">    glutInitWindowSize (<span class=\"number\">300</span>, <span class=\"number\">300</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 定义窗口位置 */</span></span><br><span class=\"line\">    glutInitWindowPosition (<span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* 显示窗口，窗口标题为执行函数名 */</span></span><br><span class=\"line\">    glutCreateWindow ( argv [ <span class=\"number\">0</span> ] );</span><br><span class=\"line\">    <span class=\"comment\">/* 调用OpenGL初始化函数 */</span></span><br><span class=\"line\">    init ( );</span><br><span class=\"line\">    <span class=\"comment\">/* 注册OpenGL绘图函数 */</span></span><br><span class=\"line\">    glutDisplayFunc ( display );</span><br><span class=\"line\">    <span class=\"comment\">// /* 进入GLUT消息循环，开始执行程序 */</span></span><br><span class=\"line\">    glutMainLoop( );<span class=\"comment\">//用于进入事件处理循环，仅退出窗口时，函数返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-编译运行\"><a href=\"#3-编译运行\" class=\"headerlink\" title=\"3.编译运行\"></a>3.编译运行</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc test.c -o test -lGL -lglut</span><br><span class=\"line\">./test</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-效果图\"><a href=\"#4-效果图\" class=\"headerlink\" title=\"4.效果图\"></a>4.效果图</h2><img src=\"1.png\" style=\"zoom: 25%;\" />\n\n<h2 id=\"5-附录：\"><a href=\"#5-附录：\" class=\"headerlink\" title=\"5.附录：\"></a>5.附录：</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireSphere</span><span class=\"params\">(GLdouble radius, GLint slices, GLint stacks)</span></span>; 线框球</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidSphere</span><span class=\"params\">(GLdouble radius, GLint slices, GLint stacks)</span></span>; 实心球</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireCube</span><span class=\"params\">(GLdouble size)</span></span>; 线框立方体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidCube</span><span class=\"params\">(GLdouble size)</span></span>; 实心立方体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireTorus</span><span class=\"params\">(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings)</span></span>; 线框圆环</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidTorus</span><span class=\"params\">(GLdouble innerRadius, GLdouble outerRadius, GLint nsides, GLint rings)</span></span>; 实心圆环</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireIcosahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 线框<span class=\"number\">20</span>面体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidIcosahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 实心<span class=\"number\">20</span>面体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireOctahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 线框<span class=\"number\">8</span>面体 </span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidOctahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 实心<span class=\"number\">8</span>面体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireTetrahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 线框<span class=\"number\">4</span>面体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidTetrahedron</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span>; 实心<span class=\"number\">4</span>面体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireDodecahedron</span><span class=\"params\">(GLdouble radius)</span></span>; 线框<span class=\"number\">12</span>面体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidDodecahedron</span><span class=\"params\">(GLdouble radius)</span></span>; 实心<span class=\"number\">12</span>面体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireCone</span><span class=\"params\">(GLdouble radius, GLdouble height, GLint slices, GLint stacks)</span></span>; 线框圆锥体</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidCone</span><span class=\"params\">(GLdouble radius, GLdouble height, GLint slices, GLint stacks)</span></span>; 实心圆锥体</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutWireTeapot</span><span class=\"params\">(GLdouble size)</span></span>; 线框茶壶</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">glutSolidTeapot</span><span class=\"params\">(GLdouble size)</span></span>; 实心茶壶</span><br><span class=\"line\"></span><br><span class=\"line\">函数中，radius表示球体的半径，slices表示球体围绕z轴分割的数目，stacks表示球体沿着z轴分割的数目。</span><br><span class=\"line\"></span><br><span class=\"line\">绘制中心在模型坐标原点,半径为radius的球体,球体围绕z轴分割slices次,球体沿着z轴分割stacks次</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"三、OpenGL流程详细介绍\"><a href=\"#三、OpenGL流程详细介绍\" class=\"headerlink\" title=\"三、OpenGL流程详细介绍\"></a>三、OpenGL流程详细介绍</h1><h2 id=\"1、简介\"><a href=\"#1、简介\" class=\"headerlink\" title=\"1、简介\"></a>1、简介</h2><p>OpenGL（Open Graphics Library）是一个跨编程语言、跨平台的编程图形程序接口，它将计算机的资源抽象称为一个个OpenGL的对象，对这些资源的操作抽象为一个个的OpenGL指令。</p>\n<p>OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，去除了许多不必要和性能较低的API接口。</p>\n<p>本文介绍的OpenGL版本是基于OpenGL ES 3.0的。这也是目前覆盖率最高的OpenGL版本，被广泛运用在各种终端设备上。</p>\n<h2 id=\"2、OpenGL上下文（Context）\"><a href=\"#2、OpenGL上下文（Context）\" class=\"headerlink\" title=\"2、OpenGL上下文（Context）\"></a>2、OpenGL上下文（Context）</h2><p>在应用程序调用任何OpenGL的指令之前，需要安排首先创建一个OpenGL的上下文。这个上下文是一个非常庞大的状态机，保存了OpenGL中的各种状态，这也是OpenGL指令执行的基础。</p>\n<p>OpenGL的函数不管在哪个语言中，都是类似C语言一样的面向过程的函数，本质上都是对OpenGL上下文这个庞大的状态机中的某个状态或者对象进行操作，当然你得首先把这个对象设置为当前对象。因此，通过对OpenGL指令的封装，是可以将OpenGL的相关调用封装成为一个面向对象的图形API的。</p>\n<p>由于OpenGL上下文是一个巨大的状态机，切换上下文往往会产生较大的开销，但是不同的绘制模块，可能需要使用完全独立的状态管理。因此，可以在应用程序中分别创建多个不同的上下文，在不同线程中使用不同的上下文，上下文之间共享纹理、缓冲区等资源。这样的方案，会比反复切换上下文，或者大量修改渲染状态，更加合理高效的。</p>\n<h2 id=\"3、帧缓冲区（FrameBuffer）\"><a href=\"#3、帧缓冲区（FrameBuffer）\" class=\"headerlink\" title=\"3、帧缓冲区（FrameBuffer）\"></a>3、帧缓冲区（FrameBuffer）</h2><p>OpenGL是图形API，因此可以说所有的运算和结果最终都是需要通过图像进行输出的。那么绘图必然就需要有一块画板，而帧缓冲区就是OpenGL中的画板。但是特别需要注意的是，帧缓冲区不是常规意义缓冲区（就像鲸鱼不是鱼一样），它并不是实际存储数据的对象，类似画画的时候，需要在画板上放一块画布，才能实际在画布上进行绘画，这些画布可以是纹理（Texture）或者是渲染缓冲区（RenderBuffer），而放置这些画布的位置被称为帧缓冲区的附着（Attachment）。</p>\n<h3 id=\"3-1、附着（Attachment）\"><a href=\"#3-1、附着（Attachment）\" class=\"headerlink\" title=\"3.1、附着（Attachment）\"></a>3.1、附着（Attachment）</h3><p>附着可以理解为画板上的夹子，夹住了哪个画布，就往对应画布上输出数据。</p>\n<p>在帧缓冲区中可以附着3种类型的附着，颜色附着（ColorAttachment），深度附着（DepthAttachment），模板附着（StencilAttachment）。这三种附着对应的存储区域也被称为颜色缓冲区（ColorBuffer），深度缓冲区（DepthBuffer），模板缓冲区（StencilBuffer）。</p>\n<p>颜色附着输出绘制图像的颜色数据，也就是平时常见的图像的RGBA数据。如果使用了多渲染目标(Multiple Render Targets)技术，那么颜色附着的数量可能会大于一。</p>\n<p>深度附着输出绘制图像的深度数据，深度数据主要在3D渲染中使用，一般用于判断物体的远近来实现遮挡的效果。</p>\n<p>模板附着输出模板数据，模板数据是渲染中较为高级的用法，一般用于渲染时进行像素级别的剔除和遮挡效果，常见的应用场景比如三维物体的描边。</p>\n<h2 id=\"4、纹理（Texture）和渲染缓冲区（RenderBuffer）\"><a href=\"#4、纹理（Texture）和渲染缓冲区（RenderBuffer）\" class=\"headerlink\" title=\"4、纹理（Texture）和渲染缓冲区（RenderBuffer）\"></a>4、纹理（Texture）和渲染缓冲区（RenderBuffer）</h2><p>前面已经说过，帧缓冲区并不是实际存储数据的地方，实际存储图像数据数据的对象就是纹理和渲染缓冲区。</p>\n<p>他们三者的关系是这样的，纹理或渲染缓冲区作为帧缓冲区的附着。</p>\n<p>那么，纹理和渲染缓冲区又有什么关系和区别呢？</p>\n<p>纹理和渲染缓冲区同样是存储图像的对象。一般来说，渲染缓冲区对应操作系统提供的窗口，而纹理代表列离屏的图像存储区域。因此，渲染缓冲区都是2D的图像类型，而纹理一般有立方体纹理，1D、2D、3D纹理等类型，同时纹理还额外支持了mipmap等其他特性。</p>\n<p>值得注意的是，一般来说渲染缓冲区和纹理不能同时挂载在同一个帧缓冲区上。</p>\n<h2 id=\"5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）\"><a href=\"#5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）\" class=\"headerlink\" title=\"5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）\"></a>5、顶点数组（VertexArray）和顶点缓冲区（VertexBuffer）</h2><p>准备好了画布之后，就要开始画图了。画图一般是先画好图像的骨架，然后再往骨架里面填充颜色，这对于OpenGL也是一样的。顶点数据就是要画的图像的骨架，和现实中不同的是，OpenGL中的图像都是由图元组成。在OpenGL ES中，有3种类型的图元：点、线、三角形。那这些顶点数据最终是存储在哪里的呢？开发者可以选择设定函数指针，在调用绘制方法的时候，直接由内存传入顶点数据，也就是说这部分数据之前是存储在内存当中的，被称为顶点数组。而性能更高的做法是，提前分配一块显存，将顶点数据预先传入到显存当中。这部分的显存，就被称为顶点缓冲区。</p>\n<h2 id=\"6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）\"><a href=\"#6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）\" class=\"headerlink\" title=\"6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）\"></a>6、索引数组（ElementArray）和索引缓冲区（ElementBuffer）</h2><p>其实我觉得索引在OpenGL叫Element确实有点不够贴切，而在DirectX中叫做IndexBuffer更加合适一些。</p>\n<p>索引数据的目的主要是为了实现顶点的复用，在绘制图像时，总是会有一些顶点被多个图元共享，而反复对这个顶点进行运算常常是没有必要的（也有某些特殊场景需要）。因此对通过索引数据，指示OpenGL绘制顶点的顺序，不但能防止顶点的重复运算，也能在不修改顶点数据的情况下，一定程度的重新组合图像。</p>\n<p>和顶点数据一样，索引数据也可以以索引数组的形式存储在内存当中，调用绘制函数时传入；或者提前分配一块显存，将索引数据存储在这块显存当中，这块显存就被称为索引缓冲区。同样的，使用缓冲区的方式，性能一般会比直接使用索引数组的方式更加高效。</p>\n<p>OpenGL ES提供了2种主要的绘制方法：glDrawArrays和glDrawElements。前者对应的就是没有索引数据的情况，后者对应的是有索引数据的情况。</p>\n<h2 id=\"7、着色器程序（Shader）\"><a href=\"#7、着色器程序（Shader）\" class=\"headerlink\" title=\"7、着色器程序（Shader）\"></a>7、着色器程序（Shader）</h2><p>在固定渲染管线时代，这一步并不是必须的。而是由内置的一段包含了光照、坐标变换、裁剪等等诸多功能的固定shader程序来完成。而可自定义shader，可以说是现代图形API最重要的能力了，没有之一。可以说，shader提供对图形运算的精细操作，带来了各式各样的处理能力，极度的丰富了图形API所能实现的效果。</p>\n<p>OpenGL和其他主流的图形API早在好几年前，就全面的将固定渲染管线架构变为了可编程渲染管线。因此，OpenGL在实际调用绘制函数之前，还需要指定一个由shader编译成的着色器程序。</p>\n<p>常见的着色器主要有顶点着色器（VertexShader），片段着色器（FragmentShader）&#x2F;像素着色器（PixelShader），几何着色器（GeometryShader），曲面细分着色器（TessellationShader）。片段着色器和像素着色器只是在OpenGL和DX中的不同叫法而已。可惜的是，直到OpenGL ES 3.0，依然只支持了顶点着色器和片段着色器这两个最基础的着色器。</p>\n<p>OpenGL在处理shader时，和其他编译器一样。通过编译、链接等步骤，生成了着色器程序（glProgram），着色器程序同时包含了顶点着色器和片段着色器的运算逻辑。在OpenGL进行绘制的时候，首先由顶点着色器对传入的顶点数据进行运算。再通过图元装配，将顶点转换为图元。然后进行光栅化，将图元这种矢量图形，转换为栅格化数据。最后，将栅格化数据传入片段着色器中进行运算。片段着色器会对栅格化数据中的每一个像素进行运算，并决定像素的颜色，也可以在这个阶段将某些像素丢弃。</p>\n<p>其中像素的颜色可以是具体的数值或者是由某种算法计算而来的。如果图元有纹理，就必须用纹理来产生图元的二维渲染图象上每个像素的颜色。对于图元在二维屏幕上图象的每个像素来说，都必须从纹理中获得一个颜色值。我们把这一过程称为纹理过滤（texture filtering），纹理过滤根据不同的过滤方式会由一个或多个像素确定最终获得的颜色。表示这个像素位置的数据被称为纹理坐标（TextureCoordinate）而寻找这个纹理中对应像素位置的方法被称为纹理寻址方式或者纹理环绕方式（TextureWrap）。</p>\n<p>最终，没有被丢弃的像素，下一步会进入测试阶段。通过了深度测试和模板测试，会和帧缓冲区上的颜色附着（FrameBuffer上的ColorAttachment）上的颜色进行混合，决定最终留在画布上的颜色是什么。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/2.png\"></p>\n<img src=\"3.png\" style=\"zoom:50%;\" />\n\n<h3 id=\"7-1、顶点着色器（VertexShader）\"><a href=\"#7-1、顶点着色器（VertexShader）\" class=\"headerlink\" title=\"7.1、顶点着色器（VertexShader）\"></a>7.1、顶点着色器（VertexShader）</h3><p>顶点着色器是OpenGL中用于计算顶点属性的程序。顶点着色器是逐顶点运算的程序，也就是说每个顶点数据都会执行一次顶点着色器，当然这是并行的，并且顶点着色器运算过程中无法访问其他顶点的数据。</p>\n<p>顶点着色器的数据输入主要有两种，统一变量（Uniform）、顶点属性（VertexAttribute）。统一变量在所有顶点运算中是一样的，而顶点属性则是从外部输入的顶点数据中获取，一般在每个顶点运算中都是不同的。</p>\n<p>一般来说典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照运算等等。顶点坐标由自身坐标系转换到归一化坐标系的运算，就是在这里发生的。</p>\n<p>同时顶点着色器的输出结果，也会作为片段着色器的输入。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/4.png\"></p>\n<h3 id=\"7-2、片段着色器（FragmentShader）\"><a href=\"#7-2、片段着色器（FragmentShader）\" class=\"headerlink\" title=\"7.2、片段着色器（FragmentShader）\"></a>7.2、片段着色器（FragmentShader）</h3><p>片段着色器是OpenGL中用于计算片段（像素）颜色的程序。片段做社区是逐像素运算的程序，也就是说每个像素都会执行一次片段着色器，当然也是并行的。</p>\n<p>片段着色器的的数据输入主要有三种种，统一变量（Uniform）、顶点着色器输入变量（也被称为可变变量varying）、采样器（Sampler）。统一变量的值，在同个OpenGL着色器程序中的顶点着色器和片段着色器中是一致的。顶点着色器输入变量在每个像素运算中则一般是不同的，它的值由组成图元的顶点的顶点着色器运算输出的值，根据像素位置进行插值的结果而决定。采样器则是用于从设定好的纹理中，获取纹理的像素颜色的。</p>\n<p>在片段着色器中允许丢弃像素，而使得像素不参与后续的运算。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/5.png\"></p>\n<h2 id=\"8、逐片段操作（Per-Fragment-Operation）\"><a href=\"#8、逐片段操作（Per-Fragment-Operation）\" class=\"headerlink\" title=\"8、逐片段操作（Per-Fragment Operation）\"></a>8、逐片段操作（Per-Fragment Operation）</h2><p><img src=\"/2023/04/14/4-1-OpenGL/6.png\"></p>\n<h3 id=\"8-1、测试（Test）\"><a href=\"#8-1、测试（Test）\" class=\"headerlink\" title=\"8.1、测试（Test）\"></a>8.1、测试（Test）</h3><p>在着色器程序完成之后，我们得到了像素数据。这些数据必须要通过测试才能最终绘制到画布，也就是帧缓冲上的颜色附着上。</p>\n<p>测试主要可以分为像素所有者测试（PixelOwnershipTest）、裁剪测试（ScissorTest）、模板测试（StencilTest）和深度测试（DepthTest），执行的顺序也是按照这个顺序进行执行。</p>\n<p>最开始进行的测试是像素所有者测试，主要是剔除不属于当前程序的像素运算。</p>\n<p>之后裁剪测试，主要是剔除窗口区域之外的像素。</p>\n<p>这两个测试都是由OpenGL内部实现的，无需开发者干预，因此不再进行赘述。</p>\n<p>深度测试，主要是通过对像素的运算出来的深度，也就是像素离屏幕的距离进行对比，根据OpenGL设定好的深度测试程序，决定是否最终渲染到画布上。一般默认的程序是将离屏幕较近的像素保留，而将离屏幕较远的像素丢弃。如果像素最终被渲染到画布上，根据设定好的OpenGL深度覆写状态，可能会更新帧缓冲区上深度附着的值，方便进行下一次的比较。</p>\n<p>模板测试和深度测试的执行原理一致，但是执行的顺序是在深度测试之前的，放在后面 主要是比深度测试更加难以理解一些，初学者可以暂时跳过这个部分。模板测试同样也是通过模板测试程序去决定最终的像素是否丢弃，同样也是根据OpenGL的模板覆写状态决定是否更新像素的模板值。模板测试给开发者提供了高性能的裁剪方案，三维物体的描边技术，就是模板测试典型的用处之一。</p>\n<h3 id=\"8-2、混合（Blending）\"><a href=\"#8-2、混合（Blending）\" class=\"headerlink\" title=\"8.2、混合（Blending）\"></a>8.2、混合（Blending）</h3><p>在测试阶段之后，如果像素依然没有被剔除，那么像素的颜色将会和帧缓冲区中颜色附着上的颜色进行混合，混合的算法可以通过OpenGL的函数进行指定。但是OpenGL提供的混合算法是有限的，如果需要更加复杂的混合算法，一般可以通过像素着色器进行实现，当然性能会比原生的混合算法差一些。</p>\n<h3 id=\"8-3、抖动（Dithering）\"><a href=\"#8-3、抖动（Dithering）\" class=\"headerlink\" title=\"8.3、抖动（Dithering）\"></a>8.3、抖动（Dithering）</h3><p>在混合阶段过后，根据OpenGL的状态设置，会决定是否有抖动这个阶段。</p>\n<p>抖动是一种针对对于可用颜色较少的系统，可以以牺牲分辨率为代价，通过颜色值的抖动来增加可用颜色数量的技术。抖动操作是和硬件相关的，允许程序员所做的操作就只有打开或关闭抖动操作。实际上，若机器的分辨率已经相当高，激活抖动操作根本就没有任何意义。默认情况下，抖动是激活的。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/7.png\"></p>\n<h2 id=\"9、渲染到纹理\"><a href=\"#9、渲染到纹理\" class=\"headerlink\" title=\"9、渲染到纹理\"></a>9、渲染到纹理</h2><p>有些OpenGL程序并不希望渲染出来的图像立即显示在屏幕上，而是需要多次渲染。可能其中一次渲染的结果是下次渲染的输入。因此，如果帧缓冲区的颜色附着设置为一张纹理，那么渲染完成之后，可以重新构造新的帧缓冲区，并将上次渲染出来的纹理作为输入，重新进行前面所述的流程。</p>\n<h2 id=\"10、渲染上屏-x2F-交换缓冲区-SwapBuffer\"><a href=\"#10、渲染上屏-x2F-交换缓冲区-SwapBuffer\" class=\"headerlink\" title=\"10、渲染上屏&#x2F;交换缓冲区(SwapBuffer)\"></a>10、渲染上屏&#x2F;交换缓冲区(SwapBuffer)</h2><p>前面已经提过，渲染缓冲区一般映射的是系统的资源比如窗口。如果将图像直接渲染到窗口对应的渲染缓冲区，则可以将图像显示到屏幕上。</p>\n<p>但是，值得注意的是，如果每个窗口只有一个缓冲区，那么在绘制过程中屏幕进行了刷新，窗口可能显示出不完整的图像。</p>\n<p>为了解决这个问题，常规的OpenGL程序至少都会有两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区。在一个缓冲区渲染完成之后，通过将屏幕缓冲区和离屏缓冲区交换，实现图像在屏幕上的显示。</p>\n<p>由于显示器的刷新一般是逐行进行的，因此为了防止交换缓冲区的时候屏幕上下区域的图像分属于两个不同的帧，因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进行交换，这个信号就被称为垂直同步信号，这个技术被称为垂直同步。</p>\n<p>使用了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后再进行下一帧的渲染，使得帧率无法完全达到硬件允许的最高水平。为了解决这个问题，引入了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，而垂直同步发生时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利用硬件性能的目的。</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/9.jpg\"></p>\n<h3 id=\"11-顶点数据最终加工成图像的过程\"><a href=\"#11-顶点数据最终加工成图像的过程\" class=\"headerlink\" title=\"11.顶点数据最终加工成图像的过程\"></a>11.顶点数据最终加工成图像的过程</h3><p><strong>着色器（shader）</strong>是在GPU上运行的小程序，GPU有成千上万个处理核心，能进行非常多的并行计算，在些计算的逻辑就写在着色器里，上图中蓝色部分就是表示我们可以通过写shader来进行控制的部分</p>\n<p><strong>顶点着色器</strong>先把3D坐标转换成另一种3D坐标，也就是OpenGL世界里的坐标<br>        <strong>图元着色器</strong>会把顶点着色器传进来的坐标连接成一个图形<br>        <strong>几何着色器</strong>可以进一步构造新的图元或其他形状<br>        <strong>光栅化</strong>就是把图元映射成屏幕上对应的像素<br>        <strong>片段着色器</strong>用来给物体上色<br>        <strong>测试与混合</strong>如果物体对应Alpha值所表示的颜色带有一定的透明，它后面有不完全透明的物体，则要跟后面物体的颜色进行混合，以此达到透明效果，如果被前面物体挡住了，就丢弃被挡住部分的像素</p>\n<p>整个流程就像工厂里的流水线一样，把原料（顶点数据）从一头放入，经过一道道工序的处理，最终变成产品，所以这个渲染流程也叫渲染流水线</p>\n<p><img src=\"/2023/04/14/4-1-OpenGL/15.png\"></p>\n<h1 id=\"四、例程\"><a href=\"#四、例程\" class=\"headerlink\" title=\"四、例程\"></a>四、例程</h1><h2 id=\"1-创建窗口\"><a href=\"#1-创建窗口\" class=\"headerlink\" title=\"1.创建窗口\"></a>1.创建窗口</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// System Headers</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;glad/glad.h&gt;</span><span class=\"comment\">//函数加载</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;GLFW/glfw3.h&gt;</span><span class=\"comment\">//窗口管理</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Standard Headers</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">framebuffer_size_callback</span><span class=\"params\">(GLFWwindow *window, <span class=\"type\">int</span> width, <span class=\"type\">int</span> height)</span></span>;<span class=\"comment\">//回调函数原型声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processInput</span><span class=\"params\">(GLFWwindow *window)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// settings</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> SCR_WIDTH = <span class=\"number\">800</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">unsigned</span> <span class=\"type\">int</span> SCR_HEIGHT = <span class=\"number\">600</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">glfwInit</span>();<span class=\"comment\">//初始化    </span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR, <span class=\"number\">3</span>);<span class=\"comment\">//设置主版本号</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR, <span class=\"number\">3</span>);<span class=\"comment\">//设置次版本号</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);<span class=\"comment\">//使用核心模式</span></span><br><span class=\"line\">    <span class=\"comment\">//创建一个窗口对象,参数：窗口宽，窗口高，窗口标题，暂时忽略，暂时忽略</span></span><br><span class=\"line\">    GLFWwindow *window = <span class=\"built_in\">glfwCreateWindow</span>(SCR_WIDTH, SCR_HEIGHT, <span class=\"string\">&quot;GLFW 3.3.1&quot;</span>, <span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (window == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Failed to create GLFW window&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"built_in\">glfwTerminate</span>();<span class=\"comment\">//释放内存</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//通知GLFW将我们窗口的上下文设置为当前线程的主上下文</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwMakeContextCurrent</span>(window);</span><br><span class=\"line\">    <span class=\"comment\">//对窗口注册一个回调函数,每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwSetFramebufferSizeCallback</span>(window, framebuffer_size_callback);</span><br><span class=\"line\">    <span class=\"comment\">//初始化GLAD用来管理OpenGL的函数指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress)) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Failed to initialize GLAD&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置视口，OpenGL幕后的坐标转窗口坐标将以此为参考</span></span><br><span class=\"line\">    <span class=\"comment\">//OpenGL的坐标最大最小值为1和-1</span></span><br><span class=\"line\">    <span class=\"comment\">//如下x轴-1~1对应窗口坐标0~800,y轴-1～1对应窗口坐标0~600</span></span><br><span class=\"line\">    <span class=\"comment\">//如OpenGL坐标（0，0）对应窗口坐标（400,300），（-0.5,0.5）对应（200,450）</span></span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">800</span>,<span class=\"number\">600</span>);</span><br><span class=\"line\">    <span class=\"comment\">//渲染循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">glfwWindowShouldClose</span>(window)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//监视键盘 输入</span></span><br><span class=\"line\">        <span class=\"built_in\">processInput</span>(window);</span><br><span class=\"line\">        <span class=\"comment\">// 渲染指令</span></span><br><span class=\"line\">        <span class=\"built_in\">glClearColor</span>(<span class=\"number\">0.2f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">0.3f</span>, <span class=\"number\">1.0f</span>);<span class=\"comment\">//清除颜色缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_COLOR_BUFFER_BIT 颜色缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_DEPTH_BUFFER_BIT 深度缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_STENCIL+BUFFER_BIT 模板缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\">        <span class=\"comment\">//交换颜色缓冲，OpenGL绘图的时候，前缓冲用于显示，后缓冲就在渲染</span></span><br><span class=\"line\">        <span class=\"comment\">//当后缓冲渲染完毕，前缓冲和后缓冲互换，后缓冲变前缓冲，前缓冲变后缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">// 检查并调用事件，交换缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glfwSwapBuffers</span>(window);<span class=\"comment\">//检查触发事件</span></span><br><span class=\"line\">        <span class=\"comment\">//消息分发函数 检测有没有触发窗口消息，然后调用对应回调函数</span></span><br><span class=\"line\">        <span class=\"built_in\">glfwPollEvents</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//释放/删除之前的分配的所有资源,释放内存</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwTerminate</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输入控制，检查用户是否按下了返回键(Esc)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processInput</span><span class=\"params\">(GLFWwindow *window)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">glfwSetWindowShouldClose</span>(window, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当用户改变窗口的大小的时候，视口也应该被调整</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">framebuffer_size_callback</span><span class=\"params\">(GLFWwindow *window, <span class=\"type\">int</span> width, <span class=\"type\">int</span> height)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意：对于视网膜(Retina)显示屏，width和height都会明显比原输入值更高一点。</span></span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, width, height);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-能控制移动的彩色矩形\"><a href=\"#2-能控制移动的彩色矩形\" class=\"headerlink\" title=\"2.能控制移动的彩色矩形\"></a>2.能控制移动的彩色矩形</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;glad/glad.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//顶点着色器</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *vertexShaderSource = </span><br><span class=\"line\"><span class=\"string\">&quot;#version 330 core\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;layout (location = 0) in vec3 aPos;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;layout (location = 1) in vec3 aColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;out vec3 ourColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;uniform vec2 pos;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;void main()&#123;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;    gl_Position = vec4(aPos.x+pos.x,aPos.y+pos.y,aPos.z,1.0);\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;    ourColor=aColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;\\n&#125;&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//片段着色器</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> *fragmentShaderSource =</span><br><span class=\"line\"><span class=\"string\">&quot;#version 330 core\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;out vec4 FragColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;in vec3 ourColor;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;void main()&#123;\\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;    FragColor = vec4(ourColor,0.8f);&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#125;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//顶点和颜色数据</span></span><br><span class=\"line\"><span class=\"type\">float</span> vertices[] = &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 位置              // 颜色</span></span><br><span class=\"line\">     <span class=\"number\">0.5f</span>, <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,   <span class=\"comment\">// 右下</span></span><br><span class=\"line\">    <span class=\"number\">-0.5f</span>, <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>,   <span class=\"comment\">// 左下</span></span><br><span class=\"line\">     <span class=\"number\">-0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>,    <span class=\"comment\">// 顶部</span></span><br><span class=\"line\">     <span class=\"number\">0.5f</span>,  <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.5f</span>, <span class=\"number\">0.5f</span>    <span class=\"comment\">// 顶部</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//索引</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> indices[] = &#123; <span class=\"comment\">// 注意索引从0开始! </span></span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"comment\">// 第一个三角形</span></span><br><span class=\"line\">    <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>  <span class=\"comment\">// 第二个三角形</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//矩形平面坐标</span></span><br><span class=\"line\"><span class=\"type\">float</span> x=<span class=\"number\">0</span>,y=<span class=\"number\">0</span>,speed=<span class=\"number\">0.02f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//编译着色器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">CompileShader</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span>* source,<span class=\"type\">int</span> type)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> shader=<span class=\"built_in\">glCreateShader</span>(type);</span><br><span class=\"line\">    <span class=\"built_in\">glShaderSource</span>(shader,<span class=\"number\">1</span>,&amp;source,<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"built_in\">glCompileShader</span>(shader);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> ret=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span> log[<span class=\"number\">512</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">glGetShaderiv</span>(shader,GL_COMPILE_STATUS,&amp;ret);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!ret)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">glGetShaderInfoLog</span>(shader,<span class=\"number\">512</span>,<span class=\"literal\">nullptr</span>,log);</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;着色器编译失败：&quot;</span>&lt;&lt;log&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> shader;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//窗口大小变动的回调函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">framebuffer_size_callback</span><span class=\"params\">(GLFWwindow* window,<span class=\"type\">int</span> width,<span class=\"type\">int</span> height)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,width,height);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果ESC键按下，则关闭窗口</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processInput</span><span class=\"params\">(GLFWwindow *window)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">glfwSetWindowShouldClose</span>(window, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window,GLFW_KEY_D) == GLFW_PRESS)&#123;</span><br><span class=\"line\">        x&gt;=<span class=\"number\">0.5f</span> ? x=<span class=\"number\">0.5f</span> : x+=speed;   </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window,GLFW_KEY_A) == GLFW_PRESS)&#123; </span><br><span class=\"line\">        x&lt;=<span class=\"number\">-0.5f</span> ? x=<span class=\"number\">-0.5f</span> : x-=speed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window,GLFW_KEY_W) == GLFW_PRESS)&#123;</span><br><span class=\"line\">        y&gt;=<span class=\"number\">0.5f</span> ? y=<span class=\"number\">0.5f</span> : y+=speed;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">glfwGetKey</span>(window,GLFW_KEY_S) == GLFW_PRESS)&#123;</span><br><span class=\"line\">        y&lt;=<span class=\"number\">-0.5f</span> ? y = <span class=\"number\">-0.5f</span> : y-=speed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">glfwInit</span>();<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MAJOR,<span class=\"number\">3</span>); <span class=\"comment\">//主版本号</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_CONTEXT_VERSION_MINOR,<span class=\"number\">3</span>);<span class=\"comment\">//次版本号</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwWindowHint</span>(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);<span class=\"comment\">//采用核心模式</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//参数：窗口宽，窗口高，窗口标题，暂时忽略，暂时忽略</span></span><br><span class=\"line\">    GLFWwindow* window = <span class=\"built_in\">glfwCreateWindow</span>(<span class=\"number\">800</span>,<span class=\"number\">600</span>,<span class=\"string\">&quot;这是窗口标题&quot;</span>,<span class=\"literal\">nullptr</span>,<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!window)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;创建窗口失败！&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"built_in\">glfwTerminate</span>();<span class=\"comment\">//释放内存</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">glfwMakeContextCurrent</span>(window);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//初始化GLAD，GLAD用于管理函数指针</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"built_in\">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress))&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;初始化GLAD失败&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//设置视口，OpenGL幕后的坐标转窗口坐标将以此为参考</span></span><br><span class=\"line\">    <span class=\"comment\">//OpenGL的坐标最大最小值为1和-1</span></span><br><span class=\"line\">    <span class=\"comment\">//如下x轴-1~1对应窗口坐标0~800,y轴-1～1对应窗口坐标0~600</span></span><br><span class=\"line\">    <span class=\"comment\">//如OpenGL坐标（0，0）对应窗口坐标（400,300），（-0.5,0.5）对应（200,450）</span></span><br><span class=\"line\">    <span class=\"built_in\">glViewport</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">800</span>,<span class=\"number\">600</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//编译着色器</span></span><br><span class=\"line\">    <span class=\"type\">int</span> vertexShader=<span class=\"built_in\">CompileShader</span>(vertexShaderSource, GL_VERTEX_SHADER);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!vertexShader) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> fragmentShader=<span class=\"built_in\">CompileShader</span>(fragmentShaderSource, GL_FRAGMENT_SHADER);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!fragmentShader) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//链接着色器程序</span></span><br><span class=\"line\">    <span class=\"type\">int</span> shaderProgram=<span class=\"built_in\">glCreateProgram</span>();</span><br><span class=\"line\">    <span class=\"built_in\">glAttachShader</span>(shaderProgram,vertexShader);</span><br><span class=\"line\">    <span class=\"built_in\">glAttachShader</span>(shaderProgram,fragmentShader);</span><br><span class=\"line\">    <span class=\"built_in\">glLinkProgram</span>(shaderProgram);</span><br><span class=\"line\">    <span class=\"built_in\">glDeleteShader</span>(vertexShader);</span><br><span class=\"line\">    <span class=\"built_in\">glDeleteShader</span>(fragmentShader);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建VAO</span></span><br><span class=\"line\">    GLuint VAO=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">glGenVertexArrays</span>(<span class=\"number\">1</span>,&amp;VAO);</span><br><span class=\"line\">    <span class=\"built_in\">glBindVertexArray</span>(VAO);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//创建VBO</span></span><br><span class=\"line\">    GLuint VBO=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">glGenBuffers</span>(<span class=\"number\">1</span>,&amp;VBO);</span><br><span class=\"line\">    <span class=\"built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);</span><br><span class=\"line\">    <span class=\"built_in\">glBufferData</span>(GL_ARRAY_BUFFER,<span class=\"built_in\">sizeof</span>(vertices),vertices,GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建EBO</span></span><br><span class=\"line\">    GLuint EBO=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">glGenBuffers</span>(<span class=\"number\">1</span>,&amp;EBO);</span><br><span class=\"line\">    <span class=\"built_in\">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER,EBO);</span><br><span class=\"line\">    <span class=\"built_in\">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER,<span class=\"built_in\">sizeof</span>(indices),indices,GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//顶点数据 从偏移0 * 6*sizeof(float)处开始拿3个float</span></span><br><span class=\"line\">    <span class=\"comment\">//之后再从偏移1 * 6*sizeof(float)处开始拿3个float 直到拿完</span></span><br><span class=\"line\">    <span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">0</span>,<span class=\"number\">3</span>,GL_FLOAT,GL_FALSE,<span class=\"number\">6</span>*<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>),(<span class=\"type\">void</span>*)<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">//颜色数据同上 不过偏移是从3*sizeof(float)开始，不是从0</span></span><br><span class=\"line\">    <span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,GL_FLOAT,GL_FALSE,<span class=\"number\">6</span>*<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>),(<span class=\"type\">void</span>*)(<span class=\"number\">3</span>*<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>)));</span><br><span class=\"line\">    <span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> index=<span class=\"built_in\">glGetUniformLocation</span>(shaderProgram,<span class=\"string\">&quot;pos&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//注册窗口大小变化回调函数</span></span><br><span class=\"line\">    <span class=\"built_in\">glfwSetFramebufferSizeCallback</span>(window,framebuffer_size_callback);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//窗口循环 如果窗口被关闭，则退出循环</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!<span class=\"built_in\">glfwWindowShouldClose</span>(window))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//监视键盘输入</span></span><br><span class=\"line\">        <span class=\"built_in\">processInput</span>(window);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//清除颜色缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glClearColor</span>(<span class=\"number\">0.2f</span>,<span class=\"number\">0.3f</span>,<span class=\"number\">0.3f</span>,<span class=\"number\">0.8f</span>);</span><br><span class=\"line\">        <span class=\"comment\">//GL_COLOR_BUFFER_BIT 颜色缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_DEPTH_BUFFER_BIT 深度缓冲</span></span><br><span class=\"line\">        <span class=\"comment\">//GL_STENCIL+BUFFER_BIT 模板缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">glUseProgram</span>(shaderProgram);</span><br><span class=\"line\">        <span class=\"built_in\">glBindVertexArray</span>(VAO);</span><br><span class=\"line\">        <span class=\"built_in\">glUniform2f</span>(index,x,y);</span><br><span class=\"line\">        <span class=\"built_in\">glDrawElements</span>(GL_TRIANGLES,<span class=\"number\">6</span>,GL_UNSIGNED_INT,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//交换颜色缓冲，OpenGL绘图的时候，前缓冲用于显示，后缓冲就在渲染</span></span><br><span class=\"line\">        <span class=\"comment\">//当后缓冲渲染完毕，前缓冲和后缓冲互换，后缓冲变前缓冲，前缓冲变后缓冲</span></span><br><span class=\"line\">        <span class=\"built_in\">glfwSwapBuffers</span>(window);</span><br><span class=\"line\">        <span class=\"comment\">//消息分发函数 检测有没有触发窗口消息，然后调用对应回调函数</span></span><br><span class=\"line\">        <span class=\"built_in\">glfwPollEvents</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">glDeleteVertexArrays</span>(<span class=\"number\">1</span>,&amp;VAO);</span><br><span class=\"line\">    <span class=\"built_in\">glDeleteBuffers</span>(<span class=\"number\">1</span>,&amp;VBO);</span><br><span class=\"line\">    <span class=\"built_in\">glDeleteBuffers</span>(<span class=\"number\">1</span>,&amp;EBO);</span><br><span class=\"line\">    <span class=\"built_in\">glfwTerminate</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"OpenGL ES 3.x概述","date":"2023-04-14T13:33:11.000Z","comments":0,"description":null,"typora-root-url":"4-2-OpenGL ES","_content":"\n# 一、OpenGL ES 3.x概述\n\nOpenGL ES 是基于 OpenGL 三维图形 API 的子集，主要是针对手机以及 PDA（掌上电脑）等嵌入式设备设计的。 OpenGL ES 的 API 由 Khronos 组织定义并推广， Khronos 是一个图形软硬件行业协会，该协会致力于为这些 API 建立免费的开发标准。\n\n## 1、 OpenGL ES3.x简介 \n\nOpenGL 的应用领域较为广泛，适用于 UNIX、 Mac OS、 Linux 以及 Windows 等几乎所有的操作系统，可以开发游戏、工业建模以及嵌入式设备应用。\n\nOpenGL ES 是专门针对嵌入式设备而设计的，其实际是 OpenGL 的剪裁版本，去除了OpenGL 中许多不是必须存在的特性，如 GL_QUADS（四边形）与 GL_POLYGONS（多边形）绘制模式以及 glBegin（开始） /glEnd（结束）操作等。\n\n##  2.OpenGL与OpenGL-ES的主要区别：\n\n<!--more--> \n\n之所以会推出OpenGL-ES版本，主要是应对嵌入式环境和应用的要求。\n\n早先定义OpenGL ES是OpenGL的嵌入式设备版本，但由于嵌入式设备要求的是高性能，所以一些其它纯追求高性能的设备也开始用这种API方式，比如 SONY PlayStation 3。  \n\n OpenGL ES相对OpenGL删减了一切低效能的操作方式，有高性能的决不留低效能的，即只求效能不求兼容性。\n\n嵌入式设备一般工作于较恶劣的环境，包括：温度、湿度、振动、冲击、酸碱腐蚀等。例如：中国的酸雨气候就给很多室外电子设备带来了新的难题，中东地区的风沙也使得美军必须采用更先进的非IT技术来保护他们的电子设备。 \n\n需要人机界面的嵌入式应用，由于受环境受环境因素的影响，一般不能提供有缘电源，在有限的电能限制下工作，如何以更低的功耗完成人机交互界面，成为OpenGL必须要面对的问题，进而推出了OpenGL-ES标准。应该说在高效完成2D/3D界面的同时，达到了降低功耗的效果。 \n\n##  3.OpenGL ES 1.0、2.0、3.0的区别 \n\n### OpenGL ES1.0：\n\n 针对固定管线硬件(fixed pipeline)，通过它内建的functions来设置诸如灯光、vertexes（图形的顶点数）、颜色、camera等等的东西。\n\n### OpenGL ES2.0：\n\n 针对可编程管线硬件(programmable pipeline)，需要自己动手编写任何功能。与此同时，2.0相比于1.0更具灵活性，功能也更强大。可以自定义顶点和像素计算，可以让表现方式更加准确。\n\n### OpenGL ES3.0：\n\n OpenGL ES3.0扩展了OpenGL ES2.0，支持许多新的渲染技术、优化和显示质量改进，包括——引入了许多和纹理相关的新功能，对着色语言进行了重大更新和支持着色器新功能的API特性，引入了多种与几何形状规范和图元渲染控制相关的新功能，引入了新的缓冲区对象，增添了许多与屏幕外渲染到帧缓冲区对象相关的新功能。具体功能在后边的文章详细说明。（可能:））\n\n###  OpenGL ES 3.0的向后兼容新 \n\nOpenGL ES 3.0向后兼容OpenGL ES 2.0，但由于3.0/2.0不支持1.x支持的固定功能管线，3.0/2.0不能向后兼容1.x。\n\n## 4.EGL/EAGL \n\nEGL API 参考页面:https://www.khronos.org/registry/EGL/sdk/docs/man/)\n\n### 4.1作用\n\n EGL就是Embedded Graphics Library。嵌入式图形框架。 EGL是Khronos渲染API（如OpenGL ES）和原生窗口系统之间的接口（在iOS上则是EAGL）\n\n### 4.2原因\n\nOpenGL-ES 命令需要存储渲染上下文的状态和绘制表面的支持才能完成图形图像的绘制. \n\n- 渲染上下文：存储相关的OpenGL-ES 状态\n- 绘制表面：是用于绘制图元的表面，它指定渲染所需的缓冲区类型，比如颜色缓冲区，深度缓冲区和模板缓冲区，绘制表面还需要指定所需缓冲区的位深度\n\n因为OpenGL-ES API没有提及如何常见渲染上下文，或者渲染上下文如何连接到原生窗口系统，EGL就是 khronos 提出的OpenGL-ES 和原生窗口系统之间的接口；（ 唯⼀⽀持OpenGL ES 却不⽀持EGL 的平台是iOS。Apple 提供⾃⼰的EGL API的iOS实现,称为EAGL。 ）\n\n###  4.3EGL的功能如下：\n\n- 查询并初始化设备显示商的可用显示设备\n- 创建渲染表面\n   EGL创建的表面可用分为屏幕上的表面和屏幕外的表面，屏幕上的表面连接到原生窗口系统，屏幕外的表面不显示但是用作渲染表面的像素缓冲区\n- 创建渲染上下文\n   EGL 的最新版本时 EGL v1.4\n\n### 4.4使用流程\n\n任何OpenGL ES应用程序都必须在开始渲染之前使用EGL执行如下任务：\n\n<img src=\"9.jpg\" style=\"zoom: 80%;\" />\n\n\n\n\n\n## 5.OpenGL ES 3.0图形管线的各个阶段 \n\n![](8.png)\n\n![](10.jpg)\n\n### 5.1顶点着色器\n\n顶点和顶点着色器(Vertex & Vertex shader)，shader 是指运行在GPU可编程管线上的程序，也就是GPU所用的编程语言，本质是一种类C语言。\n Vertex shader 的内容包含：\n\n- shader程序： 用来描述顶点上执⾏操作的顶点着⾊器程序源代码/可执⾏⽂件 \n\n- shader 的输入属性，就是顶点数组提供的各个顶点的属性\n\n- uniform(统一变量)  Vertex/Pixel shader 使用的不变的变量，如：颜色数据\n\n- 采样器， 代表顶点着⾊器使⽤纹理的特殊统⼀变量类型。 \n\n  ![](11.jpg)\n\n 如图所示，可以由很多属性输入到顶点着色器，最后顶点着色器也会输出属性数据，其中gl_Position和gl_PointSize是OpenGL的内建变量。\n\n在图元光栅化阶段，为每个生成的片段计算 vertex shader 的输出值，并作为输入值传递给pixel shader,\n **用于分配给每个图元顶点的Vertex shader输出每个片段值的机制被称为插值** \n\n### 5.2图元装配\n\n图元(Primitive):  基本的图形对象 。如：点，线，三⻆形等。\n\n图元装配: 将顶点数据计算成⼀个个图元.在这个阶段会执⾏裁剪、透视分割和Viewport变换操作。\n\n  对于每个单独图元及其对应的顶点， 图元装配阶段执⾏的操作包括：将顶点着⾊器的输出值执⾏裁剪、透视分割、视⼝变换后进⼊光栅化阶段 \n\n### 5.3光栅化\n\n 光栅化是将**图元转换为一组二维片段的过程**，此后这些片段就会交给Pixel shader 处理，这些二维片段就是屏幕上可以绘制的像素。 \n\n![](12.jpg)\n\n### 5.4 **⽚元着⾊器/⽚段着⾊器** \n\n片段着色器（Pixel shader/Fragment shader）为片段操作实现了通用的可编程方法，它的组成如下：\n\n- Shader 程序-- 描述⽚段上执⾏操作的⽚元着⾊器程序源代码/可执⾏⽂件 \n\n- 输入变量--光栅化阶段用插值为每个片段生成的 Vertex shader 输出\n\n- 输出变量-- 统⼀变量(uniform)--顶点/⽚元着⾊器使⽤的不变数据 \n\n- 采样器--代表⽚元着⾊器使⽤纹理的特殊统⼀变量类型 \n\n  ![](13.jpg)\n\n### 5.5逐片段操作\n\n![](14.webp)\n\n- 像素归属测试: 确定帧缓存区中位置(Xw,Yw)的像素⽬前是不是归属于OpenGL ES所有. 例如,如果⼀个显示OpenGL ES帧缓存区View被另外⼀个View 所遮蔽.则窗⼝系统可以确定被遮蔽的像素不属于OpenGL ES 上下⽂.从⽽不全显示这些像素. ⽽像素归属测试是OpenGL ES 的⼀部分,它不由开发者开⼈为控制,⽽是由OpenGL ES 内部进⾏。\n- 裁剪测试: 裁剪测试确定(Xw,Yw)是否位于作为OpenGL ES状态的⼀部分裁剪矩形范围内.如果该⽚段位于裁剪区域之外,则被抛弃。\n- 深度测试: 输⼊⽚段的深度值进步⽐较,确定⽚段是否拒绝测试。\n- 混合: 混合将新⽣成的⽚段颜⾊与保存在帧缓存的位置的颜⾊值组合起来。\n- 抖动: 抖动可⽤于最⼩化因为使⽤有限精度在帧缓存区中保存颜⾊值⽽产⽣的伪像。\n\n# 二、环境搭建\n\n# 三、第一个OpenGL ES 3.0程序\n\n```c\n#include \"esUtil.h\"\n\ntypedef struct\n{\n   // Handle to a program object\n   GLuint programObject;\n\n} UserData;\n\n///\n// Create a shader object, load the shader source, and\n// compile the shader.\n//\nGLuint LoadShader ( GLenum type, const char *shaderSrc )\n{\n   GLuint shader;\n   GLint compiled;\n\n   // Create the shader object,创建指定类型的新着色器对象\n   shader = glCreateShader ( type );\n\n   if ( shader == 0 )\n   {\n      return 0;\n   }\n\n   // Load the shader source着色器源代码本身用glShaderSource加载到着色器对象\n   glShaderSource ( shader, 1, &shaderSrc, NULL );\n\n   // Compile the shader着色器用glCompileShader函数编译\n   glCompileShader ( shader );\n\n   // Check the compile status确定编译的状态，打印输出生成的错误\n   glGetShaderiv ( shader, GL_COMPILE_STATUS, &compiled );\n\n   if ( !compiled )\n   {\n      GLint infoLen = 0;\n\n      glGetShaderiv ( shader, GL_INFO_LOG_LENGTH, &infoLen );\n\n      if ( infoLen > 1 )\n      {\n         char *infoLog = malloc ( sizeof ( char ) * infoLen );\n\n         glGetShaderInfoLog ( shader, infoLen, NULL, infoLog );\n         esLogMessage ( \"Error compiling shader:\\n%s\\n\", infoLog );\n\n         free ( infoLog );\n      }\n\n      glDeleteShader ( shader );\n      return 0;\n   }\n\n   return shader;//着色器编译成功，则返回一个新的着色器对象。\n\n}\n\n///\n// Initialize the shader and program object\n//\nint Init ( ESContext *esContext )\n{\n   UserData *userData = esContext->userData;\n    //顶点着色器\n   char vShaderStr[] =\n      \"#version 300 es                          \\n\"\n      \"layout(location = 0) in vec4 vPosition;  \\n\"\n      \"void main()                              \\n\"\n      \"{                                        \\n\"\n      \"   gl_Position = vPosition;              \\n\"\n      \"}                                        \\n\";\n\t/*1.声明着色器版本；\n\t2.声明一个名为vPosition的4分量向量输入属性，layout（location=0）限定符表示这个变量的位置是顶点属性0；\n\t3.声明一个main函数，表示着色器执行的开始，{}中是着色器主体，将vPosition输入属性拷贝到名为gl_Position的特殊输出变量。每个顶点着色器必须在gl_Position变量中输出一个位置，这个变量定义传递到管线下一个阶段的位置。*/\n    //片断着色器\n   char fShaderStr[] =\n      \"#version 300 es                              \\n\"\n      \"precision mediump float;                     \\n\"\n      \"out vec4 fragColor;                          \\n\"\n      \"void main()                                  \\n\"\n      \"{                                            \\n\"\n      \"   fragColor = vec4 ( 1.0, 0.0, 0.0, 1.0 );  \\n\"\n      \"}                                            \\n\";\n\n   GLuint vertexShader;\n   GLuint fragmentShader;\n   GLuint programObject;\n   GLint linked;\n\n   // Load the vertex/fragment shaders.编译和加载着色器\n   vertexShader = LoadShader ( GL_VERTEX_SHADER, vShaderStr );\n   fragmentShader = LoadShader ( GL_FRAGMENT_SHADER, fShaderStr );\n\n   // Create the program object创建一个程序对象\n   programObject = glCreateProgram ( );\n\n   if ( programObject == 0 )\n   {\n      return 0;\n   }\n\t//用glAttachShader将顶点着色器和片断着色器连接到对象上。\n   glAttachShader ( programObject, vertexShader );\n   glAttachShader ( programObject, fragmentShader );\n\n   // Link the program连接程序\n   glLinkProgram ( programObject );\n\n   // Check the link status检查错误\n   glGetProgramiv ( programObject, GL_LINK_STATUS, &linked );\n\n   if ( !linked )\n   {\n      GLint infoLen = 0;\n\n      glGetProgramiv ( programObject, GL_INFO_LOG_LENGTH, &infoLen );\n\n      if ( infoLen > 1 )\n      {\n         char *infoLog = malloc ( sizeof ( char ) * infoLen );\n\n         glGetProgramInfoLog ( programObject, infoLen, NULL, infoLog );\n         esLogMessage ( \"Error linking program:\\n%s\\n\", infoLog );\n\n         free ( infoLog );\n      }\n\n      glDeleteProgram ( programObject );\n      return FALSE;\n   }\n\n   // Store the program object.保存程序对象。对象连接成功后，可以使用程序对象进行渲染，可以调用glUseProgram ( userData->programObject )来使用程序对象\n   userData->programObject = programObject;\n\n   glClearColor ( 1.0f, 1.0f, 1.0f, 0.0f );\n   return TRUE;\n}\n\n///\n// Draw a triangle using the shader pair created in Init()\n//Draw回调函数用于绘制帧\nvoid Draw ( ESContext *esContext )\n{\n   UserData *userData = esContext->userData;\n   GLfloat vVertices[] = {  0.0f,  0.5f, 0.3f,\n                            -0.5f, -0.5f, 0.5f,\n                            0.5f, -0.5f, -0.4f\n                         };\n\n   // Set the viewport设置视口的原点和宽高\n   glViewport ( 0, 0, esContext->width, esContext->height );\n\n   // Clear the color buffer清除缓冲区，清除颜色为glClearColor指定的颜色\n   glClear ( GL_COLOR_BUFFER_BIT );\n\n   // Use the program object对象连接成功后，可以使用程序对象进行渲染\n   glUseProgram ( userData->programObject );\n\n   // Load the vertex data加载几何形状和绘制图元\n    //三角形的顶点由vVertices数组中的三个坐标（x， y， z）指定。顶点位置使用glVertexAttribPointer加载到GL，并连接到顶点着色器生命的vPosition属性\n   glVertexAttribPointer ( 0, 3, GL_FLOAT, GL_FALSE, 0, vVertices );\n   glEnableVertexAttribArray ( 0 );\n\n   glDrawArrays ( GL_TRIANGLES, 0, 3 );//告诉OpenGL ES绘制图元\n}\n\nvoid Shutdown ( ESContext *esContext )\n{\n   UserData *userData = esContext->userData;\n\n   glDeleteProgram ( userData->programObject );\n}\n//应用程序的主入口。ESContext有一个名为userData、类型为void的成员变量，应用程序所需的所有数据保存在userData中\nint esMain ( ESContext *esContext )\n{\n   esContext->userData = malloc ( sizeof ( UserData ) );//分配userData\n\n   esCreateWindow ( esContext, \"Hello Triangle\", 375, 667, ES_WINDOW_RGB );//创建了窗口并初始化绘图回调函数\n\t//创建顶点着色器和片断着色器,OpenGL ES 3.0程序必须至少有一个顶点着色器和一个片断着色器。\n   if ( !Init ( esContext ) )\n   {\n      return GL_FALSE;\n   }\n\n   esRegisterShutdownFunc ( esContext, Shutdown );\n   esRegisterDrawFunc ( esContext, Draw );\n\n   return GL_TRUE;\n}\n```\n\n代码分析参见： [OpenGL ES 3.0 入门 - 简书 (jianshu.com)](https://www.jianshu.com/p/2ce67644eae8) \n\n## 代码流程框架1\n\n<img src=\"16.jpg\" style=\"zoom:80%;\" />\n\n## 代码流程框架2\n\n![](19.jpg)\n\n## 代码流程框架3\n\n![](20.jpg)\n\n# 四、OpenGL-ES 3.0/2.0 API查询网站\n\nOpenGL-ES 3.0 API：https://www.khronos.org/registry/OpenGL-Refpages/es3.0/\n\nOpenGL-ES 2.0 API：https://registry.khronos.org/OpenGL-Refpages/es2.0/\n\n# 五、坐标系的转换\n\n1、OpenGL坐标系\n\n2、纹理坐标系\n\n 2D纹理是一个图像数据的二维数组。一个纹理单独数据元素称作“纹素”(Texel)。图像中的每个纹素根据基本格式和数据类型指定。如果用2D纹理渲染时，纹理坐标用作图像中的索引。2D纹理的纹理坐标用一对2D坐标(s,t)或者(u,v)来表示，这些坐标用于查找一个纹理贴图的规范化坐标。 \n\n![](18.webp)\n\n 纹理图像的左下坐标由(0.0,0.0)决定，右上角坐标由(1.0,1.0)指定。在[0.0,1.0]之外的坐标是允许的，在区间之外的纹理读取行为由纹理包装模式决定。 \n\n3、屏幕坐标系\n\n![](17坐标系.png)\n\n裁剪： 限制纹理坐标的取值范围来实现裁剪的效果 \n\n\n\n# 六、纹理对象的创建与加载\n\n## 1.本地资源\n\nOpenCv读取，然后绑定纹理\n\n```cpp\nstatic int LoadTextures(void)\n{\n    string name;\n    cv::Mat image;\n\tGLuint LoadingTexture；\n        \n    name = string(\"../\" + \"resource/Loadingpicture-\" + to_string(1) + \".png\";//读取UI文件资源路径\n    image = cv::imread(name, cv::IMREAD_UNCHANGED);//OpenCv读取文件\n    if(image.data == NULL)\n    {\n        PRINT(\"%s::%d Load Loadingpicture.png Failed \\n\",\t__FILE__,  __LINE__);   \n        return -1;\n    }\n    /* Genarate Texture  */\n    glGenTextures(1, &LoadingTexture);//生成纹理名称\n    glBindTexture(GL_TEXTURE_2D, LoadingTexture);//绑定指定纹理到目标\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,image.cols, image.rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, image.data);//指定2D纹理对象（目标纹理GL_TEXTURE_2D）\n    /* Linear Filtering */\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glBindTexture(GL_TEXTURE_2D, 0);\n    return 1;\n｝\n```\n\n## 2.缓冲区资源\n\n创建EGLImage对象，然后绑定纹理\n\n```\n\n```\n\n","source":"_posts/4-2-OpenGL ES.md","raw":"---\ntitle: OpenGL ES 3.x概述\ndate: 2023-4-14 21:33:11\ncategories: 笔记\ntags: [嵌入式,OpenGL]\ncomments: false\ndescription:\ntypora-root-url: 4-2-OpenGL ES\n\n---\n\n# 一、OpenGL ES 3.x概述\n\nOpenGL ES 是基于 OpenGL 三维图形 API 的子集，主要是针对手机以及 PDA（掌上电脑）等嵌入式设备设计的。 OpenGL ES 的 API 由 Khronos 组织定义并推广， Khronos 是一个图形软硬件行业协会，该协会致力于为这些 API 建立免费的开发标准。\n\n## 1、 OpenGL ES3.x简介 \n\nOpenGL 的应用领域较为广泛，适用于 UNIX、 Mac OS、 Linux 以及 Windows 等几乎所有的操作系统，可以开发游戏、工业建模以及嵌入式设备应用。\n\nOpenGL ES 是专门针对嵌入式设备而设计的，其实际是 OpenGL 的剪裁版本，去除了OpenGL 中许多不是必须存在的特性，如 GL_QUADS（四边形）与 GL_POLYGONS（多边形）绘制模式以及 glBegin（开始） /glEnd（结束）操作等。\n\n##  2.OpenGL与OpenGL-ES的主要区别：\n\n<!--more--> \n\n之所以会推出OpenGL-ES版本，主要是应对嵌入式环境和应用的要求。\n\n早先定义OpenGL ES是OpenGL的嵌入式设备版本，但由于嵌入式设备要求的是高性能，所以一些其它纯追求高性能的设备也开始用这种API方式，比如 SONY PlayStation 3。  \n\n OpenGL ES相对OpenGL删减了一切低效能的操作方式，有高性能的决不留低效能的，即只求效能不求兼容性。\n\n嵌入式设备一般工作于较恶劣的环境，包括：温度、湿度、振动、冲击、酸碱腐蚀等。例如：中国的酸雨气候就给很多室外电子设备带来了新的难题，中东地区的风沙也使得美军必须采用更先进的非IT技术来保护他们的电子设备。 \n\n需要人机界面的嵌入式应用，由于受环境受环境因素的影响，一般不能提供有缘电源，在有限的电能限制下工作，如何以更低的功耗完成人机交互界面，成为OpenGL必须要面对的问题，进而推出了OpenGL-ES标准。应该说在高效完成2D/3D界面的同时，达到了降低功耗的效果。 \n\n##  3.OpenGL ES 1.0、2.0、3.0的区别 \n\n### OpenGL ES1.0：\n\n 针对固定管线硬件(fixed pipeline)，通过它内建的functions来设置诸如灯光、vertexes（图形的顶点数）、颜色、camera等等的东西。\n\n### OpenGL ES2.0：\n\n 针对可编程管线硬件(programmable pipeline)，需要自己动手编写任何功能。与此同时，2.0相比于1.0更具灵活性，功能也更强大。可以自定义顶点和像素计算，可以让表现方式更加准确。\n\n### OpenGL ES3.0：\n\n OpenGL ES3.0扩展了OpenGL ES2.0，支持许多新的渲染技术、优化和显示质量改进，包括——引入了许多和纹理相关的新功能，对着色语言进行了重大更新和支持着色器新功能的API特性，引入了多种与几何形状规范和图元渲染控制相关的新功能，引入了新的缓冲区对象，增添了许多与屏幕外渲染到帧缓冲区对象相关的新功能。具体功能在后边的文章详细说明。（可能:））\n\n###  OpenGL ES 3.0的向后兼容新 \n\nOpenGL ES 3.0向后兼容OpenGL ES 2.0，但由于3.0/2.0不支持1.x支持的固定功能管线，3.0/2.0不能向后兼容1.x。\n\n## 4.EGL/EAGL \n\nEGL API 参考页面:https://www.khronos.org/registry/EGL/sdk/docs/man/)\n\n### 4.1作用\n\n EGL就是Embedded Graphics Library。嵌入式图形框架。 EGL是Khronos渲染API（如OpenGL ES）和原生窗口系统之间的接口（在iOS上则是EAGL）\n\n### 4.2原因\n\nOpenGL-ES 命令需要存储渲染上下文的状态和绘制表面的支持才能完成图形图像的绘制. \n\n- 渲染上下文：存储相关的OpenGL-ES 状态\n- 绘制表面：是用于绘制图元的表面，它指定渲染所需的缓冲区类型，比如颜色缓冲区，深度缓冲区和模板缓冲区，绘制表面还需要指定所需缓冲区的位深度\n\n因为OpenGL-ES API没有提及如何常见渲染上下文，或者渲染上下文如何连接到原生窗口系统，EGL就是 khronos 提出的OpenGL-ES 和原生窗口系统之间的接口；（ 唯⼀⽀持OpenGL ES 却不⽀持EGL 的平台是iOS。Apple 提供⾃⼰的EGL API的iOS实现,称为EAGL。 ）\n\n###  4.3EGL的功能如下：\n\n- 查询并初始化设备显示商的可用显示设备\n- 创建渲染表面\n   EGL创建的表面可用分为屏幕上的表面和屏幕外的表面，屏幕上的表面连接到原生窗口系统，屏幕外的表面不显示但是用作渲染表面的像素缓冲区\n- 创建渲染上下文\n   EGL 的最新版本时 EGL v1.4\n\n### 4.4使用流程\n\n任何OpenGL ES应用程序都必须在开始渲染之前使用EGL执行如下任务：\n\n<img src=\"9.jpg\" style=\"zoom: 80%;\" />\n\n\n\n\n\n## 5.OpenGL ES 3.0图形管线的各个阶段 \n\n![](8.png)\n\n![](10.jpg)\n\n### 5.1顶点着色器\n\n顶点和顶点着色器(Vertex & Vertex shader)，shader 是指运行在GPU可编程管线上的程序，也就是GPU所用的编程语言，本质是一种类C语言。\n Vertex shader 的内容包含：\n\n- shader程序： 用来描述顶点上执⾏操作的顶点着⾊器程序源代码/可执⾏⽂件 \n\n- shader 的输入属性，就是顶点数组提供的各个顶点的属性\n\n- uniform(统一变量)  Vertex/Pixel shader 使用的不变的变量，如：颜色数据\n\n- 采样器， 代表顶点着⾊器使⽤纹理的特殊统⼀变量类型。 \n\n  ![](11.jpg)\n\n 如图所示，可以由很多属性输入到顶点着色器，最后顶点着色器也会输出属性数据，其中gl_Position和gl_PointSize是OpenGL的内建变量。\n\n在图元光栅化阶段，为每个生成的片段计算 vertex shader 的输出值，并作为输入值传递给pixel shader,\n **用于分配给每个图元顶点的Vertex shader输出每个片段值的机制被称为插值** \n\n### 5.2图元装配\n\n图元(Primitive):  基本的图形对象 。如：点，线，三⻆形等。\n\n图元装配: 将顶点数据计算成⼀个个图元.在这个阶段会执⾏裁剪、透视分割和Viewport变换操作。\n\n  对于每个单独图元及其对应的顶点， 图元装配阶段执⾏的操作包括：将顶点着⾊器的输出值执⾏裁剪、透视分割、视⼝变换后进⼊光栅化阶段 \n\n### 5.3光栅化\n\n 光栅化是将**图元转换为一组二维片段的过程**，此后这些片段就会交给Pixel shader 处理，这些二维片段就是屏幕上可以绘制的像素。 \n\n![](12.jpg)\n\n### 5.4 **⽚元着⾊器/⽚段着⾊器** \n\n片段着色器（Pixel shader/Fragment shader）为片段操作实现了通用的可编程方法，它的组成如下：\n\n- Shader 程序-- 描述⽚段上执⾏操作的⽚元着⾊器程序源代码/可执⾏⽂件 \n\n- 输入变量--光栅化阶段用插值为每个片段生成的 Vertex shader 输出\n\n- 输出变量-- 统⼀变量(uniform)--顶点/⽚元着⾊器使⽤的不变数据 \n\n- 采样器--代表⽚元着⾊器使⽤纹理的特殊统⼀变量类型 \n\n  ![](13.jpg)\n\n### 5.5逐片段操作\n\n![](14.webp)\n\n- 像素归属测试: 确定帧缓存区中位置(Xw,Yw)的像素⽬前是不是归属于OpenGL ES所有. 例如,如果⼀个显示OpenGL ES帧缓存区View被另外⼀个View 所遮蔽.则窗⼝系统可以确定被遮蔽的像素不属于OpenGL ES 上下⽂.从⽽不全显示这些像素. ⽽像素归属测试是OpenGL ES 的⼀部分,它不由开发者开⼈为控制,⽽是由OpenGL ES 内部进⾏。\n- 裁剪测试: 裁剪测试确定(Xw,Yw)是否位于作为OpenGL ES状态的⼀部分裁剪矩形范围内.如果该⽚段位于裁剪区域之外,则被抛弃。\n- 深度测试: 输⼊⽚段的深度值进步⽐较,确定⽚段是否拒绝测试。\n- 混合: 混合将新⽣成的⽚段颜⾊与保存在帧缓存的位置的颜⾊值组合起来。\n- 抖动: 抖动可⽤于最⼩化因为使⽤有限精度在帧缓存区中保存颜⾊值⽽产⽣的伪像。\n\n# 二、环境搭建\n\n# 三、第一个OpenGL ES 3.0程序\n\n```c\n#include \"esUtil.h\"\n\ntypedef struct\n{\n   // Handle to a program object\n   GLuint programObject;\n\n} UserData;\n\n///\n// Create a shader object, load the shader source, and\n// compile the shader.\n//\nGLuint LoadShader ( GLenum type, const char *shaderSrc )\n{\n   GLuint shader;\n   GLint compiled;\n\n   // Create the shader object,创建指定类型的新着色器对象\n   shader = glCreateShader ( type );\n\n   if ( shader == 0 )\n   {\n      return 0;\n   }\n\n   // Load the shader source着色器源代码本身用glShaderSource加载到着色器对象\n   glShaderSource ( shader, 1, &shaderSrc, NULL );\n\n   // Compile the shader着色器用glCompileShader函数编译\n   glCompileShader ( shader );\n\n   // Check the compile status确定编译的状态，打印输出生成的错误\n   glGetShaderiv ( shader, GL_COMPILE_STATUS, &compiled );\n\n   if ( !compiled )\n   {\n      GLint infoLen = 0;\n\n      glGetShaderiv ( shader, GL_INFO_LOG_LENGTH, &infoLen );\n\n      if ( infoLen > 1 )\n      {\n         char *infoLog = malloc ( sizeof ( char ) * infoLen );\n\n         glGetShaderInfoLog ( shader, infoLen, NULL, infoLog );\n         esLogMessage ( \"Error compiling shader:\\n%s\\n\", infoLog );\n\n         free ( infoLog );\n      }\n\n      glDeleteShader ( shader );\n      return 0;\n   }\n\n   return shader;//着色器编译成功，则返回一个新的着色器对象。\n\n}\n\n///\n// Initialize the shader and program object\n//\nint Init ( ESContext *esContext )\n{\n   UserData *userData = esContext->userData;\n    //顶点着色器\n   char vShaderStr[] =\n      \"#version 300 es                          \\n\"\n      \"layout(location = 0) in vec4 vPosition;  \\n\"\n      \"void main()                              \\n\"\n      \"{                                        \\n\"\n      \"   gl_Position = vPosition;              \\n\"\n      \"}                                        \\n\";\n\t/*1.声明着色器版本；\n\t2.声明一个名为vPosition的4分量向量输入属性，layout（location=0）限定符表示这个变量的位置是顶点属性0；\n\t3.声明一个main函数，表示着色器执行的开始，{}中是着色器主体，将vPosition输入属性拷贝到名为gl_Position的特殊输出变量。每个顶点着色器必须在gl_Position变量中输出一个位置，这个变量定义传递到管线下一个阶段的位置。*/\n    //片断着色器\n   char fShaderStr[] =\n      \"#version 300 es                              \\n\"\n      \"precision mediump float;                     \\n\"\n      \"out vec4 fragColor;                          \\n\"\n      \"void main()                                  \\n\"\n      \"{                                            \\n\"\n      \"   fragColor = vec4 ( 1.0, 0.0, 0.0, 1.0 );  \\n\"\n      \"}                                            \\n\";\n\n   GLuint vertexShader;\n   GLuint fragmentShader;\n   GLuint programObject;\n   GLint linked;\n\n   // Load the vertex/fragment shaders.编译和加载着色器\n   vertexShader = LoadShader ( GL_VERTEX_SHADER, vShaderStr );\n   fragmentShader = LoadShader ( GL_FRAGMENT_SHADER, fShaderStr );\n\n   // Create the program object创建一个程序对象\n   programObject = glCreateProgram ( );\n\n   if ( programObject == 0 )\n   {\n      return 0;\n   }\n\t//用glAttachShader将顶点着色器和片断着色器连接到对象上。\n   glAttachShader ( programObject, vertexShader );\n   glAttachShader ( programObject, fragmentShader );\n\n   // Link the program连接程序\n   glLinkProgram ( programObject );\n\n   // Check the link status检查错误\n   glGetProgramiv ( programObject, GL_LINK_STATUS, &linked );\n\n   if ( !linked )\n   {\n      GLint infoLen = 0;\n\n      glGetProgramiv ( programObject, GL_INFO_LOG_LENGTH, &infoLen );\n\n      if ( infoLen > 1 )\n      {\n         char *infoLog = malloc ( sizeof ( char ) * infoLen );\n\n         glGetProgramInfoLog ( programObject, infoLen, NULL, infoLog );\n         esLogMessage ( \"Error linking program:\\n%s\\n\", infoLog );\n\n         free ( infoLog );\n      }\n\n      glDeleteProgram ( programObject );\n      return FALSE;\n   }\n\n   // Store the program object.保存程序对象。对象连接成功后，可以使用程序对象进行渲染，可以调用glUseProgram ( userData->programObject )来使用程序对象\n   userData->programObject = programObject;\n\n   glClearColor ( 1.0f, 1.0f, 1.0f, 0.0f );\n   return TRUE;\n}\n\n///\n// Draw a triangle using the shader pair created in Init()\n//Draw回调函数用于绘制帧\nvoid Draw ( ESContext *esContext )\n{\n   UserData *userData = esContext->userData;\n   GLfloat vVertices[] = {  0.0f,  0.5f, 0.3f,\n                            -0.5f, -0.5f, 0.5f,\n                            0.5f, -0.5f, -0.4f\n                         };\n\n   // Set the viewport设置视口的原点和宽高\n   glViewport ( 0, 0, esContext->width, esContext->height );\n\n   // Clear the color buffer清除缓冲区，清除颜色为glClearColor指定的颜色\n   glClear ( GL_COLOR_BUFFER_BIT );\n\n   // Use the program object对象连接成功后，可以使用程序对象进行渲染\n   glUseProgram ( userData->programObject );\n\n   // Load the vertex data加载几何形状和绘制图元\n    //三角形的顶点由vVertices数组中的三个坐标（x， y， z）指定。顶点位置使用glVertexAttribPointer加载到GL，并连接到顶点着色器生命的vPosition属性\n   glVertexAttribPointer ( 0, 3, GL_FLOAT, GL_FALSE, 0, vVertices );\n   glEnableVertexAttribArray ( 0 );\n\n   glDrawArrays ( GL_TRIANGLES, 0, 3 );//告诉OpenGL ES绘制图元\n}\n\nvoid Shutdown ( ESContext *esContext )\n{\n   UserData *userData = esContext->userData;\n\n   glDeleteProgram ( userData->programObject );\n}\n//应用程序的主入口。ESContext有一个名为userData、类型为void的成员变量，应用程序所需的所有数据保存在userData中\nint esMain ( ESContext *esContext )\n{\n   esContext->userData = malloc ( sizeof ( UserData ) );//分配userData\n\n   esCreateWindow ( esContext, \"Hello Triangle\", 375, 667, ES_WINDOW_RGB );//创建了窗口并初始化绘图回调函数\n\t//创建顶点着色器和片断着色器,OpenGL ES 3.0程序必须至少有一个顶点着色器和一个片断着色器。\n   if ( !Init ( esContext ) )\n   {\n      return GL_FALSE;\n   }\n\n   esRegisterShutdownFunc ( esContext, Shutdown );\n   esRegisterDrawFunc ( esContext, Draw );\n\n   return GL_TRUE;\n}\n```\n\n代码分析参见： [OpenGL ES 3.0 入门 - 简书 (jianshu.com)](https://www.jianshu.com/p/2ce67644eae8) \n\n## 代码流程框架1\n\n<img src=\"16.jpg\" style=\"zoom:80%;\" />\n\n## 代码流程框架2\n\n![](19.jpg)\n\n## 代码流程框架3\n\n![](20.jpg)\n\n# 四、OpenGL-ES 3.0/2.0 API查询网站\n\nOpenGL-ES 3.0 API：https://www.khronos.org/registry/OpenGL-Refpages/es3.0/\n\nOpenGL-ES 2.0 API：https://registry.khronos.org/OpenGL-Refpages/es2.0/\n\n# 五、坐标系的转换\n\n1、OpenGL坐标系\n\n2、纹理坐标系\n\n 2D纹理是一个图像数据的二维数组。一个纹理单独数据元素称作“纹素”(Texel)。图像中的每个纹素根据基本格式和数据类型指定。如果用2D纹理渲染时，纹理坐标用作图像中的索引。2D纹理的纹理坐标用一对2D坐标(s,t)或者(u,v)来表示，这些坐标用于查找一个纹理贴图的规范化坐标。 \n\n![](18.webp)\n\n 纹理图像的左下坐标由(0.0,0.0)决定，右上角坐标由(1.0,1.0)指定。在[0.0,1.0]之外的坐标是允许的，在区间之外的纹理读取行为由纹理包装模式决定。 \n\n3、屏幕坐标系\n\n![](17坐标系.png)\n\n裁剪： 限制纹理坐标的取值范围来实现裁剪的效果 \n\n\n\n# 六、纹理对象的创建与加载\n\n## 1.本地资源\n\nOpenCv读取，然后绑定纹理\n\n```cpp\nstatic int LoadTextures(void)\n{\n    string name;\n    cv::Mat image;\n\tGLuint LoadingTexture；\n        \n    name = string(\"../\" + \"resource/Loadingpicture-\" + to_string(1) + \".png\";//读取UI文件资源路径\n    image = cv::imread(name, cv::IMREAD_UNCHANGED);//OpenCv读取文件\n    if(image.data == NULL)\n    {\n        PRINT(\"%s::%d Load Loadingpicture.png Failed \\n\",\t__FILE__,  __LINE__);   \n        return -1;\n    }\n    /* Genarate Texture  */\n    glGenTextures(1, &LoadingTexture);//生成纹理名称\n    glBindTexture(GL_TEXTURE_2D, LoadingTexture);//绑定指定纹理到目标\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,image.cols, image.rows, 0, GL_RGBA, GL_UNSIGNED_BYTE, image.data);//指定2D纹理对象（目标纹理GL_TEXTURE_2D）\n    /* Linear Filtering */\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glBindTexture(GL_TEXTURE_2D, 0);\n    return 1;\n｝\n```\n\n## 2.缓冲区资源\n\n创建EGLImage对象，然后绑定纹理\n\n```\n\n```\n\n","slug":"4-2-OpenGL ES","published":1,"updated":"2023-04-14T13:38:52.972Z","_id":"clggl89av0001y4ob4jhh8njg","layout":"post","photos":[],"link":"","content":"<h1 id=\"一、OpenGL-ES-3-x概述\"><a href=\"#一、OpenGL-ES-3-x概述\" class=\"headerlink\" title=\"一、OpenGL ES 3.x概述\"></a>一、OpenGL ES 3.x概述</h1><p>OpenGL ES 是基于 OpenGL 三维图形 API 的子集，主要是针对手机以及 PDA（掌上电脑）等嵌入式设备设计的。 OpenGL ES 的 API 由 Khronos 组织定义并推广， Khronos 是一个图形软硬件行业协会，该协会致力于为这些 API 建立免费的开发标准。</p>\n<h2 id=\"1、-OpenGL-ES3-x简介\"><a href=\"#1、-OpenGL-ES3-x简介\" class=\"headerlink\" title=\"1、 OpenGL ES3.x简介\"></a>1、 OpenGL ES3.x简介</h2><p>OpenGL 的应用领域较为广泛，适用于 UNIX、 Mac OS、 Linux 以及 Windows 等几乎所有的操作系统，可以开发游戏、工业建模以及嵌入式设备应用。</p>\n<p>OpenGL ES 是专门针对嵌入式设备而设计的，其实际是 OpenGL 的剪裁版本，去除了OpenGL 中许多不是必须存在的特性，如 GL_QUADS（四边形）与 GL_POLYGONS（多边形）绘制模式以及 glBegin（开始） &#x2F;glEnd（结束）操作等。</p>\n<h2 id=\"2-OpenGL与OpenGL-ES的主要区别：\"><a href=\"#2-OpenGL与OpenGL-ES的主要区别：\" class=\"headerlink\" title=\"2.OpenGL与OpenGL-ES的主要区别：\"></a>2.OpenGL与OpenGL-ES的主要区别：</h2><span id=\"more\"></span> \n\n<p>之所以会推出OpenGL-ES版本，主要是应对嵌入式环境和应用的要求。</p>\n<p>早先定义OpenGL ES是OpenGL的嵌入式设备版本，但由于嵌入式设备要求的是高性能，所以一些其它纯追求高性能的设备也开始用这种API方式，比如 SONY PlayStation 3。  </p>\n<p> OpenGL ES相对OpenGL删减了一切低效能的操作方式，有高性能的决不留低效能的，即只求效能不求兼容性。</p>\n<p>嵌入式设备一般工作于较恶劣的环境，包括：温度、湿度、振动、冲击、酸碱腐蚀等。例如：中国的酸雨气候就给很多室外电子设备带来了新的难题，中东地区的风沙也使得美军必须采用更先进的非IT技术来保护他们的电子设备。 </p>\n<p>需要人机界面的嵌入式应用，由于受环境受环境因素的影响，一般不能提供有缘电源，在有限的电能限制下工作，如何以更低的功耗完成人机交互界面，成为OpenGL必须要面对的问题，进而推出了OpenGL-ES标准。应该说在高效完成2D&#x2F;3D界面的同时，达到了降低功耗的效果。 </p>\n<h2 id=\"3-OpenGL-ES-1-0、2-0、3-0的区别\"><a href=\"#3-OpenGL-ES-1-0、2-0、3-0的区别\" class=\"headerlink\" title=\"3.OpenGL ES 1.0、2.0、3.0的区别\"></a>3.OpenGL ES 1.0、2.0、3.0的区别</h2><h3 id=\"OpenGL-ES1-0：\"><a href=\"#OpenGL-ES1-0：\" class=\"headerlink\" title=\"OpenGL ES1.0：\"></a>OpenGL ES1.0：</h3><p> 针对固定管线硬件(fixed pipeline)，通过它内建的functions来设置诸如灯光、vertexes（图形的顶点数）、颜色、camera等等的东西。</p>\n<h3 id=\"OpenGL-ES2-0：\"><a href=\"#OpenGL-ES2-0：\" class=\"headerlink\" title=\"OpenGL ES2.0：\"></a>OpenGL ES2.0：</h3><p> 针对可编程管线硬件(programmable pipeline)，需要自己动手编写任何功能。与此同时，2.0相比于1.0更具灵活性，功能也更强大。可以自定义顶点和像素计算，可以让表现方式更加准确。</p>\n<h3 id=\"OpenGL-ES3-0：\"><a href=\"#OpenGL-ES3-0：\" class=\"headerlink\" title=\"OpenGL ES3.0：\"></a>OpenGL ES3.0：</h3><p> OpenGL ES3.0扩展了OpenGL ES2.0，支持许多新的渲染技术、优化和显示质量改进，包括——引入了许多和纹理相关的新功能，对着色语言进行了重大更新和支持着色器新功能的API特性，引入了多种与几何形状规范和图元渲染控制相关的新功能，引入了新的缓冲区对象，增添了许多与屏幕外渲染到帧缓冲区对象相关的新功能。具体功能在后边的文章详细说明。（可能:））</p>\n<h3 id=\"OpenGL-ES-3-0的向后兼容新\"><a href=\"#OpenGL-ES-3-0的向后兼容新\" class=\"headerlink\" title=\"OpenGL ES 3.0的向后兼容新\"></a>OpenGL ES 3.0的向后兼容新</h3><p>OpenGL ES 3.0向后兼容OpenGL ES 2.0，但由于3.0&#x2F;2.0不支持1.x支持的固定功能管线，3.0&#x2F;2.0不能向后兼容1.x。</p>\n<h2 id=\"4-EGL-x2F-EAGL\"><a href=\"#4-EGL-x2F-EAGL\" class=\"headerlink\" title=\"4.EGL&#x2F;EAGL\"></a>4.EGL&#x2F;EAGL</h2><p>EGL API 参考页面:<a href=\"https://www.khronos.org/registry/EGL/sdk/docs/man/\">https://www.khronos.org/registry/EGL/sdk/docs/man/</a>)</p>\n<h3 id=\"4-1作用\"><a href=\"#4-1作用\" class=\"headerlink\" title=\"4.1作用\"></a>4.1作用</h3><p> EGL就是Embedded Graphics Library。嵌入式图形框架。 EGL是Khronos渲染API（如OpenGL ES）和原生窗口系统之间的接口（在iOS上则是EAGL）</p>\n<h3 id=\"4-2原因\"><a href=\"#4-2原因\" class=\"headerlink\" title=\"4.2原因\"></a>4.2原因</h3><p>OpenGL-ES 命令需要存储渲染上下文的状态和绘制表面的支持才能完成图形图像的绘制. </p>\n<ul>\n<li>渲染上下文：存储相关的OpenGL-ES 状态</li>\n<li>绘制表面：是用于绘制图元的表面，它指定渲染所需的缓冲区类型，比如颜色缓冲区，深度缓冲区和模板缓冲区，绘制表面还需要指定所需缓冲区的位深度</li>\n</ul>\n<p>因为OpenGL-ES API没有提及如何常见渲染上下文，或者渲染上下文如何连接到原生窗口系统，EGL就是 khronos 提出的OpenGL-ES 和原生窗口系统之间的接口；（ 唯⼀⽀持OpenGL ES 却不⽀持EGL 的平台是iOS。Apple 提供⾃⼰的EGL API的iOS实现,称为EAGL。 ）</p>\n<h3 id=\"4-3EGL的功能如下：\"><a href=\"#4-3EGL的功能如下：\" class=\"headerlink\" title=\"4.3EGL的功能如下：\"></a>4.3EGL的功能如下：</h3><ul>\n<li>查询并初始化设备显示商的可用显示设备</li>\n<li>创建渲染表面<br> EGL创建的表面可用分为屏幕上的表面和屏幕外的表面，屏幕上的表面连接到原生窗口系统，屏幕外的表面不显示但是用作渲染表面的像素缓冲区</li>\n<li>创建渲染上下文<br> EGL 的最新版本时 EGL v1.4</li>\n</ul>\n<h3 id=\"4-4使用流程\"><a href=\"#4-4使用流程\" class=\"headerlink\" title=\"4.4使用流程\"></a>4.4使用流程</h3><p>任何OpenGL ES应用程序都必须在开始渲染之前使用EGL执行如下任务：</p>\n<img src=\"9.jpg\" style=\"zoom: 80%;\" />\n\n\n\n\n\n<h2 id=\"5-OpenGL-ES-3-0图形管线的各个阶段\"><a href=\"#5-OpenGL-ES-3-0图形管线的各个阶段\" class=\"headerlink\" title=\"5.OpenGL ES 3.0图形管线的各个阶段\"></a>5.OpenGL ES 3.0图形管线的各个阶段</h2><p><img src=\"/2023/04/14/4-2-OpenGL%20ES/8.png\"></p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/10.jpg\"></p>\n<h3 id=\"5-1顶点着色器\"><a href=\"#5-1顶点着色器\" class=\"headerlink\" title=\"5.1顶点着色器\"></a>5.1顶点着色器</h3><p>顶点和顶点着色器(Vertex &amp; Vertex shader)，shader 是指运行在GPU可编程管线上的程序，也就是GPU所用的编程语言，本质是一种类C语言。<br> Vertex shader 的内容包含：</p>\n<ul>\n<li><p>shader程序： 用来描述顶点上执⾏操作的顶点着⾊器程序源代码&#x2F;可执⾏⽂件 </p>\n</li>\n<li><p>shader 的输入属性，就是顶点数组提供的各个顶点的属性</p>\n</li>\n<li><p>uniform(统一变量)  Vertex&#x2F;Pixel shader 使用的不变的变量，如：颜色数据</p>\n</li>\n<li><p>采样器， 代表顶点着⾊器使⽤纹理的特殊统⼀变量类型。 </p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/11.jpg\"></p>\n</li>\n</ul>\n<p> 如图所示，可以由很多属性输入到顶点着色器，最后顶点着色器也会输出属性数据，其中gl_Position和gl_PointSize是OpenGL的内建变量。</p>\n<p>在图元光栅化阶段，为每个生成的片段计算 vertex shader 的输出值，并作为输入值传递给pixel shader,<br> <strong>用于分配给每个图元顶点的Vertex shader输出每个片段值的机制被称为插值</strong> </p>\n<h3 id=\"5-2图元装配\"><a href=\"#5-2图元装配\" class=\"headerlink\" title=\"5.2图元装配\"></a>5.2图元装配</h3><p>图元(Primitive):  基本的图形对象 。如：点，线，三⻆形等。</p>\n<p>图元装配: 将顶点数据计算成⼀个个图元.在这个阶段会执⾏裁剪、透视分割和Viewport变换操作。</p>\n<p>  对于每个单独图元及其对应的顶点， 图元装配阶段执⾏的操作包括：将顶点着⾊器的输出值执⾏裁剪、透视分割、视⼝变换后进⼊光栅化阶段 </p>\n<h3 id=\"5-3光栅化\"><a href=\"#5-3光栅化\" class=\"headerlink\" title=\"5.3光栅化\"></a>5.3光栅化</h3><p> 光栅化是将<strong>图元转换为一组二维片段的过程</strong>，此后这些片段就会交给Pixel shader 处理，这些二维片段就是屏幕上可以绘制的像素。 </p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/12.jpg\"></p>\n<h3 id=\"5-4-⽚元着⾊器-x2F-⽚段着⾊器\"><a href=\"#5-4-⽚元着⾊器-x2F-⽚段着⾊器\" class=\"headerlink\" title=\"5.4 ⽚元着⾊器&#x2F;⽚段着⾊器\"></a>5.4 <strong>⽚元着⾊器&#x2F;⽚段着⾊器</strong></h3><p>片段着色器（Pixel shader&#x2F;Fragment shader）为片段操作实现了通用的可编程方法，它的组成如下：</p>\n<ul>\n<li><p>Shader 程序– 描述⽚段上执⾏操作的⽚元着⾊器程序源代码&#x2F;可执⾏⽂件 </p>\n</li>\n<li><p>输入变量–光栅化阶段用插值为每个片段生成的 Vertex shader 输出</p>\n</li>\n<li><p>输出变量– 统⼀变量(uniform)–顶点&#x2F;⽚元着⾊器使⽤的不变数据 </p>\n</li>\n<li><p>采样器–代表⽚元着⾊器使⽤纹理的特殊统⼀变量类型 </p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/13.jpg\"></p>\n</li>\n</ul>\n<h3 id=\"5-5逐片段操作\"><a href=\"#5-5逐片段操作\" class=\"headerlink\" title=\"5.5逐片段操作\"></a>5.5逐片段操作</h3><p><img src=\"/2023/04/14/4-2-OpenGL%20ES/14.webp\"></p>\n<ul>\n<li>像素归属测试: 确定帧缓存区中位置(Xw,Yw)的像素⽬前是不是归属于OpenGL ES所有. 例如,如果⼀个显示OpenGL ES帧缓存区View被另外⼀个View 所遮蔽.则窗⼝系统可以确定被遮蔽的像素不属于OpenGL ES 上下⽂.从⽽不全显示这些像素. ⽽像素归属测试是OpenGL ES 的⼀部分,它不由开发者开⼈为控制,⽽是由OpenGL ES 内部进⾏。</li>\n<li>裁剪测试: 裁剪测试确定(Xw,Yw)是否位于作为OpenGL ES状态的⼀部分裁剪矩形范围内.如果该⽚段位于裁剪区域之外,则被抛弃。</li>\n<li>深度测试: 输⼊⽚段的深度值进步⽐较,确定⽚段是否拒绝测试。</li>\n<li>混合: 混合将新⽣成的⽚段颜⾊与保存在帧缓存的位置的颜⾊值组合起来。</li>\n<li>抖动: 抖动可⽤于最⼩化因为使⽤有限精度在帧缓存区中保存颜⾊值⽽产⽣的伪像。</li>\n</ul>\n<h1 id=\"二、环境搭建\"><a href=\"#二、环境搭建\" class=\"headerlink\" title=\"二、环境搭建\"></a>二、环境搭建</h1><h1 id=\"三、第一个OpenGL-ES-3-0程序\"><a href=\"#三、第一个OpenGL-ES-3-0程序\" class=\"headerlink\" title=\"三、第一个OpenGL ES 3.0程序\"></a>三、第一个OpenGL ES 3.0程序</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esUtil.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// Handle to a program object</span></span><br><span class=\"line\">   GLuint programObject;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; UserData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// Create a shader object, load the shader source, and</span></span><br><span class=\"line\"><span class=\"comment\">// compile the shader.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">GLuint <span class=\"title function_\">LoadShader</span> <span class=\"params\">( GLenum type, <span class=\"type\">const</span> <span class=\"type\">char</span> *shaderSrc )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   GLuint shader;</span><br><span class=\"line\">   GLint compiled;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Create the shader object,创建指定类型的新着色器对象</span></span><br><span class=\"line\">   shader = glCreateShader ( type );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( shader == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Load the shader source着色器源代码本身用glShaderSource加载到着色器对象</span></span><br><span class=\"line\">   glShaderSource ( shader, <span class=\"number\">1</span>, &amp;shaderSrc, <span class=\"literal\">NULL</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Compile the shader着色器用glCompileShader函数编译</span></span><br><span class=\"line\">   glCompileShader ( shader );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Check the compile status确定编译的状态，打印输出生成的错误</span></span><br><span class=\"line\">   glGetShaderiv ( shader, GL_COMPILE_STATUS, &amp;compiled );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( !compiled )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      GLint infoLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      glGetShaderiv ( shader, GL_INFO_LOG_LENGTH, &amp;infoLen );</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( infoLen &gt; <span class=\"number\">1</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"type\">char</span> *infoLog = <span class=\"built_in\">malloc</span> ( <span class=\"keyword\">sizeof</span> ( <span class=\"type\">char</span> ) * infoLen );</span><br><span class=\"line\"></span><br><span class=\"line\">         glGetShaderInfoLog ( shader, infoLen, <span class=\"literal\">NULL</span>, infoLog );</span><br><span class=\"line\">         esLogMessage ( <span class=\"string\">&quot;Error compiling shader:\\n%s\\n&quot;</span>, infoLog );</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"built_in\">free</span> ( infoLog );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      glDeleteShader ( shader );</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> shader;<span class=\"comment\">//着色器编译成功，则返回一个新的着色器对象。</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// Initialize the shader and program object</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Init</span> <span class=\"params\">( ESContext *esContext )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   UserData *userData = esContext-&gt;userData;</span><br><span class=\"line\">    <span class=\"comment\">//顶点着色器</span></span><br><span class=\"line\">   <span class=\"type\">char</span> vShaderStr[] =</span><br><span class=\"line\">      <span class=\"string\">&quot;#version 300 es                          \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;layout(location = 0) in vec4 vPosition;  \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;void main()                              \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;&#123;                                        \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;   gl_Position = vPosition;              \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;&#125;                                        \\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/*1.声明着色器版本；</span></span><br><span class=\"line\"><span class=\"comment\">\t2.声明一个名为vPosition的4分量向量输入属性，layout（location=0）限定符表示这个变量的位置是顶点属性0；</span></span><br><span class=\"line\"><span class=\"comment\">\t3.声明一个main函数，表示着色器执行的开始，&#123;&#125;中是着色器主体，将vPosition输入属性拷贝到名为gl_Position的特殊输出变量。每个顶点着色器必须在gl_Position变量中输出一个位置，这个变量定义传递到管线下一个阶段的位置。*/</span></span><br><span class=\"line\">    <span class=\"comment\">//片断着色器</span></span><br><span class=\"line\">   <span class=\"type\">char</span> fShaderStr[] =</span><br><span class=\"line\">      <span class=\"string\">&quot;#version 300 es                              \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;precision mediump float;                     \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;out vec4 fragColor;                          \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;void main()                                  \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;&#123;                                            \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;   fragColor = vec4 ( 1.0, 0.0, 0.0, 1.0 );  \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;&#125;                                            \\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   GLuint vertexShader;</span><br><span class=\"line\">   GLuint fragmentShader;</span><br><span class=\"line\">   GLuint programObject;</span><br><span class=\"line\">   GLint linked;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Load the vertex/fragment shaders.编译和加载着色器</span></span><br><span class=\"line\">   vertexShader = LoadShader ( GL_VERTEX_SHADER, vShaderStr );</span><br><span class=\"line\">   fragmentShader = LoadShader ( GL_FRAGMENT_SHADER, fShaderStr );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Create the program object创建一个程序对象</span></span><br><span class=\"line\">   programObject = glCreateProgram ( );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( programObject == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//用glAttachShader将顶点着色器和片断着色器连接到对象上。</span></span><br><span class=\"line\">   glAttachShader ( programObject, vertexShader );</span><br><span class=\"line\">   glAttachShader ( programObject, fragmentShader );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Link the program连接程序</span></span><br><span class=\"line\">   glLinkProgram ( programObject );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Check the link status检查错误</span></span><br><span class=\"line\">   glGetProgramiv ( programObject, GL_LINK_STATUS, &amp;linked );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( !linked )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      GLint infoLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      glGetProgramiv ( programObject, GL_INFO_LOG_LENGTH, &amp;infoLen );</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( infoLen &gt; <span class=\"number\">1</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"type\">char</span> *infoLog = <span class=\"built_in\">malloc</span> ( <span class=\"keyword\">sizeof</span> ( <span class=\"type\">char</span> ) * infoLen );</span><br><span class=\"line\"></span><br><span class=\"line\">         glGetProgramInfoLog ( programObject, infoLen, <span class=\"literal\">NULL</span>, infoLog );</span><br><span class=\"line\">         esLogMessage ( <span class=\"string\">&quot;Error linking program:\\n%s\\n&quot;</span>, infoLog );</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"built_in\">free</span> ( infoLog );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      glDeleteProgram ( programObject );</span><br><span class=\"line\">      <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Store the program object.保存程序对象。对象连接成功后，可以使用程序对象进行渲染，可以调用glUseProgram ( userData-&gt;programObject )来使用程序对象</span></span><br><span class=\"line\">   userData-&gt;programObject = programObject;</span><br><span class=\"line\"></span><br><span class=\"line\">   glClearColor ( <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span> );</span><br><span class=\"line\">   <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// Draw a triangle using the shader pair created in Init()</span></span><br><span class=\"line\"><span class=\"comment\">//Draw回调函数用于绘制帧</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Draw</span> <span class=\"params\">( ESContext *esContext )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   UserData *userData = esContext-&gt;userData;</span><br><span class=\"line\">   GLfloat vVertices[] = &#123;  <span class=\"number\">0.0f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.3f</span>,</span><br><span class=\"line\">                            <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">                            <span class=\"number\">0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.4f</span></span><br><span class=\"line\">                         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Set the viewport设置视口的原点和宽高</span></span><br><span class=\"line\">   glViewport ( <span class=\"number\">0</span>, <span class=\"number\">0</span>, esContext-&gt;width, esContext-&gt;height );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Clear the color buffer清除缓冲区，清除颜色为glClearColor指定的颜色</span></span><br><span class=\"line\">   glClear ( GL_COLOR_BUFFER_BIT );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Use the program object对象连接成功后，可以使用程序对象进行渲染</span></span><br><span class=\"line\">   glUseProgram ( userData-&gt;programObject );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Load the vertex data加载几何形状和绘制图元</span></span><br><span class=\"line\">    <span class=\"comment\">//三角形的顶点由vVertices数组中的三个坐标（x， y， z）指定。顶点位置使用glVertexAttribPointer加载到GL，并连接到顶点着色器生命的vPosition属性</span></span><br><span class=\"line\">   glVertexAttribPointer ( <span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vVertices );</span><br><span class=\"line\">   glEnableVertexAttribArray ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">   glDrawArrays ( GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span> );<span class=\"comment\">//告诉OpenGL ES绘制图元</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Shutdown</span> <span class=\"params\">( ESContext *esContext )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   UserData *userData = esContext-&gt;userData;</span><br><span class=\"line\"></span><br><span class=\"line\">   glDeleteProgram ( userData-&gt;programObject );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//应用程序的主入口。ESContext有一个名为userData、类型为void的成员变量，应用程序所需的所有数据保存在userData中</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">esMain</span> <span class=\"params\">( ESContext *esContext )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   esContext-&gt;userData = <span class=\"built_in\">malloc</span> ( <span class=\"keyword\">sizeof</span> ( UserData ) );<span class=\"comment\">//分配userData</span></span><br><span class=\"line\"></span><br><span class=\"line\">   esCreateWindow ( esContext, <span class=\"string\">&quot;Hello Triangle&quot;</span>, <span class=\"number\">375</span>, <span class=\"number\">667</span>, ES_WINDOW_RGB );<span class=\"comment\">//创建了窗口并初始化绘图回调函数</span></span><br><span class=\"line\">\t<span class=\"comment\">//创建顶点着色器和片断着色器,OpenGL ES 3.0程序必须至少有一个顶点着色器和一个片断着色器。</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( !Init ( esContext ) )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> GL_FALSE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   esRegisterShutdownFunc ( esContext, Shutdown );</span><br><span class=\"line\">   esRegisterDrawFunc ( esContext, Draw );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> GL_TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码分析参见： <a href=\"https://www.jianshu.com/p/2ce67644eae8\">OpenGL ES 3.0 入门 - 简书 (jianshu.com)</a> </p>\n<h2 id=\"代码流程框架1\"><a href=\"#代码流程框架1\" class=\"headerlink\" title=\"代码流程框架1\"></a>代码流程框架1</h2><img src=\"16.jpg\" style=\"zoom:80%;\" />\n\n<h2 id=\"代码流程框架2\"><a href=\"#代码流程框架2\" class=\"headerlink\" title=\"代码流程框架2\"></a>代码流程框架2</h2><p><img src=\"/2023/04/14/4-2-OpenGL%20ES/19.jpg\"></p>\n<h2 id=\"代码流程框架3\"><a href=\"#代码流程框架3\" class=\"headerlink\" title=\"代码流程框架3\"></a>代码流程框架3</h2><p><img src=\"/2023/04/14/4-2-OpenGL%20ES/20.jpg\"></p>\n<h1 id=\"四、OpenGL-ES-3-0-x2F-2-0-API查询网站\"><a href=\"#四、OpenGL-ES-3-0-x2F-2-0-API查询网站\" class=\"headerlink\" title=\"四、OpenGL-ES 3.0&#x2F;2.0 API查询网站\"></a>四、OpenGL-ES 3.0&#x2F;2.0 API查询网站</h1><p>OpenGL-ES 3.0 API：<a href=\"https://www.khronos.org/registry/OpenGL-Refpages/es3.0/\">https://www.khronos.org/registry/OpenGL-Refpages/es3.0/</a></p>\n<p>OpenGL-ES 2.0 API：<a href=\"https://registry.khronos.org/OpenGL-Refpages/es2.0/\">https://registry.khronos.org/OpenGL-Refpages/es2.0/</a></p>\n<h1 id=\"五、坐标系的转换\"><a href=\"#五、坐标系的转换\" class=\"headerlink\" title=\"五、坐标系的转换\"></a>五、坐标系的转换</h1><p>1、OpenGL坐标系</p>\n<p>2、纹理坐标系</p>\n<p> 2D纹理是一个图像数据的二维数组。一个纹理单独数据元素称作“纹素”(Texel)。图像中的每个纹素根据基本格式和数据类型指定。如果用2D纹理渲染时，纹理坐标用作图像中的索引。2D纹理的纹理坐标用一对2D坐标(s,t)或者(u,v)来表示，这些坐标用于查找一个纹理贴图的规范化坐标。 </p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/18.webp\"></p>\n<p> 纹理图像的左下坐标由(0.0,0.0)决定，右上角坐标由(1.0,1.0)指定。在[0.0,1.0]之外的坐标是允许的，在区间之外的纹理读取行为由纹理包装模式决定。 </p>\n<p>3、屏幕坐标系</p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/17%E5%9D%90%E6%A0%87%E7%B3%BB.png\"></p>\n<p>裁剪： 限制纹理坐标的取值范围来实现裁剪的效果 </p>\n<h1 id=\"六、纹理对象的创建与加载\"><a href=\"#六、纹理对象的创建与加载\" class=\"headerlink\" title=\"六、纹理对象的创建与加载\"></a>六、纹理对象的创建与加载</h1><h2 id=\"1-本地资源\"><a href=\"#1-本地资源\" class=\"headerlink\" title=\"1.本地资源\"></a>1.本地资源</h2><p>OpenCv读取，然后绑定纹理</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">LoadTextures</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    cv::Mat image;</span><br><span class=\"line\">\tGLuint LoadingTexture；</span><br><span class=\"line\">        </span><br><span class=\"line\">    name = <span class=\"built_in\">string</span>(<span class=\"string\">&quot;../&quot;</span> + <span class=\"string\">&quot;resource/Loadingpicture-&quot;</span> + <span class=\"built_in\">to_string</span>(<span class=\"number\">1</span>) + <span class=\"string\">&quot;.png&quot;</span>;<span class=\"comment\">//读取UI文件资源路径</span></span><br><span class=\"line\">    image = cv::<span class=\"built_in\">imread</span>(name, cv::IMREAD_UNCHANGED);<span class=\"comment\">//OpenCv读取文件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(image.data == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">PRINT</span>(<span class=\"string\">&quot;%s::%d Load Loadingpicture.png Failed \\n&quot;</span>,\t__FILE__,  __LINE__);   </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* Genarate Texture  */</span></span><br><span class=\"line\">    <span class=\"built_in\">glGenTextures</span>(<span class=\"number\">1</span>, &amp;LoadingTexture);<span class=\"comment\">//生成纹理名称</span></span><br><span class=\"line\">    <span class=\"built_in\">glBindTexture</span>(GL_TEXTURE_2D, LoadingTexture);<span class=\"comment\">//绑定指定纹理到目标</span></span><br><span class=\"line\">    <span class=\"built_in\">glTexImage2D</span>(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA,image.cols, image.rows, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, image.data);<span class=\"comment\">//指定2D纹理对象（目标纹理GL_TEXTURE_2D）</span></span><br><span class=\"line\">    <span class=\"comment\">/* Linear Filtering */</span></span><br><span class=\"line\">    <span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    <span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    <span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class=\"line\">    <span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class=\"line\">    <span class=\"built_in\">glBindTexture</span>(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-缓冲区资源\"><a href=\"#2-缓冲区资源\" class=\"headerlink\" title=\"2.缓冲区资源\"></a>2.缓冲区资源</h2><p>创建EGLImage对象，然后绑定纹理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"style":""}},"length":9311,"excerpt":"<h1 id=\"一、OpenGL-ES-3-x概述\"><a href=\"#一、OpenGL-ES-3-x概述\" class=\"headerlink\" title=\"一、OpenGL ES 3.x概述\"></a>一、OpenGL ES 3.x概述</h1><p>OpenGL ES 是基于 OpenGL 三维图形 API 的子集，主要是针对手机以及 PDA（掌上电脑）等嵌入式设备设计的。 OpenGL ES 的 API 由 Khronos 组织定义并推广， Khronos 是一个图形软硬件行业协会，该协会致力于为这些 API 建立免费的开发标准。</p>\n<h2 id=\"1、-OpenGL-ES3-x简介\"><a href=\"#1、-OpenGL-ES3-x简介\" class=\"headerlink\" title=\"1、 OpenGL ES3.x简介\"></a>1、 OpenGL ES3.x简介</h2><p>OpenGL 的应用领域较为广泛，适用于 UNIX、 Mac OS、 Linux 以及 Windows 等几乎所有的操作系统，可以开发游戏、工业建模以及嵌入式设备应用。</p>\n<p>OpenGL ES 是专门针对嵌入式设备而设计的，其实际是 OpenGL 的剪裁版本，去除了OpenGL 中许多不是必须存在的特性，如 GL_QUADS（四边形）与 GL_POLYGONS（多边形）绘制模式以及 glBegin（开始） &#x2F;glEnd（结束）操作等。</p>\n<h2 id=\"2-OpenGL与OpenGL-ES的主要区别：\"><a href=\"#2-OpenGL与OpenGL-ES的主要区别：\" class=\"headerlink\" title=\"2.OpenGL与OpenGL-ES的主要区别：\"></a>2.OpenGL与OpenGL-ES的主要区别：</h2>","more":"<p>之所以会推出OpenGL-ES版本，主要是应对嵌入式环境和应用的要求。</p>\n<p>早先定义OpenGL ES是OpenGL的嵌入式设备版本，但由于嵌入式设备要求的是高性能，所以一些其它纯追求高性能的设备也开始用这种API方式，比如 SONY PlayStation 3。  </p>\n<p> OpenGL ES相对OpenGL删减了一切低效能的操作方式，有高性能的决不留低效能的，即只求效能不求兼容性。</p>\n<p>嵌入式设备一般工作于较恶劣的环境，包括：温度、湿度、振动、冲击、酸碱腐蚀等。例如：中国的酸雨气候就给很多室外电子设备带来了新的难题，中东地区的风沙也使得美军必须采用更先进的非IT技术来保护他们的电子设备。 </p>\n<p>需要人机界面的嵌入式应用，由于受环境受环境因素的影响，一般不能提供有缘电源，在有限的电能限制下工作，如何以更低的功耗完成人机交互界面，成为OpenGL必须要面对的问题，进而推出了OpenGL-ES标准。应该说在高效完成2D&#x2F;3D界面的同时，达到了降低功耗的效果。 </p>\n<h2 id=\"3-OpenGL-ES-1-0、2-0、3-0的区别\"><a href=\"#3-OpenGL-ES-1-0、2-0、3-0的区别\" class=\"headerlink\" title=\"3.OpenGL ES 1.0、2.0、3.0的区别\"></a>3.OpenGL ES 1.0、2.0、3.0的区别</h2><h3 id=\"OpenGL-ES1-0：\"><a href=\"#OpenGL-ES1-0：\" class=\"headerlink\" title=\"OpenGL ES1.0：\"></a>OpenGL ES1.0：</h3><p> 针对固定管线硬件(fixed pipeline)，通过它内建的functions来设置诸如灯光、vertexes（图形的顶点数）、颜色、camera等等的东西。</p>\n<h3 id=\"OpenGL-ES2-0：\"><a href=\"#OpenGL-ES2-0：\" class=\"headerlink\" title=\"OpenGL ES2.0：\"></a>OpenGL ES2.0：</h3><p> 针对可编程管线硬件(programmable pipeline)，需要自己动手编写任何功能。与此同时，2.0相比于1.0更具灵活性，功能也更强大。可以自定义顶点和像素计算，可以让表现方式更加准确。</p>\n<h3 id=\"OpenGL-ES3-0：\"><a href=\"#OpenGL-ES3-0：\" class=\"headerlink\" title=\"OpenGL ES3.0：\"></a>OpenGL ES3.0：</h3><p> OpenGL ES3.0扩展了OpenGL ES2.0，支持许多新的渲染技术、优化和显示质量改进，包括——引入了许多和纹理相关的新功能，对着色语言进行了重大更新和支持着色器新功能的API特性，引入了多种与几何形状规范和图元渲染控制相关的新功能，引入了新的缓冲区对象，增添了许多与屏幕外渲染到帧缓冲区对象相关的新功能。具体功能在后边的文章详细说明。（可能:））</p>\n<h3 id=\"OpenGL-ES-3-0的向后兼容新\"><a href=\"#OpenGL-ES-3-0的向后兼容新\" class=\"headerlink\" title=\"OpenGL ES 3.0的向后兼容新\"></a>OpenGL ES 3.0的向后兼容新</h3><p>OpenGL ES 3.0向后兼容OpenGL ES 2.0，但由于3.0&#x2F;2.0不支持1.x支持的固定功能管线，3.0&#x2F;2.0不能向后兼容1.x。</p>\n<h2 id=\"4-EGL-x2F-EAGL\"><a href=\"#4-EGL-x2F-EAGL\" class=\"headerlink\" title=\"4.EGL&#x2F;EAGL\"></a>4.EGL&#x2F;EAGL</h2><p>EGL API 参考页面:<a href=\"https://www.khronos.org/registry/EGL/sdk/docs/man/\">https://www.khronos.org/registry/EGL/sdk/docs/man/</a>)</p>\n<h3 id=\"4-1作用\"><a href=\"#4-1作用\" class=\"headerlink\" title=\"4.1作用\"></a>4.1作用</h3><p> EGL就是Embedded Graphics Library。嵌入式图形框架。 EGL是Khronos渲染API（如OpenGL ES）和原生窗口系统之间的接口（在iOS上则是EAGL）</p>\n<h3 id=\"4-2原因\"><a href=\"#4-2原因\" class=\"headerlink\" title=\"4.2原因\"></a>4.2原因</h3><p>OpenGL-ES 命令需要存储渲染上下文的状态和绘制表面的支持才能完成图形图像的绘制. </p>\n<ul>\n<li>渲染上下文：存储相关的OpenGL-ES 状态</li>\n<li>绘制表面：是用于绘制图元的表面，它指定渲染所需的缓冲区类型，比如颜色缓冲区，深度缓冲区和模板缓冲区，绘制表面还需要指定所需缓冲区的位深度</li>\n</ul>\n<p>因为OpenGL-ES API没有提及如何常见渲染上下文，或者渲染上下文如何连接到原生窗口系统，EGL就是 khronos 提出的OpenGL-ES 和原生窗口系统之间的接口；（ 唯⼀⽀持OpenGL ES 却不⽀持EGL 的平台是iOS。Apple 提供⾃⼰的EGL API的iOS实现,称为EAGL。 ）</p>\n<h3 id=\"4-3EGL的功能如下：\"><a href=\"#4-3EGL的功能如下：\" class=\"headerlink\" title=\"4.3EGL的功能如下：\"></a>4.3EGL的功能如下：</h3><ul>\n<li>查询并初始化设备显示商的可用显示设备</li>\n<li>创建渲染表面<br> EGL创建的表面可用分为屏幕上的表面和屏幕外的表面，屏幕上的表面连接到原生窗口系统，屏幕外的表面不显示但是用作渲染表面的像素缓冲区</li>\n<li>创建渲染上下文<br> EGL 的最新版本时 EGL v1.4</li>\n</ul>\n<h3 id=\"4-4使用流程\"><a href=\"#4-4使用流程\" class=\"headerlink\" title=\"4.4使用流程\"></a>4.4使用流程</h3><p>任何OpenGL ES应用程序都必须在开始渲染之前使用EGL执行如下任务：</p>\n<img src=\"9.jpg\" style=\"zoom: 80%;\" />\n\n\n\n\n\n<h2 id=\"5-OpenGL-ES-3-0图形管线的各个阶段\"><a href=\"#5-OpenGL-ES-3-0图形管线的各个阶段\" class=\"headerlink\" title=\"5.OpenGL ES 3.0图形管线的各个阶段\"></a>5.OpenGL ES 3.0图形管线的各个阶段</h2><p><img src=\"/2023/04/14/4-2-OpenGL%20ES/8.png\"></p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/10.jpg\"></p>\n<h3 id=\"5-1顶点着色器\"><a href=\"#5-1顶点着色器\" class=\"headerlink\" title=\"5.1顶点着色器\"></a>5.1顶点着色器</h3><p>顶点和顶点着色器(Vertex &amp; Vertex shader)，shader 是指运行在GPU可编程管线上的程序，也就是GPU所用的编程语言，本质是一种类C语言。<br> Vertex shader 的内容包含：</p>\n<ul>\n<li><p>shader程序： 用来描述顶点上执⾏操作的顶点着⾊器程序源代码&#x2F;可执⾏⽂件 </p>\n</li>\n<li><p>shader 的输入属性，就是顶点数组提供的各个顶点的属性</p>\n</li>\n<li><p>uniform(统一变量)  Vertex&#x2F;Pixel shader 使用的不变的变量，如：颜色数据</p>\n</li>\n<li><p>采样器， 代表顶点着⾊器使⽤纹理的特殊统⼀变量类型。 </p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/11.jpg\"></p>\n</li>\n</ul>\n<p> 如图所示，可以由很多属性输入到顶点着色器，最后顶点着色器也会输出属性数据，其中gl_Position和gl_PointSize是OpenGL的内建变量。</p>\n<p>在图元光栅化阶段，为每个生成的片段计算 vertex shader 的输出值，并作为输入值传递给pixel shader,<br> <strong>用于分配给每个图元顶点的Vertex shader输出每个片段值的机制被称为插值</strong> </p>\n<h3 id=\"5-2图元装配\"><a href=\"#5-2图元装配\" class=\"headerlink\" title=\"5.2图元装配\"></a>5.2图元装配</h3><p>图元(Primitive):  基本的图形对象 。如：点，线，三⻆形等。</p>\n<p>图元装配: 将顶点数据计算成⼀个个图元.在这个阶段会执⾏裁剪、透视分割和Viewport变换操作。</p>\n<p>  对于每个单独图元及其对应的顶点， 图元装配阶段执⾏的操作包括：将顶点着⾊器的输出值执⾏裁剪、透视分割、视⼝变换后进⼊光栅化阶段 </p>\n<h3 id=\"5-3光栅化\"><a href=\"#5-3光栅化\" class=\"headerlink\" title=\"5.3光栅化\"></a>5.3光栅化</h3><p> 光栅化是将<strong>图元转换为一组二维片段的过程</strong>，此后这些片段就会交给Pixel shader 处理，这些二维片段就是屏幕上可以绘制的像素。 </p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/12.jpg\"></p>\n<h3 id=\"5-4-⽚元着⾊器-x2F-⽚段着⾊器\"><a href=\"#5-4-⽚元着⾊器-x2F-⽚段着⾊器\" class=\"headerlink\" title=\"5.4 ⽚元着⾊器&#x2F;⽚段着⾊器\"></a>5.4 <strong>⽚元着⾊器&#x2F;⽚段着⾊器</strong></h3><p>片段着色器（Pixel shader&#x2F;Fragment shader）为片段操作实现了通用的可编程方法，它的组成如下：</p>\n<ul>\n<li><p>Shader 程序– 描述⽚段上执⾏操作的⽚元着⾊器程序源代码&#x2F;可执⾏⽂件 </p>\n</li>\n<li><p>输入变量–光栅化阶段用插值为每个片段生成的 Vertex shader 输出</p>\n</li>\n<li><p>输出变量– 统⼀变量(uniform)–顶点&#x2F;⽚元着⾊器使⽤的不变数据 </p>\n</li>\n<li><p>采样器–代表⽚元着⾊器使⽤纹理的特殊统⼀变量类型 </p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/13.jpg\"></p>\n</li>\n</ul>\n<h3 id=\"5-5逐片段操作\"><a href=\"#5-5逐片段操作\" class=\"headerlink\" title=\"5.5逐片段操作\"></a>5.5逐片段操作</h3><p><img src=\"/2023/04/14/4-2-OpenGL%20ES/14.webp\"></p>\n<ul>\n<li>像素归属测试: 确定帧缓存区中位置(Xw,Yw)的像素⽬前是不是归属于OpenGL ES所有. 例如,如果⼀个显示OpenGL ES帧缓存区View被另外⼀个View 所遮蔽.则窗⼝系统可以确定被遮蔽的像素不属于OpenGL ES 上下⽂.从⽽不全显示这些像素. ⽽像素归属测试是OpenGL ES 的⼀部分,它不由开发者开⼈为控制,⽽是由OpenGL ES 内部进⾏。</li>\n<li>裁剪测试: 裁剪测试确定(Xw,Yw)是否位于作为OpenGL ES状态的⼀部分裁剪矩形范围内.如果该⽚段位于裁剪区域之外,则被抛弃。</li>\n<li>深度测试: 输⼊⽚段的深度值进步⽐较,确定⽚段是否拒绝测试。</li>\n<li>混合: 混合将新⽣成的⽚段颜⾊与保存在帧缓存的位置的颜⾊值组合起来。</li>\n<li>抖动: 抖动可⽤于最⼩化因为使⽤有限精度在帧缓存区中保存颜⾊值⽽产⽣的伪像。</li>\n</ul>\n<h1 id=\"二、环境搭建\"><a href=\"#二、环境搭建\" class=\"headerlink\" title=\"二、环境搭建\"></a>二、环境搭建</h1><h1 id=\"三、第一个OpenGL-ES-3-0程序\"><a href=\"#三、第一个OpenGL-ES-3-0程序\" class=\"headerlink\" title=\"三、第一个OpenGL ES 3.0程序\"></a>三、第一个OpenGL ES 3.0程序</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;esUtil.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">   <span class=\"comment\">// Handle to a program object</span></span><br><span class=\"line\">   GLuint programObject;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; UserData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// Create a shader object, load the shader source, and</span></span><br><span class=\"line\"><span class=\"comment\">// compile the shader.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">GLuint <span class=\"title function_\">LoadShader</span> <span class=\"params\">( GLenum type, <span class=\"type\">const</span> <span class=\"type\">char</span> *shaderSrc )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   GLuint shader;</span><br><span class=\"line\">   GLint compiled;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Create the shader object,创建指定类型的新着色器对象</span></span><br><span class=\"line\">   shader = glCreateShader ( type );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( shader == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Load the shader source着色器源代码本身用glShaderSource加载到着色器对象</span></span><br><span class=\"line\">   glShaderSource ( shader, <span class=\"number\">1</span>, &amp;shaderSrc, <span class=\"literal\">NULL</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Compile the shader着色器用glCompileShader函数编译</span></span><br><span class=\"line\">   glCompileShader ( shader );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Check the compile status确定编译的状态，打印输出生成的错误</span></span><br><span class=\"line\">   glGetShaderiv ( shader, GL_COMPILE_STATUS, &amp;compiled );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( !compiled )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      GLint infoLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      glGetShaderiv ( shader, GL_INFO_LOG_LENGTH, &amp;infoLen );</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( infoLen &gt; <span class=\"number\">1</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"type\">char</span> *infoLog = <span class=\"built_in\">malloc</span> ( <span class=\"keyword\">sizeof</span> ( <span class=\"type\">char</span> ) * infoLen );</span><br><span class=\"line\"></span><br><span class=\"line\">         glGetShaderInfoLog ( shader, infoLen, <span class=\"literal\">NULL</span>, infoLog );</span><br><span class=\"line\">         esLogMessage ( <span class=\"string\">&quot;Error compiling shader:\\n%s\\n&quot;</span>, infoLog );</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"built_in\">free</span> ( infoLog );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      glDeleteShader ( shader );</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> shader;<span class=\"comment\">//着色器编译成功，则返回一个新的着色器对象。</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// Initialize the shader and program object</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">Init</span> <span class=\"params\">( ESContext *esContext )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   UserData *userData = esContext-&gt;userData;</span><br><span class=\"line\">    <span class=\"comment\">//顶点着色器</span></span><br><span class=\"line\">   <span class=\"type\">char</span> vShaderStr[] =</span><br><span class=\"line\">      <span class=\"string\">&quot;#version 300 es                          \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;layout(location = 0) in vec4 vPosition;  \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;void main()                              \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;&#123;                                        \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;   gl_Position = vPosition;              \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;&#125;                                        \\n&quot;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/*1.声明着色器版本；</span></span><br><span class=\"line\"><span class=\"comment\">\t2.声明一个名为vPosition的4分量向量输入属性，layout（location=0）限定符表示这个变量的位置是顶点属性0；</span></span><br><span class=\"line\"><span class=\"comment\">\t3.声明一个main函数，表示着色器执行的开始，&#123;&#125;中是着色器主体，将vPosition输入属性拷贝到名为gl_Position的特殊输出变量。每个顶点着色器必须在gl_Position变量中输出一个位置，这个变量定义传递到管线下一个阶段的位置。*/</span></span><br><span class=\"line\">    <span class=\"comment\">//片断着色器</span></span><br><span class=\"line\">   <span class=\"type\">char</span> fShaderStr[] =</span><br><span class=\"line\">      <span class=\"string\">&quot;#version 300 es                              \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;precision mediump float;                     \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;out vec4 fragColor;                          \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;void main()                                  \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;&#123;                                            \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;   fragColor = vec4 ( 1.0, 0.0, 0.0, 1.0 );  \\n&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot;&#125;                                            \\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   GLuint vertexShader;</span><br><span class=\"line\">   GLuint fragmentShader;</span><br><span class=\"line\">   GLuint programObject;</span><br><span class=\"line\">   GLint linked;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Load the vertex/fragment shaders.编译和加载着色器</span></span><br><span class=\"line\">   vertexShader = LoadShader ( GL_VERTEX_SHADER, vShaderStr );</span><br><span class=\"line\">   fragmentShader = LoadShader ( GL_FRAGMENT_SHADER, fShaderStr );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Create the program object创建一个程序对象</span></span><br><span class=\"line\">   programObject = glCreateProgram ( );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( programObject == <span class=\"number\">0</span> )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//用glAttachShader将顶点着色器和片断着色器连接到对象上。</span></span><br><span class=\"line\">   glAttachShader ( programObject, vertexShader );</span><br><span class=\"line\">   glAttachShader ( programObject, fragmentShader );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Link the program连接程序</span></span><br><span class=\"line\">   glLinkProgram ( programObject );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Check the link status检查错误</span></span><br><span class=\"line\">   glGetProgramiv ( programObject, GL_LINK_STATUS, &amp;linked );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( !linked )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      GLint infoLen = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      glGetProgramiv ( programObject, GL_INFO_LOG_LENGTH, &amp;infoLen );</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( infoLen &gt; <span class=\"number\">1</span> )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">         <span class=\"type\">char</span> *infoLog = <span class=\"built_in\">malloc</span> ( <span class=\"keyword\">sizeof</span> ( <span class=\"type\">char</span> ) * infoLen );</span><br><span class=\"line\"></span><br><span class=\"line\">         glGetProgramInfoLog ( programObject, infoLen, <span class=\"literal\">NULL</span>, infoLog );</span><br><span class=\"line\">         esLogMessage ( <span class=\"string\">&quot;Error linking program:\\n%s\\n&quot;</span>, infoLog );</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"built_in\">free</span> ( infoLog );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      glDeleteProgram ( programObject );</span><br><span class=\"line\">      <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Store the program object.保存程序对象。对象连接成功后，可以使用程序对象进行渲染，可以调用glUseProgram ( userData-&gt;programObject )来使用程序对象</span></span><br><span class=\"line\">   userData-&gt;programObject = programObject;</span><br><span class=\"line\"></span><br><span class=\"line\">   glClearColor ( <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span> );</span><br><span class=\"line\">   <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">///</span></span><br><span class=\"line\"><span class=\"comment\">// Draw a triangle using the shader pair created in Init()</span></span><br><span class=\"line\"><span class=\"comment\">//Draw回调函数用于绘制帧</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Draw</span> <span class=\"params\">( ESContext *esContext )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   UserData *userData = esContext-&gt;userData;</span><br><span class=\"line\">   GLfloat vVertices[] = &#123;  <span class=\"number\">0.0f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.3f</span>,</span><br><span class=\"line\">                            <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.5f</span>,</span><br><span class=\"line\">                            <span class=\"number\">0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">-0.4f</span></span><br><span class=\"line\">                         &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Set the viewport设置视口的原点和宽高</span></span><br><span class=\"line\">   glViewport ( <span class=\"number\">0</span>, <span class=\"number\">0</span>, esContext-&gt;width, esContext-&gt;height );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Clear the color buffer清除缓冲区，清除颜色为glClearColor指定的颜色</span></span><br><span class=\"line\">   glClear ( GL_COLOR_BUFFER_BIT );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Use the program object对象连接成功后，可以使用程序对象进行渲染</span></span><br><span class=\"line\">   glUseProgram ( userData-&gt;programObject );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Load the vertex data加载几何形状和绘制图元</span></span><br><span class=\"line\">    <span class=\"comment\">//三角形的顶点由vVertices数组中的三个坐标（x， y， z）指定。顶点位置使用glVertexAttribPointer加载到GL，并连接到顶点着色器生命的vPosition属性</span></span><br><span class=\"line\">   glVertexAttribPointer ( <span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vVertices );</span><br><span class=\"line\">   glEnableVertexAttribArray ( <span class=\"number\">0</span> );</span><br><span class=\"line\"></span><br><span class=\"line\">   glDrawArrays ( GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span> );<span class=\"comment\">//告诉OpenGL ES绘制图元</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Shutdown</span> <span class=\"params\">( ESContext *esContext )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   UserData *userData = esContext-&gt;userData;</span><br><span class=\"line\"></span><br><span class=\"line\">   glDeleteProgram ( userData-&gt;programObject );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//应用程序的主入口。ESContext有一个名为userData、类型为void的成员变量，应用程序所需的所有数据保存在userData中</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">esMain</span> <span class=\"params\">( ESContext *esContext )</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   esContext-&gt;userData = <span class=\"built_in\">malloc</span> ( <span class=\"keyword\">sizeof</span> ( UserData ) );<span class=\"comment\">//分配userData</span></span><br><span class=\"line\"></span><br><span class=\"line\">   esCreateWindow ( esContext, <span class=\"string\">&quot;Hello Triangle&quot;</span>, <span class=\"number\">375</span>, <span class=\"number\">667</span>, ES_WINDOW_RGB );<span class=\"comment\">//创建了窗口并初始化绘图回调函数</span></span><br><span class=\"line\">\t<span class=\"comment\">//创建顶点着色器和片断着色器,OpenGL ES 3.0程序必须至少有一个顶点着色器和一个片断着色器。</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( !Init ( esContext ) )</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> GL_FALSE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   esRegisterShutdownFunc ( esContext, Shutdown );</span><br><span class=\"line\">   esRegisterDrawFunc ( esContext, Draw );</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> GL_TRUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码分析参见： <a href=\"https://www.jianshu.com/p/2ce67644eae8\">OpenGL ES 3.0 入门 - 简书 (jianshu.com)</a> </p>\n<h2 id=\"代码流程框架1\"><a href=\"#代码流程框架1\" class=\"headerlink\" title=\"代码流程框架1\"></a>代码流程框架1</h2><img src=\"16.jpg\" style=\"zoom:80%;\" />\n\n<h2 id=\"代码流程框架2\"><a href=\"#代码流程框架2\" class=\"headerlink\" title=\"代码流程框架2\"></a>代码流程框架2</h2><p><img src=\"/2023/04/14/4-2-OpenGL%20ES/19.jpg\"></p>\n<h2 id=\"代码流程框架3\"><a href=\"#代码流程框架3\" class=\"headerlink\" title=\"代码流程框架3\"></a>代码流程框架3</h2><p><img src=\"/2023/04/14/4-2-OpenGL%20ES/20.jpg\"></p>\n<h1 id=\"四、OpenGL-ES-3-0-x2F-2-0-API查询网站\"><a href=\"#四、OpenGL-ES-3-0-x2F-2-0-API查询网站\" class=\"headerlink\" title=\"四、OpenGL-ES 3.0&#x2F;2.0 API查询网站\"></a>四、OpenGL-ES 3.0&#x2F;2.0 API查询网站</h1><p>OpenGL-ES 3.0 API：<a href=\"https://www.khronos.org/registry/OpenGL-Refpages/es3.0/\">https://www.khronos.org/registry/OpenGL-Refpages/es3.0/</a></p>\n<p>OpenGL-ES 2.0 API：<a href=\"https://registry.khronos.org/OpenGL-Refpages/es2.0/\">https://registry.khronos.org/OpenGL-Refpages/es2.0/</a></p>\n<h1 id=\"五、坐标系的转换\"><a href=\"#五、坐标系的转换\" class=\"headerlink\" title=\"五、坐标系的转换\"></a>五、坐标系的转换</h1><p>1、OpenGL坐标系</p>\n<p>2、纹理坐标系</p>\n<p> 2D纹理是一个图像数据的二维数组。一个纹理单独数据元素称作“纹素”(Texel)。图像中的每个纹素根据基本格式和数据类型指定。如果用2D纹理渲染时，纹理坐标用作图像中的索引。2D纹理的纹理坐标用一对2D坐标(s,t)或者(u,v)来表示，这些坐标用于查找一个纹理贴图的规范化坐标。 </p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/18.webp\"></p>\n<p> 纹理图像的左下坐标由(0.0,0.0)决定，右上角坐标由(1.0,1.0)指定。在[0.0,1.0]之外的坐标是允许的，在区间之外的纹理读取行为由纹理包装模式决定。 </p>\n<p>3、屏幕坐标系</p>\n<p><img src=\"/2023/04/14/4-2-OpenGL%20ES/17%E5%9D%90%E6%A0%87%E7%B3%BB.png\"></p>\n<p>裁剪： 限制纹理坐标的取值范围来实现裁剪的效果 </p>\n<h1 id=\"六、纹理对象的创建与加载\"><a href=\"#六、纹理对象的创建与加载\" class=\"headerlink\" title=\"六、纹理对象的创建与加载\"></a>六、纹理对象的创建与加载</h1><h2 id=\"1-本地资源\"><a href=\"#1-本地资源\" class=\"headerlink\" title=\"1.本地资源\"></a>1.本地资源</h2><p>OpenCv读取，然后绑定纹理</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">LoadTextures</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    cv::Mat image;</span><br><span class=\"line\">\tGLuint LoadingTexture；</span><br><span class=\"line\">        </span><br><span class=\"line\">    name = <span class=\"built_in\">string</span>(<span class=\"string\">&quot;../&quot;</span> + <span class=\"string\">&quot;resource/Loadingpicture-&quot;</span> + <span class=\"built_in\">to_string</span>(<span class=\"number\">1</span>) + <span class=\"string\">&quot;.png&quot;</span>;<span class=\"comment\">//读取UI文件资源路径</span></span><br><span class=\"line\">    image = cv::<span class=\"built_in\">imread</span>(name, cv::IMREAD_UNCHANGED);<span class=\"comment\">//OpenCv读取文件</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(image.data == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">PRINT</span>(<span class=\"string\">&quot;%s::%d Load Loadingpicture.png Failed \\n&quot;</span>,\t__FILE__,  __LINE__);   </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* Genarate Texture  */</span></span><br><span class=\"line\">    <span class=\"built_in\">glGenTextures</span>(<span class=\"number\">1</span>, &amp;LoadingTexture);<span class=\"comment\">//生成纹理名称</span></span><br><span class=\"line\">    <span class=\"built_in\">glBindTexture</span>(GL_TEXTURE_2D, LoadingTexture);<span class=\"comment\">//绑定指定纹理到目标</span></span><br><span class=\"line\">    <span class=\"built_in\">glTexImage2D</span>(GL_TEXTURE_2D, <span class=\"number\">0</span>, GL_RGBA,image.cols, image.rows, <span class=\"number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, image.data);<span class=\"comment\">//指定2D纹理对象（目标纹理GL_TEXTURE_2D）</span></span><br><span class=\"line\">    <span class=\"comment\">/* Linear Filtering */</span></span><br><span class=\"line\">    <span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">    <span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">    <span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class=\"line\">    <span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class=\"line\">    <span class=\"built_in\">glBindTexture</span>(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-缓冲区资源\"><a href=\"#2-缓冲区资源\" class=\"headerlink\" title=\"2.缓冲区资源\"></a>2.缓冲区资源</h2><p>创建EGLImage对象，然后绑定纹理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"OpenGL常用API函数","date":"2023-04-14T13:44:11.000Z","comments":0,"description":null,"typora-root-url":"4-3-OpenGL常用API函数","_content":"\n## 1，GL常用\n\n### 1.1.GL_BLEND\n\n```c\n\t//开启混合，绘制带有透明度的纹理\n\tglEnable(GL_BLEND);//开启混合\n\tglDisable(GL_DEPTH_TEST);//关闭深度缓冲区，避免因alpha通道差异导致带透明度的纹理取消绘制\n\tglBlendFunc(GL_ONE_MINUS_DST_ALPHA, GL_DST_ALPHA);//设置混合方式（四选一）\n\t//glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA);\n\t//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\t//glBlendFunc(GL_DST_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tgldisable(GL_BLEND);//关闭混合\n```\n\n<!--more--> \n\n### 1.2.GL_DEPTH_TEST\n\n```c\nglEnable(GL_DEPTH_TEST);\n1.启用了之后，OpenGL在绘制的时候就会检查，当前像素前面是否有别的像素，如果别的像素挡道了它，那它就不会绘制，也就是说，OpenGL就只绘制最前面的一层。\n2.如果需要绘制带有透明度的纹理，则必须关闭深度缓冲区的检测\n```\n\n### 1.3.glClearColor&glClear()\n\n```c\n\tglClearColor(0.0f, 0.0f, 0.0f, 0.0f);//(0.75f, 0.75f, 0.75f, 0.0f)\n\tglClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); // (or whatever buffer you want to clear)\n\n\t1.glClearColor只起到Set的作用，并不Clear任何！glClearColor的作用是，指定刷新颜色缓冲区时所用的颜色。所以，完成一个刷新过程是要 glClearColor(COLOR) 与 glClear(GL_COLOR_BUFFER_BIT) 配合使用。\n\t2.glClear(GL_COLOR_BUFFER_BIT);glClear清除颜色缓冲区的作用是，防止缓冲区中原有的颜色信息影响本次绘图（注意！即使认为可以直接覆盖原值，也是有可能会影响的），当绘图区域为整个窗口时，就是通常看到的，颜色缓冲区的清除值就是窗口的背景颜色。所以，这两条清除指令并不是必须的：比如对于静态画面只需要设置一次，比如不需要背景色/背景色为白色。\n\t3. glClear 比手动涂抹一个背景画布效率高且省力，所以通常使用这种方式。\n```\n\n### 1.4.GL_SCISSOR_TEST\n\n```c\n\t//清空指定区域颜色及深度\t\n\tglEnable(GL_SCISSOR_TEST);//开启剪裁测试\n\tglScissor(window.x, window.y, window.width, window.height);//剪裁测试的区域\n\tglClearColor(0.0f, 0.0f, 0.0f, 0.0f);//纯黑色//(0.75f, 0.75f, 0.75f, 0.0f)灰色\n\tglClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); // (or whatever buffer you want to clear)\n\tglDisable(GL_SCISSOR_TEST);//关闭剪裁测试\n\t\n1.剪裁测试用于限制绘制区域。区域内的像素，将被绘制修改。区域外的像素，将不会被修改。\n2.glScissor以左下角为坐标原点(0,0)，而通常情况下，坐标系以屏幕左上角为坐标原点(0,0)。因此，需要转换一下。\n```\n\n### 1.5.glCullFace()&GL_CULL_FACE\n\n禁用多边形正面或者背面上的光照、阴影和颜色计算及操作，消除不必要的渲染计算 。 接受符号常量GL_FRONT、GL_BACK和GL_FRONT_AND_BACK。 默认值为GL_BACK\n\t\t如果mode的值为GL_FRONT_AND_BACK，那么多边形将不会被绘制到屏幕上，但其他图元如点和线还是会绘制到屏幕上的。 \n\n```c\nglEnable(GL_CULL_FACE);//启用分面剔除,默认剔除功能是关闭的。\nglCullFace(GL_BACK);//设置后向分面剔除\nglFrontFace(GL_CCW);//设置逆时针多边形作为正面\n\nglDisable(GL_CULL_FACE);//关闭分面剔除\nglCullFace(GL_BACK);\n```\n\n### 1.6.glFrontFace();  \n\n 前面多边形的方向 。参数： GL_CW和GL_CCW。 默认值为GL_CCW。 \n\n如果一个虚构的对象的顶点是按照多边形内部顺时针的方向进行绘制的，那么可以称这个多边形基于窗口坐标的投影是顺时针的。反之，则为逆时针。\nglFrontFace就是用来指定多边形在窗口坐标中的方向是逆时针还是顺时针的。GL_CCW说明逆时针多边形为正面，而GL_CW说明顺时针多边形为正面。默认是逆时针多边形为正面\n\n注： 在完全由不透明封闭表面组成的场景中，背面多边形从不可见。 消除这些不可见多边形具有加快图像呈现的明显优势。 \n\n## 2、OpenGL核心函数库\n\nglAccum 操作累加缓冲区\nglAddSwapHintRectWIN 定义一组被 SwapBuffers 拷贝的三角形\nglAlphaFunc 允许设置 alpha 检测功能\nglAreTexturesResident 决定特定的纹理对象是否常驻在纹理内存中\nglArrayElement 定义一个被用于顶点渲染的数组成分\nglBegin,glEnd 定义一个或一组原始的顶点\nglBindTexture 允许建立一个绑定到目标纹理的有名称的纹理\nglBitmap 绘制一个位图\nglBlendFunc 特殊的像素算法\nglCallList 执行一个显示列表\nglCallLists 执行一列显示列表\nglClear 用当前值清除缓冲区\nGlClearAccum 为累加缓冲区指定用于清除的值 \nglClearColor 为色彩缓冲区指定用于清除的值 \nglClearDepth 为深度缓冲区指定用于清除的值 \nglClearStencil 为模板缓冲区指定用于清除的值 \nglClipPlane 定义被裁剪的一个平面几何体 \nglColor 设置当前色彩\nglColorMask 允许或不允许写色彩组件帧缓冲区\nglColorMaterial 使一个材质色彩指向当前的色彩\nglColorPointer 定义一列色彩\nglColorTableEXT 定义目的一个调色板纹理的调色板的格式和尺寸 \nglColorSubTableEXT 定义目的纹理的调色板的一部分被替换\nglCopyPixels 拷贝帧缓冲区里的像素\nglCopyTexImage1D 将像素从帧缓冲区拷贝到一个单空间纹理图象中\nglCopyTexImage2D 将像素从帧缓冲区拷贝到一个双空间纹理图象中\nglCopyTexSubImage1D 从帧缓冲区拷贝一个单空间纹理的子图象 \nglCopyTexSubImage2D 从帧缓冲区拷贝一个双空间纹理的子图象 \nglCullFace 定义前面或后面是否能被精选\nglDeleteLists 删除相邻一组显示列表\nglDeleteTextures 删除命名的纹理\nglDepthFunc 定义用于深度缓冲区对照的数据\nglDepthMask 允许或不允许写入深度缓冲区 \nglDepthRange 定义 z 值从标准的设备坐标映射到窗口坐标\nglDrawArrays 定义渲染多个图元\nglDrawBuffer 定义选择哪个色彩缓冲区被绘制\nglDrawElements 渲染数组数据中的图元\nglDrawPixels 将一组像素写入帧缓冲区\nglEdgeFlag 定义一个边缘标志数组\nglEdgeFlagPointer 定义一个边缘标志数组\nglEnable, glDisable 打开或关闭 OpenGL 的特殊功能\nglEnableClientState,glDisableClientState 分别打开或关闭数组 \nglEvalCoord 求解一维和二维贴图\nglEvalMesh1,glEvalMesh2 求解一维和二维点或线的网格\nglEvalPoint1,glEvalPoint2 生成及求解一个网格中的单点 \nglFeedbackBuffer 控制反馈模式\nglFinish 等待直到 OpenGL 执行结束\nglFlush 在有限的时间里强制 OpenGL 的执行\nglFogf,glFogi,glFogfv,glFogiv 定义雾参数\nglFrontFace 定义多边形的前面和背面\nglFrustum 当前矩阵乘上透视矩阵\nglGenLists 生成一组空的连续的显示列表\nglGenTextures 生成纹理名称\nglGetBooleanv,glGetDoublev,glGetFloatv,glGetIntegerv 返回值或所选参数值 \nglGetClipPlane 返回特定裁减面的系数\nglGetColorTableEXT 从当前目标纹理调色板得到颜色表数据 \nglGetColorTableParameterfvEXT,glGetColorTableParameterivEXT 从颜色表中 得到调色板参数\nglGetError 返回错误消息\nglGetLightfv,glGetLightiv 返回光源参数值 \nglGetMapdv,glGetMapfv,glGetMapiv 返回求值程序参数\nglGetMaterialfv,glGetMaterialiv 返回材质参数 \nglGetPixelMapfv,glGetpixelMapuiv,glGetpixelMapusv 返回特定的像素图\nglGetPointerv 返回顶点数据数组的地址\nglGetPolygonStipple 返回多边形的点图案\nglGetString 返回描述当前 OpenGl 连接的字符串\nglGetTexEnvfv 返回纹理环境参数\nglGetTexGendv,glGetTexGenfv,glGetTexGeniv 返回纹理坐标生成参数\nglGetTexImage 返回一个纹理图象 \nglGetTexLevelParameterfv,glGetTexLevelParameteriv 返回特定的纹理参数的 细节级别\nglGetTexParameterfv,glGetTexParameteriv 返回纹理参数值\nglHint 定义实现特殊的线索\nglIndex 建立当前的色彩索引\nglIndexMask 控制写色彩索引缓冲区里的单独位\nglIndexPointer 定义一个颜色索引数组\nglInitName 初始化名字堆栈\nglInterleavedArrays 同时定义和允许几个在一个大的数组集合里的交替数组 \nglIsEnabled 定义性能是否被允许\nglIsList 检测显示列表的存在\nglIsTexture 确定一个名字对应一个纹理\nglLightf,glLighti,glLightfv,glLightiv 设置光源参数 \nglLightModelf,glLightModeli,glLightModelfv,glLightModeliv 设置光线模型参数\nglLineStipple 设定线点绘图案\nglLineWidth 设定光栅线段的宽\nglListBase 为 glcallList 设定显示列表的基础\nglLoadIdentity 用恒等矩阵替换当前矩阵\nglLoadMatrixd,glLoadMatrif 用一个任意矩阵替换当前矩阵\nglLoadName 将一个名字调入名字堆栈\nglLogicOp 为色彩索引渲染定义一个逻辑像素操作\nglMap1d,glMap1f 定义一个一维求值程序\nglMap2d,glMap2f 定义一个二维求值程序\nglMapGrid1d,glMapGrid1f,glMapgrid2d,glMapGrid2f 定义一个一维或二维网 格\nglMaterialf,glMateriali,glMateriafv,glMaterialiv 为光照模型定义材质参数\nglMatrixMode 定义哪一个矩阵是当前矩阵\nglMultMatrixd,glMultMatrixf 用当前矩阵与任意矩阵相乘\nglNewList,glEndList 创建或替换一个显示列表\nglNormal 设定当前顶点法向\nglNormalPointer 设定一个法向数组\nglOrtho 用垂直矩阵与当前矩阵相乘\nglPassThrough 在反馈缓冲区做记号\nglPixelMapfv,glPixelMapuiv,glPixelMapusv 设定像素交换图\nglPixelStoref,glpixelStorei 设定像素存储模式\nglPixelTransferf,glPixelTransferi 设定像素存储模式\nglPixelZoom 设定像素缩放因数\nglPointSize 设定光栅点的直径\nglPolygonMode 选择一个多边形的光栅模式\nglPolygonOffset 设定 OpenGL 用于计算深度值的比例和单元\nglPolygonStipple 设定多边形填充图案\nglPrioritizeTextures 设定纹理固定的优先级\nglPushAttrib,glPopAttrib 属性堆栈的压入和弹出操作\nglPushClientAttrib,glPopClientAttrib 在客户属性堆栈存储和恢复客户状态值 \nglPushmatrix,glPopMatrix 矩阵堆栈的压入和弹出操作\nglPushName,glPopName 名字堆栈的压入和弹出操作\nglRasterPos 定义像素操作的光栅位置\nglreadBuffer 为像素选择一个源色彩缓冲区\nglReadPixels 从帧缓冲区读取一组数据 \nglRectd,glRectf,glRecti,glRects,glRectdv,glRectfv,glRectiv,glRectsv 绘制一个三 角形\nglRenderMode 定义光栅模式\nglRotated,glRotatef 将旋转矩阵与当前矩阵相乘\nglScaled,glScalef 将一般的比例矩阵与当前矩阵相乘\nglScissor 定义裁减框\nglSelectBuffer 为选择模式值建立一个缓冲区\nglShadeModel 选择平直或平滑着色\nglStencilFunc 为模板测试设置功能和参照值\nglStencilMask 控制在模板面写单独的位\nglStencilOp 设置激活模式测试\nglTexCoord 设置当前纹理坐标\nglTexCoordPointer 定义一个纹理坐标数组 \nglTexEnvf,glTexEnvi,glTexEnvfv,glTexEnviv 设定纹理坐标环境参数 \nglTexGend,glTexgenf,glTexGendv,glTexGenfv,glTexGeniv 控制纹理坐标的生成\nglTexImage1D 定义一个一维的纹理图象\nglTexImage2D 定义一个二维的纹理图 \nglTexParameterf,glTexParameteri,glTexParameterfv,glTexParameteriv 设置纹理参数\nglTexSubImage1D 定义一个存在的一维纹理图像的一部分,但不能定义新的纹理\nglTexSubImage2D 定义一个存在的二维纹理图像的一部分,但不能定义新的纹理\nglTranslated,glTranslatef 将变换矩阵与当前矩阵相乘\nglVertex 定义一个顶点\nglVertexPointer 设定一个顶点数据数组\nglViewport 设置视窗\n","source":"_posts/4-3-OpenGL常用API函数.md","raw":"---\ntitle: OpenGL常用API函数\ndate: 2023-4-14 21:44:11\ncategories: 笔记\ntags: [嵌入式,OpenGL]\ncomments: false\ndescription:\ntypora-root-url: 4-3-OpenGL常用API函数\n\n---\n\n## 1，GL常用\n\n### 1.1.GL_BLEND\n\n```c\n\t//开启混合，绘制带有透明度的纹理\n\tglEnable(GL_BLEND);//开启混合\n\tglDisable(GL_DEPTH_TEST);//关闭深度缓冲区，避免因alpha通道差异导致带透明度的纹理取消绘制\n\tglBlendFunc(GL_ONE_MINUS_DST_ALPHA, GL_DST_ALPHA);//设置混合方式（四选一）\n\t//glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA);\n\t//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\t//glBlendFunc(GL_DST_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tgldisable(GL_BLEND);//关闭混合\n```\n\n<!--more--> \n\n### 1.2.GL_DEPTH_TEST\n\n```c\nglEnable(GL_DEPTH_TEST);\n1.启用了之后，OpenGL在绘制的时候就会检查，当前像素前面是否有别的像素，如果别的像素挡道了它，那它就不会绘制，也就是说，OpenGL就只绘制最前面的一层。\n2.如果需要绘制带有透明度的纹理，则必须关闭深度缓冲区的检测\n```\n\n### 1.3.glClearColor&glClear()\n\n```c\n\tglClearColor(0.0f, 0.0f, 0.0f, 0.0f);//(0.75f, 0.75f, 0.75f, 0.0f)\n\tglClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); // (or whatever buffer you want to clear)\n\n\t1.glClearColor只起到Set的作用，并不Clear任何！glClearColor的作用是，指定刷新颜色缓冲区时所用的颜色。所以，完成一个刷新过程是要 glClearColor(COLOR) 与 glClear(GL_COLOR_BUFFER_BIT) 配合使用。\n\t2.glClear(GL_COLOR_BUFFER_BIT);glClear清除颜色缓冲区的作用是，防止缓冲区中原有的颜色信息影响本次绘图（注意！即使认为可以直接覆盖原值，也是有可能会影响的），当绘图区域为整个窗口时，就是通常看到的，颜色缓冲区的清除值就是窗口的背景颜色。所以，这两条清除指令并不是必须的：比如对于静态画面只需要设置一次，比如不需要背景色/背景色为白色。\n\t3. glClear 比手动涂抹一个背景画布效率高且省力，所以通常使用这种方式。\n```\n\n### 1.4.GL_SCISSOR_TEST\n\n```c\n\t//清空指定区域颜色及深度\t\n\tglEnable(GL_SCISSOR_TEST);//开启剪裁测试\n\tglScissor(window.x, window.y, window.width, window.height);//剪裁测试的区域\n\tglClearColor(0.0f, 0.0f, 0.0f, 0.0f);//纯黑色//(0.75f, 0.75f, 0.75f, 0.0f)灰色\n\tglClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); // (or whatever buffer you want to clear)\n\tglDisable(GL_SCISSOR_TEST);//关闭剪裁测试\n\t\n1.剪裁测试用于限制绘制区域。区域内的像素，将被绘制修改。区域外的像素，将不会被修改。\n2.glScissor以左下角为坐标原点(0,0)，而通常情况下，坐标系以屏幕左上角为坐标原点(0,0)。因此，需要转换一下。\n```\n\n### 1.5.glCullFace()&GL_CULL_FACE\n\n禁用多边形正面或者背面上的光照、阴影和颜色计算及操作，消除不必要的渲染计算 。 接受符号常量GL_FRONT、GL_BACK和GL_FRONT_AND_BACK。 默认值为GL_BACK\n\t\t如果mode的值为GL_FRONT_AND_BACK，那么多边形将不会被绘制到屏幕上，但其他图元如点和线还是会绘制到屏幕上的。 \n\n```c\nglEnable(GL_CULL_FACE);//启用分面剔除,默认剔除功能是关闭的。\nglCullFace(GL_BACK);//设置后向分面剔除\nglFrontFace(GL_CCW);//设置逆时针多边形作为正面\n\nglDisable(GL_CULL_FACE);//关闭分面剔除\nglCullFace(GL_BACK);\n```\n\n### 1.6.glFrontFace();  \n\n 前面多边形的方向 。参数： GL_CW和GL_CCW。 默认值为GL_CCW。 \n\n如果一个虚构的对象的顶点是按照多边形内部顺时针的方向进行绘制的，那么可以称这个多边形基于窗口坐标的投影是顺时针的。反之，则为逆时针。\nglFrontFace就是用来指定多边形在窗口坐标中的方向是逆时针还是顺时针的。GL_CCW说明逆时针多边形为正面，而GL_CW说明顺时针多边形为正面。默认是逆时针多边形为正面\n\n注： 在完全由不透明封闭表面组成的场景中，背面多边形从不可见。 消除这些不可见多边形具有加快图像呈现的明显优势。 \n\n## 2、OpenGL核心函数库\n\nglAccum 操作累加缓冲区\nglAddSwapHintRectWIN 定义一组被 SwapBuffers 拷贝的三角形\nglAlphaFunc 允许设置 alpha 检测功能\nglAreTexturesResident 决定特定的纹理对象是否常驻在纹理内存中\nglArrayElement 定义一个被用于顶点渲染的数组成分\nglBegin,glEnd 定义一个或一组原始的顶点\nglBindTexture 允许建立一个绑定到目标纹理的有名称的纹理\nglBitmap 绘制一个位图\nglBlendFunc 特殊的像素算法\nglCallList 执行一个显示列表\nglCallLists 执行一列显示列表\nglClear 用当前值清除缓冲区\nGlClearAccum 为累加缓冲区指定用于清除的值 \nglClearColor 为色彩缓冲区指定用于清除的值 \nglClearDepth 为深度缓冲区指定用于清除的值 \nglClearStencil 为模板缓冲区指定用于清除的值 \nglClipPlane 定义被裁剪的一个平面几何体 \nglColor 设置当前色彩\nglColorMask 允许或不允许写色彩组件帧缓冲区\nglColorMaterial 使一个材质色彩指向当前的色彩\nglColorPointer 定义一列色彩\nglColorTableEXT 定义目的一个调色板纹理的调色板的格式和尺寸 \nglColorSubTableEXT 定义目的纹理的调色板的一部分被替换\nglCopyPixels 拷贝帧缓冲区里的像素\nglCopyTexImage1D 将像素从帧缓冲区拷贝到一个单空间纹理图象中\nglCopyTexImage2D 将像素从帧缓冲区拷贝到一个双空间纹理图象中\nglCopyTexSubImage1D 从帧缓冲区拷贝一个单空间纹理的子图象 \nglCopyTexSubImage2D 从帧缓冲区拷贝一个双空间纹理的子图象 \nglCullFace 定义前面或后面是否能被精选\nglDeleteLists 删除相邻一组显示列表\nglDeleteTextures 删除命名的纹理\nglDepthFunc 定义用于深度缓冲区对照的数据\nglDepthMask 允许或不允许写入深度缓冲区 \nglDepthRange 定义 z 值从标准的设备坐标映射到窗口坐标\nglDrawArrays 定义渲染多个图元\nglDrawBuffer 定义选择哪个色彩缓冲区被绘制\nglDrawElements 渲染数组数据中的图元\nglDrawPixels 将一组像素写入帧缓冲区\nglEdgeFlag 定义一个边缘标志数组\nglEdgeFlagPointer 定义一个边缘标志数组\nglEnable, glDisable 打开或关闭 OpenGL 的特殊功能\nglEnableClientState,glDisableClientState 分别打开或关闭数组 \nglEvalCoord 求解一维和二维贴图\nglEvalMesh1,glEvalMesh2 求解一维和二维点或线的网格\nglEvalPoint1,glEvalPoint2 生成及求解一个网格中的单点 \nglFeedbackBuffer 控制反馈模式\nglFinish 等待直到 OpenGL 执行结束\nglFlush 在有限的时间里强制 OpenGL 的执行\nglFogf,glFogi,glFogfv,glFogiv 定义雾参数\nglFrontFace 定义多边形的前面和背面\nglFrustum 当前矩阵乘上透视矩阵\nglGenLists 生成一组空的连续的显示列表\nglGenTextures 生成纹理名称\nglGetBooleanv,glGetDoublev,glGetFloatv,glGetIntegerv 返回值或所选参数值 \nglGetClipPlane 返回特定裁减面的系数\nglGetColorTableEXT 从当前目标纹理调色板得到颜色表数据 \nglGetColorTableParameterfvEXT,glGetColorTableParameterivEXT 从颜色表中 得到调色板参数\nglGetError 返回错误消息\nglGetLightfv,glGetLightiv 返回光源参数值 \nglGetMapdv,glGetMapfv,glGetMapiv 返回求值程序参数\nglGetMaterialfv,glGetMaterialiv 返回材质参数 \nglGetPixelMapfv,glGetpixelMapuiv,glGetpixelMapusv 返回特定的像素图\nglGetPointerv 返回顶点数据数组的地址\nglGetPolygonStipple 返回多边形的点图案\nglGetString 返回描述当前 OpenGl 连接的字符串\nglGetTexEnvfv 返回纹理环境参数\nglGetTexGendv,glGetTexGenfv,glGetTexGeniv 返回纹理坐标生成参数\nglGetTexImage 返回一个纹理图象 \nglGetTexLevelParameterfv,glGetTexLevelParameteriv 返回特定的纹理参数的 细节级别\nglGetTexParameterfv,glGetTexParameteriv 返回纹理参数值\nglHint 定义实现特殊的线索\nglIndex 建立当前的色彩索引\nglIndexMask 控制写色彩索引缓冲区里的单独位\nglIndexPointer 定义一个颜色索引数组\nglInitName 初始化名字堆栈\nglInterleavedArrays 同时定义和允许几个在一个大的数组集合里的交替数组 \nglIsEnabled 定义性能是否被允许\nglIsList 检测显示列表的存在\nglIsTexture 确定一个名字对应一个纹理\nglLightf,glLighti,glLightfv,glLightiv 设置光源参数 \nglLightModelf,glLightModeli,glLightModelfv,glLightModeliv 设置光线模型参数\nglLineStipple 设定线点绘图案\nglLineWidth 设定光栅线段的宽\nglListBase 为 glcallList 设定显示列表的基础\nglLoadIdentity 用恒等矩阵替换当前矩阵\nglLoadMatrixd,glLoadMatrif 用一个任意矩阵替换当前矩阵\nglLoadName 将一个名字调入名字堆栈\nglLogicOp 为色彩索引渲染定义一个逻辑像素操作\nglMap1d,glMap1f 定义一个一维求值程序\nglMap2d,glMap2f 定义一个二维求值程序\nglMapGrid1d,glMapGrid1f,glMapgrid2d,glMapGrid2f 定义一个一维或二维网 格\nglMaterialf,glMateriali,glMateriafv,glMaterialiv 为光照模型定义材质参数\nglMatrixMode 定义哪一个矩阵是当前矩阵\nglMultMatrixd,glMultMatrixf 用当前矩阵与任意矩阵相乘\nglNewList,glEndList 创建或替换一个显示列表\nglNormal 设定当前顶点法向\nglNormalPointer 设定一个法向数组\nglOrtho 用垂直矩阵与当前矩阵相乘\nglPassThrough 在反馈缓冲区做记号\nglPixelMapfv,glPixelMapuiv,glPixelMapusv 设定像素交换图\nglPixelStoref,glpixelStorei 设定像素存储模式\nglPixelTransferf,glPixelTransferi 设定像素存储模式\nglPixelZoom 设定像素缩放因数\nglPointSize 设定光栅点的直径\nglPolygonMode 选择一个多边形的光栅模式\nglPolygonOffset 设定 OpenGL 用于计算深度值的比例和单元\nglPolygonStipple 设定多边形填充图案\nglPrioritizeTextures 设定纹理固定的优先级\nglPushAttrib,glPopAttrib 属性堆栈的压入和弹出操作\nglPushClientAttrib,glPopClientAttrib 在客户属性堆栈存储和恢复客户状态值 \nglPushmatrix,glPopMatrix 矩阵堆栈的压入和弹出操作\nglPushName,glPopName 名字堆栈的压入和弹出操作\nglRasterPos 定义像素操作的光栅位置\nglreadBuffer 为像素选择一个源色彩缓冲区\nglReadPixels 从帧缓冲区读取一组数据 \nglRectd,glRectf,glRecti,glRects,glRectdv,glRectfv,glRectiv,glRectsv 绘制一个三 角形\nglRenderMode 定义光栅模式\nglRotated,glRotatef 将旋转矩阵与当前矩阵相乘\nglScaled,glScalef 将一般的比例矩阵与当前矩阵相乘\nglScissor 定义裁减框\nglSelectBuffer 为选择模式值建立一个缓冲区\nglShadeModel 选择平直或平滑着色\nglStencilFunc 为模板测试设置功能和参照值\nglStencilMask 控制在模板面写单独的位\nglStencilOp 设置激活模式测试\nglTexCoord 设置当前纹理坐标\nglTexCoordPointer 定义一个纹理坐标数组 \nglTexEnvf,glTexEnvi,glTexEnvfv,glTexEnviv 设定纹理坐标环境参数 \nglTexGend,glTexgenf,glTexGendv,glTexGenfv,glTexGeniv 控制纹理坐标的生成\nglTexImage1D 定义一个一维的纹理图象\nglTexImage2D 定义一个二维的纹理图 \nglTexParameterf,glTexParameteri,glTexParameterfv,glTexParameteriv 设置纹理参数\nglTexSubImage1D 定义一个存在的一维纹理图像的一部分,但不能定义新的纹理\nglTexSubImage2D 定义一个存在的二维纹理图像的一部分,但不能定义新的纹理\nglTranslated,glTranslatef 将变换矩阵与当前矩阵相乘\nglVertex 定义一个顶点\nglVertexPointer 设定一个顶点数据数组\nglViewport 设置视窗\n","slug":"4-3-OpenGL常用API函数","published":1,"updated":"2023-04-14T13:44:48.005Z","_id":"clgglizt30000hoobe91vdfjh","layout":"post","photos":[],"link":"","content":"<h2 id=\"1，GL常用\"><a href=\"#1，GL常用\" class=\"headerlink\" title=\"1，GL常用\"></a>1，GL常用</h2><h3 id=\"1-1-GL-BLEND\"><a href=\"#1-1-GL-BLEND\" class=\"headerlink\" title=\"1.1.GL_BLEND\"></a>1.1.GL_BLEND</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//开启混合，绘制带有透明度的纹理</span></span><br><span class=\"line\">glEnable(GL_BLEND);<span class=\"comment\">//开启混合</span></span><br><span class=\"line\">glDisable(GL_DEPTH_TEST);<span class=\"comment\">//关闭深度缓冲区，避免因alpha通道差异导致带透明度的纹理取消绘制</span></span><br><span class=\"line\">glBlendFunc(GL_ONE_MINUS_DST_ALPHA, GL_DST_ALPHA);<span class=\"comment\">//设置混合方式（四选一）</span></span><br><span class=\"line\"><span class=\"comment\">//glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA);</span></span><br><span class=\"line\"><span class=\"comment\">//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></span><br><span class=\"line\"><span class=\"comment\">//glBlendFunc(GL_DST_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></span><br><span class=\"line\">gldisable(GL_BLEND);<span class=\"comment\">//关闭混合</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span> \n\n<h3 id=\"1-2-GL-DEPTH-TEST\"><a href=\"#1-2-GL-DEPTH-TEST\" class=\"headerlink\" title=\"1.2.GL_DEPTH_TEST\"></a>1.2.GL_DEPTH_TEST</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_DEPTH_TEST);</span><br><span class=\"line\"><span class=\"number\">1.</span>启用了之后，OpenGL在绘制的时候就会检查，当前像素前面是否有别的像素，如果别的像素挡道了它，那它就不会绘制，也就是说，OpenGL就只绘制最前面的一层。</span><br><span class=\"line\"><span class=\"number\">2.</span>如果需要绘制带有透明度的纹理，则必须关闭深度缓冲区的检测</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-glClearColor-amp-glClear\"><a href=\"#1-3-glClearColor-amp-glClear\" class=\"headerlink\" title=\"1.3.glClearColor&amp;glClear()\"></a>1.3.glClearColor&amp;glClear()</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glClearColor(<span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>);<span class=\"comment\">//(0.75f, 0.75f, 0.75f, 0.0f)</span></span><br><span class=\"line\">glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); <span class=\"comment\">// (or whatever buffer you want to clear)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>glClearColor只起到Set的作用，并不Clear任何！glClearColor的作用是，指定刷新颜色缓冲区时所用的颜色。所以，完成一个刷新过程是要 glClearColor(COLOR) 与 glClear(GL_COLOR_BUFFER_BIT) 配合使用。</span><br><span class=\"line\"><span class=\"number\">2.</span>glClear(GL_COLOR_BUFFER_BIT);glClear清除颜色缓冲区的作用是，防止缓冲区中原有的颜色信息影响本次绘图（注意！即使认为可以直接覆盖原值，也是有可能会影响的），当绘图区域为整个窗口时，就是通常看到的，颜色缓冲区的清除值就是窗口的背景颜色。所以，这两条清除指令并不是必须的：比如对于静态画面只需要设置一次，比如不需要背景色/背景色为白色。</span><br><span class=\"line\"><span class=\"number\">3.</span> glClear 比手动涂抹一个背景画布效率高且省力，所以通常使用这种方式。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-GL-SCISSOR-TEST\"><a href=\"#1-4-GL-SCISSOR-TEST\" class=\"headerlink\" title=\"1.4.GL_SCISSOR_TEST\"></a>1.4.GL_SCISSOR_TEST</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">//清空指定区域颜色及深度\t</span></span><br><span class=\"line\">\tglEnable(GL_SCISSOR_TEST);<span class=\"comment\">//开启剪裁测试</span></span><br><span class=\"line\">\tglScissor(window.x, window.y, window.width, window.height);<span class=\"comment\">//剪裁测试的区域</span></span><br><span class=\"line\">\tglClearColor(<span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>);<span class=\"comment\">//纯黑色//(0.75f, 0.75f, 0.75f, 0.0f)灰色</span></span><br><span class=\"line\">\tglClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); <span class=\"comment\">// (or whatever buffer you want to clear)</span></span><br><span class=\"line\">\tglDisable(GL_SCISSOR_TEST);<span class=\"comment\">//关闭剪裁测试</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"number\">1.</span>剪裁测试用于限制绘制区域。区域内的像素，将被绘制修改。区域外的像素，将不会被修改。</span><br><span class=\"line\"><span class=\"number\">2.</span>glScissor以左下角为坐标原点(<span class=\"number\">0</span>,<span class=\"number\">0</span>)，而通常情况下，坐标系以屏幕左上角为坐标原点(<span class=\"number\">0</span>,<span class=\"number\">0</span>)。因此，需要转换一下。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-glCullFace-amp-GL-CULL-FACE\"><a href=\"#1-5-glCullFace-amp-GL-CULL-FACE\" class=\"headerlink\" title=\"1.5.glCullFace()&amp;GL_CULL_FACE\"></a>1.5.glCullFace()&amp;GL_CULL_FACE</h3><p>禁用多边形正面或者背面上的光照、阴影和颜色计算及操作，消除不必要的渲染计算 。 接受符号常量GL_FRONT、GL_BACK和GL_FRONT_AND_BACK。 默认值为GL_BACK<br>        如果mode的值为GL_FRONT_AND_BACK，那么多边形将不会被绘制到屏幕上，但其他图元如点和线还是会绘制到屏幕上的。 </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_CULL_FACE);<span class=\"comment\">//启用分面剔除,默认剔除功能是关闭的。</span></span><br><span class=\"line\">glCullFace(GL_BACK);<span class=\"comment\">//设置后向分面剔除</span></span><br><span class=\"line\">glFrontFace(GL_CCW);<span class=\"comment\">//设置逆时针多边形作为正面</span></span><br><span class=\"line\"></span><br><span class=\"line\">glDisable(GL_CULL_FACE);<span class=\"comment\">//关闭分面剔除</span></span><br><span class=\"line\">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-glFrontFace\"><a href=\"#1-6-glFrontFace\" class=\"headerlink\" title=\"1.6.glFrontFace();\"></a>1.6.glFrontFace();</h3><p> 前面多边形的方向 。参数： GL_CW和GL_CCW。 默认值为GL_CCW。 </p>\n<p>如果一个虚构的对象的顶点是按照多边形内部顺时针的方向进行绘制的，那么可以称这个多边形基于窗口坐标的投影是顺时针的。反之，则为逆时针。<br>glFrontFace就是用来指定多边形在窗口坐标中的方向是逆时针还是顺时针的。GL_CCW说明逆时针多边形为正面，而GL_CW说明顺时针多边形为正面。默认是逆时针多边形为正面</p>\n<p>注： 在完全由不透明封闭表面组成的场景中，背面多边形从不可见。 消除这些不可见多边形具有加快图像呈现的明显优势。 </p>\n<h2 id=\"2、OpenGL核心函数库\"><a href=\"#2、OpenGL核心函数库\" class=\"headerlink\" title=\"2、OpenGL核心函数库\"></a>2、OpenGL核心函数库</h2><p>glAccum 操作累加缓冲区<br>glAddSwapHintRectWIN 定义一组被 SwapBuffers 拷贝的三角形<br>glAlphaFunc 允许设置 alpha 检测功能<br>glAreTexturesResident 决定特定的纹理对象是否常驻在纹理内存中<br>glArrayElement 定义一个被用于顶点渲染的数组成分<br>glBegin,glEnd 定义一个或一组原始的顶点<br>glBindTexture 允许建立一个绑定到目标纹理的有名称的纹理<br>glBitmap 绘制一个位图<br>glBlendFunc 特殊的像素算法<br>glCallList 执行一个显示列表<br>glCallLists 执行一列显示列表<br>glClear 用当前值清除缓冲区<br>GlClearAccum 为累加缓冲区指定用于清除的值<br>glClearColor 为色彩缓冲区指定用于清除的值<br>glClearDepth 为深度缓冲区指定用于清除的值<br>glClearStencil 为模板缓冲区指定用于清除的值<br>glClipPlane 定义被裁剪的一个平面几何体<br>glColor 设置当前色彩<br>glColorMask 允许或不允许写色彩组件帧缓冲区<br>glColorMaterial 使一个材质色彩指向当前的色彩<br>glColorPointer 定义一列色彩<br>glColorTableEXT 定义目的一个调色板纹理的调色板的格式和尺寸<br>glColorSubTableEXT 定义目的纹理的调色板的一部分被替换<br>glCopyPixels 拷贝帧缓冲区里的像素<br>glCopyTexImage1D 将像素从帧缓冲区拷贝到一个单空间纹理图象中<br>glCopyTexImage2D 将像素从帧缓冲区拷贝到一个双空间纹理图象中<br>glCopyTexSubImage1D 从帧缓冲区拷贝一个单空间纹理的子图象<br>glCopyTexSubImage2D 从帧缓冲区拷贝一个双空间纹理的子图象<br>glCullFace 定义前面或后面是否能被精选<br>glDeleteLists 删除相邻一组显示列表<br>glDeleteTextures 删除命名的纹理<br>glDepthFunc 定义用于深度缓冲区对照的数据<br>glDepthMask 允许或不允许写入深度缓冲区<br>glDepthRange 定义 z 值从标准的设备坐标映射到窗口坐标<br>glDrawArrays 定义渲染多个图元<br>glDrawBuffer 定义选择哪个色彩缓冲区被绘制<br>glDrawElements 渲染数组数据中的图元<br>glDrawPixels 将一组像素写入帧缓冲区<br>glEdgeFlag 定义一个边缘标志数组<br>glEdgeFlagPointer 定义一个边缘标志数组<br>glEnable, glDisable 打开或关闭 OpenGL 的特殊功能<br>glEnableClientState,glDisableClientState 分别打开或关闭数组<br>glEvalCoord 求解一维和二维贴图<br>glEvalMesh1,glEvalMesh2 求解一维和二维点或线的网格<br>glEvalPoint1,glEvalPoint2 生成及求解一个网格中的单点<br>glFeedbackBuffer 控制反馈模式<br>glFinish 等待直到 OpenGL 执行结束<br>glFlush 在有限的时间里强制 OpenGL 的执行<br>glFogf,glFogi,glFogfv,glFogiv 定义雾参数<br>glFrontFace 定义多边形的前面和背面<br>glFrustum 当前矩阵乘上透视矩阵<br>glGenLists 生成一组空的连续的显示列表<br>glGenTextures 生成纹理名称<br>glGetBooleanv,glGetDoublev,glGetFloatv,glGetIntegerv 返回值或所选参数值<br>glGetClipPlane 返回特定裁减面的系数<br>glGetColorTableEXT 从当前目标纹理调色板得到颜色表数据<br>glGetColorTableParameterfvEXT,glGetColorTableParameterivEXT 从颜色表中 得到调色板参数<br>glGetError 返回错误消息<br>glGetLightfv,glGetLightiv 返回光源参数值<br>glGetMapdv,glGetMapfv,glGetMapiv 返回求值程序参数<br>glGetMaterialfv,glGetMaterialiv 返回材质参数<br>glGetPixelMapfv,glGetpixelMapuiv,glGetpixelMapusv 返回特定的像素图<br>glGetPointerv 返回顶点数据数组的地址<br>glGetPolygonStipple 返回多边形的点图案<br>glGetString 返回描述当前 OpenGl 连接的字符串<br>glGetTexEnvfv 返回纹理环境参数<br>glGetTexGendv,glGetTexGenfv,glGetTexGeniv 返回纹理坐标生成参数<br>glGetTexImage 返回一个纹理图象<br>glGetTexLevelParameterfv,glGetTexLevelParameteriv 返回特定的纹理参数的 细节级别<br>glGetTexParameterfv,glGetTexParameteriv 返回纹理参数值<br>glHint 定义实现特殊的线索<br>glIndex 建立当前的色彩索引<br>glIndexMask 控制写色彩索引缓冲区里的单独位<br>glIndexPointer 定义一个颜色索引数组<br>glInitName 初始化名字堆栈<br>glInterleavedArrays 同时定义和允许几个在一个大的数组集合里的交替数组<br>glIsEnabled 定义性能是否被允许<br>glIsList 检测显示列表的存在<br>glIsTexture 确定一个名字对应一个纹理<br>glLightf,glLighti,glLightfv,glLightiv 设置光源参数<br>glLightModelf,glLightModeli,glLightModelfv,glLightModeliv 设置光线模型参数<br>glLineStipple 设定线点绘图案<br>glLineWidth 设定光栅线段的宽<br>glListBase 为 glcallList 设定显示列表的基础<br>glLoadIdentity 用恒等矩阵替换当前矩阵<br>glLoadMatrixd,glLoadMatrif 用一个任意矩阵替换当前矩阵<br>glLoadName 将一个名字调入名字堆栈<br>glLogicOp 为色彩索引渲染定义一个逻辑像素操作<br>glMap1d,glMap1f 定义一个一维求值程序<br>glMap2d,glMap2f 定义一个二维求值程序<br>glMapGrid1d,glMapGrid1f,glMapgrid2d,glMapGrid2f 定义一个一维或二维网 格<br>glMaterialf,glMateriali,glMateriafv,glMaterialiv 为光照模型定义材质参数<br>glMatrixMode 定义哪一个矩阵是当前矩阵<br>glMultMatrixd,glMultMatrixf 用当前矩阵与任意矩阵相乘<br>glNewList,glEndList 创建或替换一个显示列表<br>glNormal 设定当前顶点法向<br>glNormalPointer 设定一个法向数组<br>glOrtho 用垂直矩阵与当前矩阵相乘<br>glPassThrough 在反馈缓冲区做记号<br>glPixelMapfv,glPixelMapuiv,glPixelMapusv 设定像素交换图<br>glPixelStoref,glpixelStorei 设定像素存储模式<br>glPixelTransferf,glPixelTransferi 设定像素存储模式<br>glPixelZoom 设定像素缩放因数<br>glPointSize 设定光栅点的直径<br>glPolygonMode 选择一个多边形的光栅模式<br>glPolygonOffset 设定 OpenGL 用于计算深度值的比例和单元<br>glPolygonStipple 设定多边形填充图案<br>glPrioritizeTextures 设定纹理固定的优先级<br>glPushAttrib,glPopAttrib 属性堆栈的压入和弹出操作<br>glPushClientAttrib,glPopClientAttrib 在客户属性堆栈存储和恢复客户状态值<br>glPushmatrix,glPopMatrix 矩阵堆栈的压入和弹出操作<br>glPushName,glPopName 名字堆栈的压入和弹出操作<br>glRasterPos 定义像素操作的光栅位置<br>glreadBuffer 为像素选择一个源色彩缓冲区<br>glReadPixels 从帧缓冲区读取一组数据<br>glRectd,glRectf,glRecti,glRects,glRectdv,glRectfv,glRectiv,glRectsv 绘制一个三 角形<br>glRenderMode 定义光栅模式<br>glRotated,glRotatef 将旋转矩阵与当前矩阵相乘<br>glScaled,glScalef 将一般的比例矩阵与当前矩阵相乘<br>glScissor 定义裁减框<br>glSelectBuffer 为选择模式值建立一个缓冲区<br>glShadeModel 选择平直或平滑着色<br>glStencilFunc 为模板测试设置功能和参照值<br>glStencilMask 控制在模板面写单独的位<br>glStencilOp 设置激活模式测试<br>glTexCoord 设置当前纹理坐标<br>glTexCoordPointer 定义一个纹理坐标数组<br>glTexEnvf,glTexEnvi,glTexEnvfv,glTexEnviv 设定纹理坐标环境参数<br>glTexGend,glTexgenf,glTexGendv,glTexGenfv,glTexGeniv 控制纹理坐标的生成<br>glTexImage1D 定义一个一维的纹理图象<br>glTexImage2D 定义一个二维的纹理图<br>glTexParameterf,glTexParameteri,glTexParameterfv,glTexParameteriv 设置纹理参数<br>glTexSubImage1D 定义一个存在的一维纹理图像的一部分,但不能定义新的纹理<br>glTexSubImage2D 定义一个存在的二维纹理图像的一部分,但不能定义新的纹理<br>glTranslated,glTranslatef 将变换矩阵与当前矩阵相乘<br>glVertex 定义一个顶点<br>glVertexPointer 设定一个顶点数据数组<br>glViewport 设置视窗</p>\n","site":{"data":{"style":""}},"length":6241,"excerpt":"<h2 id=\"1，GL常用\"><a href=\"#1，GL常用\" class=\"headerlink\" title=\"1，GL常用\"></a>1，GL常用</h2><h3 id=\"1-1-GL-BLEND\"><a href=\"#1-1-GL-BLEND\" class=\"headerlink\" title=\"1.1.GL_BLEND\"></a>1.1.GL_BLEND</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//开启混合，绘制带有透明度的纹理</span></span><br><span class=\"line\">glEnable(GL_BLEND);<span class=\"comment\">//开启混合</span></span><br><span class=\"line\">glDisable(GL_DEPTH_TEST);<span class=\"comment\">//关闭深度缓冲区，避免因alpha通道差异导致带透明度的纹理取消绘制</span></span><br><span class=\"line\">glBlendFunc(GL_ONE_MINUS_DST_ALPHA, GL_DST_ALPHA);<span class=\"comment\">//设置混合方式（四选一）</span></span><br><span class=\"line\"><span class=\"comment\">//glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA);</span></span><br><span class=\"line\"><span class=\"comment\">//glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></span><br><span class=\"line\"><span class=\"comment\">//glBlendFunc(GL_DST_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span></span><br><span class=\"line\">gldisable(GL_BLEND);<span class=\"comment\">//关闭混合</span></span><br></pre></td></tr></table></figure>","more":"<h3 id=\"1-2-GL-DEPTH-TEST\"><a href=\"#1-2-GL-DEPTH-TEST\" class=\"headerlink\" title=\"1.2.GL_DEPTH_TEST\"></a>1.2.GL_DEPTH_TEST</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_DEPTH_TEST);</span><br><span class=\"line\"><span class=\"number\">1.</span>启用了之后，OpenGL在绘制的时候就会检查，当前像素前面是否有别的像素，如果别的像素挡道了它，那它就不会绘制，也就是说，OpenGL就只绘制最前面的一层。</span><br><span class=\"line\"><span class=\"number\">2.</span>如果需要绘制带有透明度的纹理，则必须关闭深度缓冲区的检测</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-glClearColor-amp-glClear\"><a href=\"#1-3-glClearColor-amp-glClear\" class=\"headerlink\" title=\"1.3.glClearColor&amp;glClear()\"></a>1.3.glClearColor&amp;glClear()</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glClearColor(<span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>);<span class=\"comment\">//(0.75f, 0.75f, 0.75f, 0.0f)</span></span><br><span class=\"line\">glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); <span class=\"comment\">// (or whatever buffer you want to clear)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>glClearColor只起到Set的作用，并不Clear任何！glClearColor的作用是，指定刷新颜色缓冲区时所用的颜色。所以，完成一个刷新过程是要 glClearColor(COLOR) 与 glClear(GL_COLOR_BUFFER_BIT) 配合使用。</span><br><span class=\"line\"><span class=\"number\">2.</span>glClear(GL_COLOR_BUFFER_BIT);glClear清除颜色缓冲区的作用是，防止缓冲区中原有的颜色信息影响本次绘图（注意！即使认为可以直接覆盖原值，也是有可能会影响的），当绘图区域为整个窗口时，就是通常看到的，颜色缓冲区的清除值就是窗口的背景颜色。所以，这两条清除指令并不是必须的：比如对于静态画面只需要设置一次，比如不需要背景色/背景色为白色。</span><br><span class=\"line\"><span class=\"number\">3.</span> glClear 比手动涂抹一个背景画布效率高且省力，所以通常使用这种方式。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-GL-SCISSOR-TEST\"><a href=\"#1-4-GL-SCISSOR-TEST\" class=\"headerlink\" title=\"1.4.GL_SCISSOR_TEST\"></a>1.4.GL_SCISSOR_TEST</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">//清空指定区域颜色及深度\t</span></span><br><span class=\"line\">\tglEnable(GL_SCISSOR_TEST);<span class=\"comment\">//开启剪裁测试</span></span><br><span class=\"line\">\tglScissor(window.x, window.y, window.width, window.height);<span class=\"comment\">//剪裁测试的区域</span></span><br><span class=\"line\">\tglClearColor(<span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>);<span class=\"comment\">//纯黑色//(0.75f, 0.75f, 0.75f, 0.0f)灰色</span></span><br><span class=\"line\">\tglClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT); <span class=\"comment\">// (or whatever buffer you want to clear)</span></span><br><span class=\"line\">\tglDisable(GL_SCISSOR_TEST);<span class=\"comment\">//关闭剪裁测试</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"number\">1.</span>剪裁测试用于限制绘制区域。区域内的像素，将被绘制修改。区域外的像素，将不会被修改。</span><br><span class=\"line\"><span class=\"number\">2.</span>glScissor以左下角为坐标原点(<span class=\"number\">0</span>,<span class=\"number\">0</span>)，而通常情况下，坐标系以屏幕左上角为坐标原点(<span class=\"number\">0</span>,<span class=\"number\">0</span>)。因此，需要转换一下。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-5-glCullFace-amp-GL-CULL-FACE\"><a href=\"#1-5-glCullFace-amp-GL-CULL-FACE\" class=\"headerlink\" title=\"1.5.glCullFace()&amp;GL_CULL_FACE\"></a>1.5.glCullFace()&amp;GL_CULL_FACE</h3><p>禁用多边形正面或者背面上的光照、阴影和颜色计算及操作，消除不必要的渲染计算 。 接受符号常量GL_FRONT、GL_BACK和GL_FRONT_AND_BACK。 默认值为GL_BACK<br>        如果mode的值为GL_FRONT_AND_BACK，那么多边形将不会被绘制到屏幕上，但其他图元如点和线还是会绘制到屏幕上的。 </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_CULL_FACE);<span class=\"comment\">//启用分面剔除,默认剔除功能是关闭的。</span></span><br><span class=\"line\">glCullFace(GL_BACK);<span class=\"comment\">//设置后向分面剔除</span></span><br><span class=\"line\">glFrontFace(GL_CCW);<span class=\"comment\">//设置逆时针多边形作为正面</span></span><br><span class=\"line\"></span><br><span class=\"line\">glDisable(GL_CULL_FACE);<span class=\"comment\">//关闭分面剔除</span></span><br><span class=\"line\">glCullFace(GL_BACK);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-6-glFrontFace\"><a href=\"#1-6-glFrontFace\" class=\"headerlink\" title=\"1.6.glFrontFace();\"></a>1.6.glFrontFace();</h3><p> 前面多边形的方向 。参数： GL_CW和GL_CCW。 默认值为GL_CCW。 </p>\n<p>如果一个虚构的对象的顶点是按照多边形内部顺时针的方向进行绘制的，那么可以称这个多边形基于窗口坐标的投影是顺时针的。反之，则为逆时针。<br>glFrontFace就是用来指定多边形在窗口坐标中的方向是逆时针还是顺时针的。GL_CCW说明逆时针多边形为正面，而GL_CW说明顺时针多边形为正面。默认是逆时针多边形为正面</p>\n<p>注： 在完全由不透明封闭表面组成的场景中，背面多边形从不可见。 消除这些不可见多边形具有加快图像呈现的明显优势。 </p>\n<h2 id=\"2、OpenGL核心函数库\"><a href=\"#2、OpenGL核心函数库\" class=\"headerlink\" title=\"2、OpenGL核心函数库\"></a>2、OpenGL核心函数库</h2><p>glAccum 操作累加缓冲区<br>glAddSwapHintRectWIN 定义一组被 SwapBuffers 拷贝的三角形<br>glAlphaFunc 允许设置 alpha 检测功能<br>glAreTexturesResident 决定特定的纹理对象是否常驻在纹理内存中<br>glArrayElement 定义一个被用于顶点渲染的数组成分<br>glBegin,glEnd 定义一个或一组原始的顶点<br>glBindTexture 允许建立一个绑定到目标纹理的有名称的纹理<br>glBitmap 绘制一个位图<br>glBlendFunc 特殊的像素算法<br>glCallList 执行一个显示列表<br>glCallLists 执行一列显示列表<br>glClear 用当前值清除缓冲区<br>GlClearAccum 为累加缓冲区指定用于清除的值<br>glClearColor 为色彩缓冲区指定用于清除的值<br>glClearDepth 为深度缓冲区指定用于清除的值<br>glClearStencil 为模板缓冲区指定用于清除的值<br>glClipPlane 定义被裁剪的一个平面几何体<br>glColor 设置当前色彩<br>glColorMask 允许或不允许写色彩组件帧缓冲区<br>glColorMaterial 使一个材质色彩指向当前的色彩<br>glColorPointer 定义一列色彩<br>glColorTableEXT 定义目的一个调色板纹理的调色板的格式和尺寸<br>glColorSubTableEXT 定义目的纹理的调色板的一部分被替换<br>glCopyPixels 拷贝帧缓冲区里的像素<br>glCopyTexImage1D 将像素从帧缓冲区拷贝到一个单空间纹理图象中<br>glCopyTexImage2D 将像素从帧缓冲区拷贝到一个双空间纹理图象中<br>glCopyTexSubImage1D 从帧缓冲区拷贝一个单空间纹理的子图象<br>glCopyTexSubImage2D 从帧缓冲区拷贝一个双空间纹理的子图象<br>glCullFace 定义前面或后面是否能被精选<br>glDeleteLists 删除相邻一组显示列表<br>glDeleteTextures 删除命名的纹理<br>glDepthFunc 定义用于深度缓冲区对照的数据<br>glDepthMask 允许或不允许写入深度缓冲区<br>glDepthRange 定义 z 值从标准的设备坐标映射到窗口坐标<br>glDrawArrays 定义渲染多个图元<br>glDrawBuffer 定义选择哪个色彩缓冲区被绘制<br>glDrawElements 渲染数组数据中的图元<br>glDrawPixels 将一组像素写入帧缓冲区<br>glEdgeFlag 定义一个边缘标志数组<br>glEdgeFlagPointer 定义一个边缘标志数组<br>glEnable, glDisable 打开或关闭 OpenGL 的特殊功能<br>glEnableClientState,glDisableClientState 分别打开或关闭数组<br>glEvalCoord 求解一维和二维贴图<br>glEvalMesh1,glEvalMesh2 求解一维和二维点或线的网格<br>glEvalPoint1,glEvalPoint2 生成及求解一个网格中的单点<br>glFeedbackBuffer 控制反馈模式<br>glFinish 等待直到 OpenGL 执行结束<br>glFlush 在有限的时间里强制 OpenGL 的执行<br>glFogf,glFogi,glFogfv,glFogiv 定义雾参数<br>glFrontFace 定义多边形的前面和背面<br>glFrustum 当前矩阵乘上透视矩阵<br>glGenLists 生成一组空的连续的显示列表<br>glGenTextures 生成纹理名称<br>glGetBooleanv,glGetDoublev,glGetFloatv,glGetIntegerv 返回值或所选参数值<br>glGetClipPlane 返回特定裁减面的系数<br>glGetColorTableEXT 从当前目标纹理调色板得到颜色表数据<br>glGetColorTableParameterfvEXT,glGetColorTableParameterivEXT 从颜色表中 得到调色板参数<br>glGetError 返回错误消息<br>glGetLightfv,glGetLightiv 返回光源参数值<br>glGetMapdv,glGetMapfv,glGetMapiv 返回求值程序参数<br>glGetMaterialfv,glGetMaterialiv 返回材质参数<br>glGetPixelMapfv,glGetpixelMapuiv,glGetpixelMapusv 返回特定的像素图<br>glGetPointerv 返回顶点数据数组的地址<br>glGetPolygonStipple 返回多边形的点图案<br>glGetString 返回描述当前 OpenGl 连接的字符串<br>glGetTexEnvfv 返回纹理环境参数<br>glGetTexGendv,glGetTexGenfv,glGetTexGeniv 返回纹理坐标生成参数<br>glGetTexImage 返回一个纹理图象<br>glGetTexLevelParameterfv,glGetTexLevelParameteriv 返回特定的纹理参数的 细节级别<br>glGetTexParameterfv,glGetTexParameteriv 返回纹理参数值<br>glHint 定义实现特殊的线索<br>glIndex 建立当前的色彩索引<br>glIndexMask 控制写色彩索引缓冲区里的单独位<br>glIndexPointer 定义一个颜色索引数组<br>glInitName 初始化名字堆栈<br>glInterleavedArrays 同时定义和允许几个在一个大的数组集合里的交替数组<br>glIsEnabled 定义性能是否被允许<br>glIsList 检测显示列表的存在<br>glIsTexture 确定一个名字对应一个纹理<br>glLightf,glLighti,glLightfv,glLightiv 设置光源参数<br>glLightModelf,glLightModeli,glLightModelfv,glLightModeliv 设置光线模型参数<br>glLineStipple 设定线点绘图案<br>glLineWidth 设定光栅线段的宽<br>glListBase 为 glcallList 设定显示列表的基础<br>glLoadIdentity 用恒等矩阵替换当前矩阵<br>glLoadMatrixd,glLoadMatrif 用一个任意矩阵替换当前矩阵<br>glLoadName 将一个名字调入名字堆栈<br>glLogicOp 为色彩索引渲染定义一个逻辑像素操作<br>glMap1d,glMap1f 定义一个一维求值程序<br>glMap2d,glMap2f 定义一个二维求值程序<br>glMapGrid1d,glMapGrid1f,glMapgrid2d,glMapGrid2f 定义一个一维或二维网 格<br>glMaterialf,glMateriali,glMateriafv,glMaterialiv 为光照模型定义材质参数<br>glMatrixMode 定义哪一个矩阵是当前矩阵<br>glMultMatrixd,glMultMatrixf 用当前矩阵与任意矩阵相乘<br>glNewList,glEndList 创建或替换一个显示列表<br>glNormal 设定当前顶点法向<br>glNormalPointer 设定一个法向数组<br>glOrtho 用垂直矩阵与当前矩阵相乘<br>glPassThrough 在反馈缓冲区做记号<br>glPixelMapfv,glPixelMapuiv,glPixelMapusv 设定像素交换图<br>glPixelStoref,glpixelStorei 设定像素存储模式<br>glPixelTransferf,glPixelTransferi 设定像素存储模式<br>glPixelZoom 设定像素缩放因数<br>glPointSize 设定光栅点的直径<br>glPolygonMode 选择一个多边形的光栅模式<br>glPolygonOffset 设定 OpenGL 用于计算深度值的比例和单元<br>glPolygonStipple 设定多边形填充图案<br>glPrioritizeTextures 设定纹理固定的优先级<br>glPushAttrib,glPopAttrib 属性堆栈的压入和弹出操作<br>glPushClientAttrib,glPopClientAttrib 在客户属性堆栈存储和恢复客户状态值<br>glPushmatrix,glPopMatrix 矩阵堆栈的压入和弹出操作<br>glPushName,glPopName 名字堆栈的压入和弹出操作<br>glRasterPos 定义像素操作的光栅位置<br>glreadBuffer 为像素选择一个源色彩缓冲区<br>glReadPixels 从帧缓冲区读取一组数据<br>glRectd,glRectf,glRecti,glRects,glRectdv,glRectfv,glRectiv,glRectsv 绘制一个三 角形<br>glRenderMode 定义光栅模式<br>glRotated,glRotatef 将旋转矩阵与当前矩阵相乘<br>glScaled,glScalef 将一般的比例矩阵与当前矩阵相乘<br>glScissor 定义裁减框<br>glSelectBuffer 为选择模式值建立一个缓冲区<br>glShadeModel 选择平直或平滑着色<br>glStencilFunc 为模板测试设置功能和参照值<br>glStencilMask 控制在模板面写单独的位<br>glStencilOp 设置激活模式测试<br>glTexCoord 设置当前纹理坐标<br>glTexCoordPointer 定义一个纹理坐标数组<br>glTexEnvf,glTexEnvi,glTexEnvfv,glTexEnviv 设定纹理坐标环境参数<br>glTexGend,glTexgenf,glTexGendv,glTexGenfv,glTexGeniv 控制纹理坐标的生成<br>glTexImage1D 定义一个一维的纹理图象<br>glTexImage2D 定义一个二维的纹理图<br>glTexParameterf,glTexParameteri,glTexParameterfv,glTexParameteriv 设置纹理参数<br>glTexSubImage1D 定义一个存在的一维纹理图像的一部分,但不能定义新的纹理<br>glTexSubImage2D 定义一个存在的二维纹理图像的一部分,但不能定义新的纹理<br>glTranslated,glTranslatef 将变换矩阵与当前矩阵相乘<br>glVertex 定义一个顶点<br>glVertexPointer 设定一个顶点数据数组<br>glViewport 设置视窗</p>"},{"title":"OpenGL ES 2.0 API","date":"2023-04-14T13:46:11.000Z","comments":0,"description":null,"typora-root-url":"4-4-OpenGL ES 2.0 API","_content":"\n## OpenGL ES 2.0 API\n\n<!--more--> \n\n| glActiveTexture                       |      |\n| ------------------------------------- | ---- |\n| glAttachShader                        |      |\n| glBindAttribLocation                  |      |\n| glBindBuffer                          |      |\n| glBindFramebuffer                     |      |\n| glBindRenderbuffer                    |      |\n| glBindTexture                         |      |\n| glBlendColor                          |      |\n| glBlendEquation                       |      |\n| glBlendEquationSeparate               |      |\n| glBlendFunc                           |      |\n| glBlendFuncSeparate                   |      |\n| glBufferData                          |      |\n| glBufferSubData                       |      |\n| glCheckFramebufferStatus              |      |\n| glClear                               |      |\n| glClearColor                          |      |\n| glClearDepthf                         |      |\n| glClearStencil                        |      |\n| glColorMask                           |      |\n| glCompileShader                       |      |\n| glCompressedTexImage2D                |      |\n| glCompressedTexSubImage2D             |      |\n| glCopyTexImage2D                      |      |\n| glCopyTexSubImage2D                   |      |\n| glCreateProgram                       |      |\n| glCreateShader                        |      |\n| glCullFace                            |      |\n| glDeleteBuffers<                      |      |\n| glDeleteFramebuffers                  |      |\n| glDeleteProgram                       |      |\n| glDeleteRenderbuffers<                |      |\n| glDeleteShader<                       |      |\n| glDeleteTextures                      |      |\n| glDepthFunc                           |      |\n| glDepthMask                           |      |\n| glDepthRangef                         |      |\n| glDetachShader                        |      |\n| glDisable                             |      |\n| glDisableVertexAttribArray            |      |\n| glDrawArrays                          |      |\n| glDrawElements                        |      |\n| glEnable                              |      |\n| glEnableVertexAttribArray             |      |\n| glFinish                              |      |\n| glFlush                               |      |\n| glFramebufferRenderbuffer             |      |\n| glFramebufferTexture2D                |      |\n| glFrontFace                           |      |\n| glGenBuffers                          |      |\n| glGenFramebuffers                     |      |\n| glGenRenderbuffers                    |      |\n| glGenTextures                         |      |\n| glGenerateMipmap                      |      |\n| glGet                                 |      |\n| glGetActiveAttrib                     |      |\n| glGetActiveUniform                    |      |\n| glGetAttachedShaders                  |      |\n| glGetAttribLocation                   |      |\n| glGetBufferParameteriv                |      |\n| glGetError                            |      |\n| glGetFramebufferAttachmentParameteriv |      |\n| glGetProgramInfoLog                   |      |\n| glGetProgramiv                        |      |\n| glGetRenderbufferParameteriv          |      |\n| glGetShaderInfoLog                    |      |\n| glGetShaderPrecisionFormat            |      |\n| glGetShaderSource                     |      |\n| glGetShaderiv                         |      |\n| glGetString                           |      |\n| glGetTexParameter                     |      |\n| glGetUniform                          |      |\n| glGetUniformLocation                  |      |\n| glGetVertexAttrib                     |      |\n| glGetVertexAttribPointerv             |      |\n| glHint                                |      |\n| glIsBuffer                            |      |\n| glIsEnabled                           |      |\n| glIsFramebuffer                       |      |\n| glIsProgram                           |      |\n| glIsRenderbuffer                      |      |\n| glIsShader                            |      |\n| glIsTexture                           |      |\n| glLineWidth                           |      |\n| glLinkProgram                         |      |\n| glPixelStorei                         |      |\n| glPolygonOffset                       |      |\n| glReadPixels                          |      |\n| glReleaseShaderCompiler               |      |\n| glRenderbufferStorage                 |      |\n| glSampleCoverage                      |      |\n| glScissor                             |      |\n| glShaderBinary                        |      |\n| glShaderSource                        |      |\n| glStencilFunc                         |      |\n| glStencilFuncSeparate                 |      |\n| glStencilMask                         |      |\n| glStencilMaskSeparate                 |      |\n| glStencilOp                           |      |\n| glStencilOpSeparate                   |      |\n| glTexImage2D                          |      |\n| glTexParameter                        |      |\n| glTexSubImage2D                       |      |\n| glUniform                             |      |\n| glUseProgram                          |      |\n| glValidateProgram                     |      |\n| glVertexAttrib                        |      |\n| glVertexAttribPointer                 |      |\n| glViewport                            |      |\n\n","source":"_posts/4-4-OpenGL ES 2.0 API.md","raw":"---\ntitle: OpenGL ES 2.0 API\ndate: 2023-4-14 21:46:11\ncategories: 笔记\ntags: [嵌入式,OpenGL]\ncomments: false\ndescription:\ntypora-root-url: 4-4-OpenGL ES 2.0 API\n\n---\n\n## OpenGL ES 2.0 API\n\n<!--more--> \n\n| glActiveTexture                       |      |\n| ------------------------------------- | ---- |\n| glAttachShader                        |      |\n| glBindAttribLocation                  |      |\n| glBindBuffer                          |      |\n| glBindFramebuffer                     |      |\n| glBindRenderbuffer                    |      |\n| glBindTexture                         |      |\n| glBlendColor                          |      |\n| glBlendEquation                       |      |\n| glBlendEquationSeparate               |      |\n| glBlendFunc                           |      |\n| glBlendFuncSeparate                   |      |\n| glBufferData                          |      |\n| glBufferSubData                       |      |\n| glCheckFramebufferStatus              |      |\n| glClear                               |      |\n| glClearColor                          |      |\n| glClearDepthf                         |      |\n| glClearStencil                        |      |\n| glColorMask                           |      |\n| glCompileShader                       |      |\n| glCompressedTexImage2D                |      |\n| glCompressedTexSubImage2D             |      |\n| glCopyTexImage2D                      |      |\n| glCopyTexSubImage2D                   |      |\n| glCreateProgram                       |      |\n| glCreateShader                        |      |\n| glCullFace                            |      |\n| glDeleteBuffers<                      |      |\n| glDeleteFramebuffers                  |      |\n| glDeleteProgram                       |      |\n| glDeleteRenderbuffers<                |      |\n| glDeleteShader<                       |      |\n| glDeleteTextures                      |      |\n| glDepthFunc                           |      |\n| glDepthMask                           |      |\n| glDepthRangef                         |      |\n| glDetachShader                        |      |\n| glDisable                             |      |\n| glDisableVertexAttribArray            |      |\n| glDrawArrays                          |      |\n| glDrawElements                        |      |\n| glEnable                              |      |\n| glEnableVertexAttribArray             |      |\n| glFinish                              |      |\n| glFlush                               |      |\n| glFramebufferRenderbuffer             |      |\n| glFramebufferTexture2D                |      |\n| glFrontFace                           |      |\n| glGenBuffers                          |      |\n| glGenFramebuffers                     |      |\n| glGenRenderbuffers                    |      |\n| glGenTextures                         |      |\n| glGenerateMipmap                      |      |\n| glGet                                 |      |\n| glGetActiveAttrib                     |      |\n| glGetActiveUniform                    |      |\n| glGetAttachedShaders                  |      |\n| glGetAttribLocation                   |      |\n| glGetBufferParameteriv                |      |\n| glGetError                            |      |\n| glGetFramebufferAttachmentParameteriv |      |\n| glGetProgramInfoLog                   |      |\n| glGetProgramiv                        |      |\n| glGetRenderbufferParameteriv          |      |\n| glGetShaderInfoLog                    |      |\n| glGetShaderPrecisionFormat            |      |\n| glGetShaderSource                     |      |\n| glGetShaderiv                         |      |\n| glGetString                           |      |\n| glGetTexParameter                     |      |\n| glGetUniform                          |      |\n| glGetUniformLocation                  |      |\n| glGetVertexAttrib                     |      |\n| glGetVertexAttribPointerv             |      |\n| glHint                                |      |\n| glIsBuffer                            |      |\n| glIsEnabled                           |      |\n| glIsFramebuffer                       |      |\n| glIsProgram                           |      |\n| glIsRenderbuffer                      |      |\n| glIsShader                            |      |\n| glIsTexture                           |      |\n| glLineWidth                           |      |\n| glLinkProgram                         |      |\n| glPixelStorei                         |      |\n| glPolygonOffset                       |      |\n| glReadPixels                          |      |\n| glReleaseShaderCompiler               |      |\n| glRenderbufferStorage                 |      |\n| glSampleCoverage                      |      |\n| glScissor                             |      |\n| glShaderBinary                        |      |\n| glShaderSource                        |      |\n| glStencilFunc                         |      |\n| glStencilFuncSeparate                 |      |\n| glStencilMask                         |      |\n| glStencilMaskSeparate                 |      |\n| glStencilOp                           |      |\n| glStencilOpSeparate                   |      |\n| glTexImage2D                          |      |\n| glTexParameter                        |      |\n| glTexSubImage2D                       |      |\n| glUniform                             |      |\n| glUseProgram                          |      |\n| glValidateProgram                     |      |\n| glVertexAttrib                        |      |\n| glVertexAttribPointer                 |      |\n| glViewport                            |      |\n\n","slug":"4-4-OpenGL ES 2.0 API","published":1,"updated":"2023-04-14T13:46:35.740Z","_id":"clgglj63u0001hoobbl2j93xk","layout":"post","photos":[],"link":"","content":"<h2 id=\"OpenGL-ES-2-0-API\"><a href=\"#OpenGL-ES-2-0-API\" class=\"headerlink\" title=\"OpenGL ES 2.0 API\"></a>OpenGL ES 2.0 API</h2><span id=\"more\"></span> \n\n<table>\n<thead>\n<tr>\n<th>glActiveTexture</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>glAttachShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindAttribLocation</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindBuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindFramebuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindRenderbuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindTexture</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendColor</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendEquation</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendEquationSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendFunc</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendFuncSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glBufferData</td>\n<td></td>\n</tr>\n<tr>\n<td>glBufferSubData</td>\n<td></td>\n</tr>\n<tr>\n<td>glCheckFramebufferStatus</td>\n<td></td>\n</tr>\n<tr>\n<td>glClear</td>\n<td></td>\n</tr>\n<tr>\n<td>glClearColor</td>\n<td></td>\n</tr>\n<tr>\n<td>glClearDepthf</td>\n<td></td>\n</tr>\n<tr>\n<td>glClearStencil</td>\n<td></td>\n</tr>\n<tr>\n<td>glColorMask</td>\n<td></td>\n</tr>\n<tr>\n<td>glCompileShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glCompressedTexImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glCompressedTexSubImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glCopyTexImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glCopyTexSubImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glCreateProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glCreateShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glCullFace</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteBuffers&lt;</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteFramebuffers</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteRenderbuffers&lt;</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteShader&lt;</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteTextures</td>\n<td></td>\n</tr>\n<tr>\n<td>glDepthFunc</td>\n<td></td>\n</tr>\n<tr>\n<td>glDepthMask</td>\n<td></td>\n</tr>\n<tr>\n<td>glDepthRangef</td>\n<td></td>\n</tr>\n<tr>\n<td>glDetachShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glDisable</td>\n<td></td>\n</tr>\n<tr>\n<td>glDisableVertexAttribArray</td>\n<td></td>\n</tr>\n<tr>\n<td>glDrawArrays</td>\n<td></td>\n</tr>\n<tr>\n<td>glDrawElements</td>\n<td></td>\n</tr>\n<tr>\n<td>glEnable</td>\n<td></td>\n</tr>\n<tr>\n<td>glEnableVertexAttribArray</td>\n<td></td>\n</tr>\n<tr>\n<td>glFinish</td>\n<td></td>\n</tr>\n<tr>\n<td>glFlush</td>\n<td></td>\n</tr>\n<tr>\n<td>glFramebufferRenderbuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glFramebufferTexture2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glFrontFace</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenBuffers</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenFramebuffers</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenRenderbuffers</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenTextures</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenerateMipmap</td>\n<td></td>\n</tr>\n<tr>\n<td>glGet</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetActiveAttrib</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetActiveUniform</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetAttachedShaders</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetAttribLocation</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetBufferParameteriv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetError</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetFramebufferAttachmentParameteriv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetProgramInfoLog</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetProgramiv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetRenderbufferParameteriv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetShaderInfoLog</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetShaderPrecisionFormat</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetShaderSource</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetShaderiv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetString</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetTexParameter</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetUniform</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetUniformLocation</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetVertexAttrib</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetVertexAttribPointerv</td>\n<td></td>\n</tr>\n<tr>\n<td>glHint</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsBuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsEnabled</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsFramebuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsRenderbuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsTexture</td>\n<td></td>\n</tr>\n<tr>\n<td>glLineWidth</td>\n<td></td>\n</tr>\n<tr>\n<td>glLinkProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glPixelStorei</td>\n<td></td>\n</tr>\n<tr>\n<td>glPolygonOffset</td>\n<td></td>\n</tr>\n<tr>\n<td>glReadPixels</td>\n<td></td>\n</tr>\n<tr>\n<td>glReleaseShaderCompiler</td>\n<td></td>\n</tr>\n<tr>\n<td>glRenderbufferStorage</td>\n<td></td>\n</tr>\n<tr>\n<td>glSampleCoverage</td>\n<td></td>\n</tr>\n<tr>\n<td>glScissor</td>\n<td></td>\n</tr>\n<tr>\n<td>glShaderBinary</td>\n<td></td>\n</tr>\n<tr>\n<td>glShaderSource</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilFunc</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilFuncSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilMask</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilMaskSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilOp</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilOpSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glTexImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glTexParameter</td>\n<td></td>\n</tr>\n<tr>\n<td>glTexSubImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glUniform</td>\n<td></td>\n</tr>\n<tr>\n<td>glUseProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glValidateProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glVertexAttrib</td>\n<td></td>\n</tr>\n<tr>\n<td>glVertexAttribPointer</td>\n<td></td>\n</tr>\n<tr>\n<td>glViewport</td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{"style":""}},"length":1710,"excerpt":"<h2 id=\"OpenGL-ES-2-0-API\"><a href=\"#OpenGL-ES-2-0-API\" class=\"headerlink\" title=\"OpenGL ES 2.0 API\"></a>OpenGL ES 2.0 API</h2>","more":"<table>\n<thead>\n<tr>\n<th>glActiveTexture</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>glAttachShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindAttribLocation</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindBuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindFramebuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindRenderbuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glBindTexture</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendColor</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendEquation</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendEquationSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendFunc</td>\n<td></td>\n</tr>\n<tr>\n<td>glBlendFuncSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glBufferData</td>\n<td></td>\n</tr>\n<tr>\n<td>glBufferSubData</td>\n<td></td>\n</tr>\n<tr>\n<td>glCheckFramebufferStatus</td>\n<td></td>\n</tr>\n<tr>\n<td>glClear</td>\n<td></td>\n</tr>\n<tr>\n<td>glClearColor</td>\n<td></td>\n</tr>\n<tr>\n<td>glClearDepthf</td>\n<td></td>\n</tr>\n<tr>\n<td>glClearStencil</td>\n<td></td>\n</tr>\n<tr>\n<td>glColorMask</td>\n<td></td>\n</tr>\n<tr>\n<td>glCompileShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glCompressedTexImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glCompressedTexSubImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glCopyTexImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glCopyTexSubImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glCreateProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glCreateShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glCullFace</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteBuffers&lt;</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteFramebuffers</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteRenderbuffers&lt;</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteShader&lt;</td>\n<td></td>\n</tr>\n<tr>\n<td>glDeleteTextures</td>\n<td></td>\n</tr>\n<tr>\n<td>glDepthFunc</td>\n<td></td>\n</tr>\n<tr>\n<td>glDepthMask</td>\n<td></td>\n</tr>\n<tr>\n<td>glDepthRangef</td>\n<td></td>\n</tr>\n<tr>\n<td>glDetachShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glDisable</td>\n<td></td>\n</tr>\n<tr>\n<td>glDisableVertexAttribArray</td>\n<td></td>\n</tr>\n<tr>\n<td>glDrawArrays</td>\n<td></td>\n</tr>\n<tr>\n<td>glDrawElements</td>\n<td></td>\n</tr>\n<tr>\n<td>glEnable</td>\n<td></td>\n</tr>\n<tr>\n<td>glEnableVertexAttribArray</td>\n<td></td>\n</tr>\n<tr>\n<td>glFinish</td>\n<td></td>\n</tr>\n<tr>\n<td>glFlush</td>\n<td></td>\n</tr>\n<tr>\n<td>glFramebufferRenderbuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glFramebufferTexture2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glFrontFace</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenBuffers</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenFramebuffers</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenRenderbuffers</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenTextures</td>\n<td></td>\n</tr>\n<tr>\n<td>glGenerateMipmap</td>\n<td></td>\n</tr>\n<tr>\n<td>glGet</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetActiveAttrib</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetActiveUniform</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetAttachedShaders</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetAttribLocation</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetBufferParameteriv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetError</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetFramebufferAttachmentParameteriv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetProgramInfoLog</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetProgramiv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetRenderbufferParameteriv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetShaderInfoLog</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetShaderPrecisionFormat</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetShaderSource</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetShaderiv</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetString</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetTexParameter</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetUniform</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetUniformLocation</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetVertexAttrib</td>\n<td></td>\n</tr>\n<tr>\n<td>glGetVertexAttribPointerv</td>\n<td></td>\n</tr>\n<tr>\n<td>glHint</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsBuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsEnabled</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsFramebuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsRenderbuffer</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsShader</td>\n<td></td>\n</tr>\n<tr>\n<td>glIsTexture</td>\n<td></td>\n</tr>\n<tr>\n<td>glLineWidth</td>\n<td></td>\n</tr>\n<tr>\n<td>glLinkProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glPixelStorei</td>\n<td></td>\n</tr>\n<tr>\n<td>glPolygonOffset</td>\n<td></td>\n</tr>\n<tr>\n<td>glReadPixels</td>\n<td></td>\n</tr>\n<tr>\n<td>glReleaseShaderCompiler</td>\n<td></td>\n</tr>\n<tr>\n<td>glRenderbufferStorage</td>\n<td></td>\n</tr>\n<tr>\n<td>glSampleCoverage</td>\n<td></td>\n</tr>\n<tr>\n<td>glScissor</td>\n<td></td>\n</tr>\n<tr>\n<td>glShaderBinary</td>\n<td></td>\n</tr>\n<tr>\n<td>glShaderSource</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilFunc</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilFuncSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilMask</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilMaskSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilOp</td>\n<td></td>\n</tr>\n<tr>\n<td>glStencilOpSeparate</td>\n<td></td>\n</tr>\n<tr>\n<td>glTexImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glTexParameter</td>\n<td></td>\n</tr>\n<tr>\n<td>glTexSubImage2D</td>\n<td></td>\n</tr>\n<tr>\n<td>glUniform</td>\n<td></td>\n</tr>\n<tr>\n<td>glUseProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glValidateProgram</td>\n<td></td>\n</tr>\n<tr>\n<td>glVertexAttrib</td>\n<td></td>\n</tr>\n<tr>\n<td>glVertexAttribPointer</td>\n<td></td>\n</tr>\n<tr>\n<td>glViewport</td>\n<td></td>\n</tr>\n</tbody></table>"},{"title":"OpenGl ES---FBO","date":"2023-04-14T13:47:11.000Z","comments":0,"description":null,"typora-root-url":"4-5-FBO","_content":"\n# OpenGl ES---FBO\n\n（Frame Buffer Object帧缓存对象）\n\n## Overview\n\n在OpenGL渲染管线中，几何数据和纹理经过多次转化和多次测试，最后以二维像素的形式显示在屏幕上。OpenGL管线的最终渲染目的地被称作帧缓存（framebuffer）。帧缓冲是一些二维数组和OpenG所使用的存储区的集合：颜色缓存、深度缓存、模板缓存和累计缓存。一般情况下，帧缓存完全由window系统生成和管理，由OpenGL使用。这个默认的帧缓存被称作“window系统生成”（window-system-provided）的帧缓存。\n\n<!--more-->\n\n在OpenGL扩展中，GL_EXT_framebuffer_object提供了一种创建额外的不能显示的帧缓存对象的接口。为了和默认的“window系统生成”的帧缓存区别，这种帧缓冲成为应用程序帧缓存（application-createdframebuffer）。通过使用帧缓存对象（FBO），OpenGL可以将显示输出到引用程序帧缓存对象，而不是传统的“window系统生成”帧缓存。而且，它完全受OpenGL控制。\n\n相似于window系统提供的帧缓存，一个FBO也包含一些存储颜色、深度和模板数据的区域。（注意：没有累积缓存）我们把FBO中这些逻辑缓存称之为“帧缓存关联图像”，它们是一些能够和一个帧缓存对象关联起来的二维数组像素。\n\n有两种类型的“帧缓存关联图像”：纹理图像（texture images）和渲染缓存图像（renderbuffer images）。如果纹理对象的图像数据关联到帧缓存，OpenGL执行的是“渲染到纹理”（render to texture）操作。如果渲染缓存的图像数据关联到帧缓存，OpenGL执行的是离线渲染（offscreen rendering）。\n\n这里要提到的是，渲染缓存对象是在GL_EXT_framebuffer_object扩展中定义的一种新的存储类型。在渲染过程中它被用作存储单幅二维图像。\n\n下面这幅图显示了帧缓存对象、纹理对象和渲染缓存对象之间的联系。多多个纹理对象或者渲染缓存对象能够通过关联点关联到一个帧缓存对象上。\n\n![](25.png)\n\n在一个帧缓存对象中有多个颜色关联点（GL_COLOR_ATTACHMENT0_EXT,...,GL_COLOR_ATTACHMENTn_EXT），一个深度关联点（GL_DEPTH_ATTACHMENT_EXT），和一个模板关联点（GL_STENCIL_ATTACHMENT_EXT）。每个FBO中至少有一个颜色关联点，其数目与实体显卡相关。可以通过GL_MAX_COLOR_ATTACHMENTS_EXT来查询颜色关联点的最大数目。FBO有多个颜色关联点的原因是这样可以同时将颜色而换成渲染到多个FBO关联区。这种“多渲染目标”（multiple rendertargets,MRT）可以通过GL_ARB_draw_buffers扩展实现。需要注意的是：FBO本身并没有任何图像存储区，只有多个关联点。\n\nFBO提供了一种高效的切换机制；将前面的帧缓存关联图像从FBO分离，然后把新的帧缓存关联图像关联到FBO。在帧缓存关联图像之间切换比在FBO之间切换要快得多。FBO提供了glFramebufferTexture2DEXT()来切换2D纹理对象和glFramebufferRenderbufferEXT()来切换渲染缓存对象。\n\n## 1、帧缓冲创建\n\n 使用glGenFrameBuffer函数来创建一个帧缓冲（FBO） \n\n```c\nGLuint framebuffer;\nglGenFramebuffers(1, &framebuffer);\nglBindFramebuffer(GL_FRAMEBUFFER, framebuffer);//绑定\nglBindFramebuffer(GL_FRAMEBUFFER, 0);//解绑定\n```\n\n绑定到GL_FRAMEBUFFER目标后，接下来所有的读、写帧缓冲的操作都会影响到当前绑定的帧缓冲。也可以把帧缓冲分开绑定到读或写目标上，分别使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER来做这件事。如果绑定到了GL_READ_FRAMEBUFFER，就能执行所有读取操作，像glReadPixels这样的函数使用了；绑定到GL_DRAW_FRAMEBUFFER上，就允许进行渲染、清空和其他的写入操作。大多数时候你不必分开用，通常绑定到GL_FRAMEBUFFER上就行。\n\n 如果要创建一个完整的帧缓冲，需要满足以下条件：\n\\- 至少包含一个附件（颜色、深度、或模板）；\n\\- 其中至少有一个颜色附件；\n\\- 附件要在附着之前创建好，并存储在内存中；\n\\- 每个缓冲应该有同样的样本。 \n\n 假如我们创建好一些附件之后，并已经附着到帧缓冲上了，那么接下来要对它进行检查，判断帧缓冲是否完整。\n\n```\nif(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)\n```\n\n 由于使用自定义的帧缓冲，渲染操作并不是对系统提供的默认的帧缓冲，所以并不会对屏幕上图像产生任何影响。如果要切回默认的帧缓冲，可以通过如下函数： \n\n```\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n```\n\n 当我们做完所有帧缓冲操作，不要忘记删除帧缓冲对象： \n\n```\nglDeleteFramebuffers(1, &framebuffer);\n```\n\n##  2、帧缓冲上可以附着的两种附件 \n\n### 2.1、纹理附件 \n\n纹理附件和通过图片加载的纹理类似，只不过这个纹理附加是通过渲染命令写入到纹理当中的，不是通过图片纹理得到的。\n\n```\nGLuint texBuffer;   \nglGenTextures(1, &texBuffer);\nglBindTexture(GL_TEXTURE_2D, texBuffer);\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, WIDTH, HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nglBindTexture(GL_TEXTURE_2D, 0);\n```\n\n\n\n### 2.2、渲染附件\n\n\n\n\n\n## 3、示例\n\n### 1，离屏渲染到2D纹理\n\n```c\n//--------------------1111111111111111----FBO初始化---------------------\n\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;\n\t\tglGenTextures(1,&eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglActiveTexture(GL_TEXTURE0);\n\t\tglBindTexture(GL_TEXTURE_2D, eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglTexImage2D(GL_TEXTURE_2D,0,GL_RGB,416,416,0,GL_RGB,GL_UNSIGNED_BYTE,NULL);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\n\t\tif(checkGlErrorState())\n\t\t{\t\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES id:%d GL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tglGenFramebuffers(1, &eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglGenRenderbuffers(1, &eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo->egiTexImage[dmaFbId].Depth_Fb);//\n\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo->egiTexImage[dmaFbId].Width, eglInfo->egiTexImage[dmaFbId].Height);\n\n\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D, eglInfo->egiTexImage[dmaFbId].Tex, 0);\n\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\n\t\tuint32_t glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n\t\tif(glStatus != GL_FRAMEBUFFER_COMPLETE) \n\t\t{\n\t\t\tBUG_ERR(\"glCheckFramebufferStatusOES Id:%d error 0x%x\",dmaFbId, glStatus);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\t\n\t\tglBindTexture(GL_TEXTURE_2D, 0);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER,0);\n//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------\nglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(window.x, window.y, window.width, window.height);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(416, 0, 416, 416);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_2D, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\n\teglSwapBuffers(eglInfo->egl_display, eglInfo->egl_surface);\n```\n\n### 2，离屏渲染到外部OES纹理\n\n```c\n//--------------------1111111111111111----FBO初始化---------------------\n\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;\n\t\tglGenTextures(1,&eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglActiveTexture(GL_TEXTURE0);\n\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t\tpfnglEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);\n\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\n\t\tif(checkGlErrorState())\n\t\t{\t\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES id:%d GL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tglGenFramebuffers(1, &eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglGenRenderbuffers(1, &eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo->egiTexImage[dmaFbId].Depth_Fb);//\n\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo->egiTexImage[dmaFbId].Width, eglInfo->egiTexImage[dmaFbId].Height);\n\n\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[dmaFbId].Tex, 0);\n\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\n\t\tuint32_t glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n\t\tif(glStatus != GL_FRAMEBUFFER_COMPLETE) \n\t\t{\n\t\t\tBUG_ERR(\"glCheckFramebufferStatusOES Id:%d error 0x%x\",dmaFbId, glStatus);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\n\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, 0);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER,0);\n//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------\nglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(window.x, window.y, window.width, window.height);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(416, 0, 416, 416);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, 0);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\n\teglSwapBuffers(eglInfo->egl_display, eglInfo->egl_surface);\n```\n\n### 3，离屏渲染2D或OES纹理（宏方式切换）\n\n```c\n\n//--------------------1111111111111111----FBO初始化---------------------\n\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;\n\n\t\tglGenTextures(1,&eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglActiveTexture(GL_TEXTURE0);\n\n\t#if FBO_TEXTURE\n\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[dmaFbId].Tex);\n\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t\tpfnglEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);\n\n\t#else\n\t\tglBindTexture(GL_TEXTURE_2D, eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglTexImage2D(GL_TEXTURE_2D,0,GL_RGB,416,416,0,GL_RGB,GL_UNSIGNED_BYTE,NULL);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t#endif\n\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\n\t\tif(checkGlErrorState())\n\t\t{\t\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES id:%d GL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tglGenFramebuffers(1, &eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[dmaFbId].Fb);\n\n\t\tglGenRenderbuffers(1, &eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo->egiTexImage[dmaFbId].Depth_Fb);//\n\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo->egiTexImage[dmaFbId].Width, eglInfo->egiTexImage[dmaFbId].Height);\n\n\n\t#if FBO_TEXTURE\n\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[dmaFbId].Tex, 0);\n\t#else\n\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D, eglInfo->egiTexImage[dmaFbId].Tex, 0);\n\t#endif\n\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\n\t\tuint32_t glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n\t\tif(glStatus != GL_FRAMEBUFFER_COMPLETE) \n\t\t{\n\t\t\tBUG_ERR(\"glCheckFramebufferStatusOES Id:%d error 0x%x\",dmaFbId, glStatus);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\t\n\t#if FBO_TEXTURE\n\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, 0);\n\t#else\n\t\tglBindTexture(GL_TEXTURE_2D, 0);\n\t#endif\n\n\t\tglBindFramebuffer(GL_FRAMEBUFFER,0);\n\n//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------\nglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);\n\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(window.x, window.y, window.width, window.height);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\n\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(416, 0, 416, 416);\n\n\t#if FBO_TEXTURE\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, 0);\n\n\t#else\n\n\t//2D纹理显示\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_2D, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\t#endif\n\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\n\teglSwapBuffers(eglInfo->egl_display, eglInfo->egl_surface);\n\n```\n\n","source":"_posts/4-5-FBO.md","raw":"---\ntitle: OpenGl ES---FBO\ndate: 2023-4-14 21:47:11\ncategories: 笔记\ntags: [嵌入式,OpenGL]\ncomments: false\ndescription:\ntypora-root-url: 4-5-FBO\n---\n\n# OpenGl ES---FBO\n\n（Frame Buffer Object帧缓存对象）\n\n## Overview\n\n在OpenGL渲染管线中，几何数据和纹理经过多次转化和多次测试，最后以二维像素的形式显示在屏幕上。OpenGL管线的最终渲染目的地被称作帧缓存（framebuffer）。帧缓冲是一些二维数组和OpenG所使用的存储区的集合：颜色缓存、深度缓存、模板缓存和累计缓存。一般情况下，帧缓存完全由window系统生成和管理，由OpenGL使用。这个默认的帧缓存被称作“window系统生成”（window-system-provided）的帧缓存。\n\n<!--more-->\n\n在OpenGL扩展中，GL_EXT_framebuffer_object提供了一种创建额外的不能显示的帧缓存对象的接口。为了和默认的“window系统生成”的帧缓存区别，这种帧缓冲成为应用程序帧缓存（application-createdframebuffer）。通过使用帧缓存对象（FBO），OpenGL可以将显示输出到引用程序帧缓存对象，而不是传统的“window系统生成”帧缓存。而且，它完全受OpenGL控制。\n\n相似于window系统提供的帧缓存，一个FBO也包含一些存储颜色、深度和模板数据的区域。（注意：没有累积缓存）我们把FBO中这些逻辑缓存称之为“帧缓存关联图像”，它们是一些能够和一个帧缓存对象关联起来的二维数组像素。\n\n有两种类型的“帧缓存关联图像”：纹理图像（texture images）和渲染缓存图像（renderbuffer images）。如果纹理对象的图像数据关联到帧缓存，OpenGL执行的是“渲染到纹理”（render to texture）操作。如果渲染缓存的图像数据关联到帧缓存，OpenGL执行的是离线渲染（offscreen rendering）。\n\n这里要提到的是，渲染缓存对象是在GL_EXT_framebuffer_object扩展中定义的一种新的存储类型。在渲染过程中它被用作存储单幅二维图像。\n\n下面这幅图显示了帧缓存对象、纹理对象和渲染缓存对象之间的联系。多多个纹理对象或者渲染缓存对象能够通过关联点关联到一个帧缓存对象上。\n\n![](25.png)\n\n在一个帧缓存对象中有多个颜色关联点（GL_COLOR_ATTACHMENT0_EXT,...,GL_COLOR_ATTACHMENTn_EXT），一个深度关联点（GL_DEPTH_ATTACHMENT_EXT），和一个模板关联点（GL_STENCIL_ATTACHMENT_EXT）。每个FBO中至少有一个颜色关联点，其数目与实体显卡相关。可以通过GL_MAX_COLOR_ATTACHMENTS_EXT来查询颜色关联点的最大数目。FBO有多个颜色关联点的原因是这样可以同时将颜色而换成渲染到多个FBO关联区。这种“多渲染目标”（multiple rendertargets,MRT）可以通过GL_ARB_draw_buffers扩展实现。需要注意的是：FBO本身并没有任何图像存储区，只有多个关联点。\n\nFBO提供了一种高效的切换机制；将前面的帧缓存关联图像从FBO分离，然后把新的帧缓存关联图像关联到FBO。在帧缓存关联图像之间切换比在FBO之间切换要快得多。FBO提供了glFramebufferTexture2DEXT()来切换2D纹理对象和glFramebufferRenderbufferEXT()来切换渲染缓存对象。\n\n## 1、帧缓冲创建\n\n 使用glGenFrameBuffer函数来创建一个帧缓冲（FBO） \n\n```c\nGLuint framebuffer;\nglGenFramebuffers(1, &framebuffer);\nglBindFramebuffer(GL_FRAMEBUFFER, framebuffer);//绑定\nglBindFramebuffer(GL_FRAMEBUFFER, 0);//解绑定\n```\n\n绑定到GL_FRAMEBUFFER目标后，接下来所有的读、写帧缓冲的操作都会影响到当前绑定的帧缓冲。也可以把帧缓冲分开绑定到读或写目标上，分别使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER来做这件事。如果绑定到了GL_READ_FRAMEBUFFER，就能执行所有读取操作，像glReadPixels这样的函数使用了；绑定到GL_DRAW_FRAMEBUFFER上，就允许进行渲染、清空和其他的写入操作。大多数时候你不必分开用，通常绑定到GL_FRAMEBUFFER上就行。\n\n 如果要创建一个完整的帧缓冲，需要满足以下条件：\n\\- 至少包含一个附件（颜色、深度、或模板）；\n\\- 其中至少有一个颜色附件；\n\\- 附件要在附着之前创建好，并存储在内存中；\n\\- 每个缓冲应该有同样的样本。 \n\n 假如我们创建好一些附件之后，并已经附着到帧缓冲上了，那么接下来要对它进行检查，判断帧缓冲是否完整。\n\n```\nif(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)\n```\n\n 由于使用自定义的帧缓冲，渲染操作并不是对系统提供的默认的帧缓冲，所以并不会对屏幕上图像产生任何影响。如果要切回默认的帧缓冲，可以通过如下函数： \n\n```\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n```\n\n 当我们做完所有帧缓冲操作，不要忘记删除帧缓冲对象： \n\n```\nglDeleteFramebuffers(1, &framebuffer);\n```\n\n##  2、帧缓冲上可以附着的两种附件 \n\n### 2.1、纹理附件 \n\n纹理附件和通过图片加载的纹理类似，只不过这个纹理附加是通过渲染命令写入到纹理当中的，不是通过图片纹理得到的。\n\n```\nGLuint texBuffer;   \nglGenTextures(1, &texBuffer);\nglBindTexture(GL_TEXTURE_2D, texBuffer);\nglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, WIDTH, HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\nglBindTexture(GL_TEXTURE_2D, 0);\n```\n\n\n\n### 2.2、渲染附件\n\n\n\n\n\n## 3、示例\n\n### 1，离屏渲染到2D纹理\n\n```c\n//--------------------1111111111111111----FBO初始化---------------------\n\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;\n\t\tglGenTextures(1,&eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglActiveTexture(GL_TEXTURE0);\n\t\tglBindTexture(GL_TEXTURE_2D, eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglTexImage2D(GL_TEXTURE_2D,0,GL_RGB,416,416,0,GL_RGB,GL_UNSIGNED_BYTE,NULL);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\n\t\tif(checkGlErrorState())\n\t\t{\t\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES id:%d GL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tglGenFramebuffers(1, &eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglGenRenderbuffers(1, &eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo->egiTexImage[dmaFbId].Depth_Fb);//\n\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo->egiTexImage[dmaFbId].Width, eglInfo->egiTexImage[dmaFbId].Height);\n\n\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D, eglInfo->egiTexImage[dmaFbId].Tex, 0);\n\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\n\t\tuint32_t glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n\t\tif(glStatus != GL_FRAMEBUFFER_COMPLETE) \n\t\t{\n\t\t\tBUG_ERR(\"glCheckFramebufferStatusOES Id:%d error 0x%x\",dmaFbId, glStatus);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\t\n\t\tglBindTexture(GL_TEXTURE_2D, 0);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER,0);\n//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------\nglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(window.x, window.y, window.width, window.height);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(416, 0, 416, 416);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_2D, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\n\teglSwapBuffers(eglInfo->egl_display, eglInfo->egl_surface);\n```\n\n### 2，离屏渲染到外部OES纹理\n\n```c\n//--------------------1111111111111111----FBO初始化---------------------\n\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;\n\t\tglGenTextures(1,&eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglActiveTexture(GL_TEXTURE0);\n\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t\tpfnglEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);\n\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\n\t\tif(checkGlErrorState())\n\t\t{\t\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES id:%d GL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tglGenFramebuffers(1, &eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglGenRenderbuffers(1, &eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo->egiTexImage[dmaFbId].Depth_Fb);//\n\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo->egiTexImage[dmaFbId].Width, eglInfo->egiTexImage[dmaFbId].Height);\n\n\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[dmaFbId].Tex, 0);\n\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\n\t\tuint32_t glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n\t\tif(glStatus != GL_FRAMEBUFFER_COMPLETE) \n\t\t{\n\t\t\tBUG_ERR(\"glCheckFramebufferStatusOES Id:%d error 0x%x\",dmaFbId, glStatus);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\n\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, 0);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER,0);\n//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------\nglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(window.x, window.y, window.width, window.height);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(416, 0, 416, 416);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, 0);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\n\teglSwapBuffers(eglInfo->egl_display, eglInfo->egl_surface);\n```\n\n### 3，离屏渲染2D或OES纹理（宏方式切换）\n\n```c\n\n//--------------------1111111111111111----FBO初始化---------------------\n\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;\n\n\t\tglGenTextures(1,&eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglActiveTexture(GL_TEXTURE0);\n\n\t#if FBO_TEXTURE\n\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[dmaFbId].Tex);\n\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t\tpfnglEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);\n\n\t#else\n\t\tglBindTexture(GL_TEXTURE_2D, eglInfo->egiTexImage[dmaFbId].Tex);\n\t\tglTexImage2D(GL_TEXTURE_2D,0,GL_RGB,416,416,0,GL_RGB,GL_UNSIGNED_BYTE,NULL);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t#endif\n\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\n\t\tif(checkGlErrorState())\n\t\t{\t\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES id:%d GL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tglGenFramebuffers(1, &eglInfo->egiTexImage[dmaFbId].Fb);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[dmaFbId].Fb);\n\n\t\tglGenRenderbuffers(1, &eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo->egiTexImage[dmaFbId].Depth_Fb);//\n\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo->egiTexImage[dmaFbId].Width, eglInfo->egiTexImage[dmaFbId].Height);\n\n\n\t#if FBO_TEXTURE\n\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[dmaFbId].Tex, 0);\n\t#else\n\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D, eglInfo->egiTexImage[dmaFbId].Tex, 0);\n\t#endif\n\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo->egiTexImage[dmaFbId].Depth_Fb);\n\n\t\tuint32_t glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n\t\tif(glStatus != GL_FRAMEBUFFER_COMPLETE) \n\t\t{\n\t\t\tBUG_ERR(\"glCheckFramebufferStatusOES Id:%d error 0x%x\",dmaFbId, glStatus);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;\n\t\t}\n\t\tif(checkEglErrorState())\n\t\t{\n\t\t\tBUG_ERR(\"pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed\",dmaFbId);\n\t\t\treturn GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;\n\t\t}\t\n\t#if FBO_TEXTURE\n\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, 0);\n\t#else\n\t\tglBindTexture(GL_TEXTURE_2D, 0);\n\t#endif\n\n\t\tglBindFramebuffer(GL_FRAMEBUFFER,0);\n\n//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------\nglBindFramebuffer(GL_FRAMEBUFFER, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);\n\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(window.x, window.y, window.width, window.height);\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\n\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n\n\tglm::mat4 Identity(1.0f);\n\tglEnable(GL_BLEND);\n\tglDisable(GL_DEPTH_TEST);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\tglViewport(416, 0, 416, 416);\n\n\t#if FBO_TEXTURE\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, 0);\n\n\t#else\n\n\t//2D纹理显示\n\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle());\n\tglActiveTexture(GL_TEXTURE0);\n\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);\n\tglBindTexture(GL_TEXTURE_2D, eglInfo->egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);//\n\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle(), \"myTexture\"), 0);\n\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog->getHandle(), \"mvp\"), 1, GL_FALSE, glm::value_ptr(Identity));\n\tglDrawArrays(GL_TRIANGLES, 0,6);\n\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\t#endif\n\n\tpFNglbindvertexarrayOES(0);  \n\tglDisable(GL_BLEND);\n\tglFlush();\n\teglSwapBuffers(eglInfo->egl_display, eglInfo->egl_surface);\n\n```\n\n","slug":"4-5-FBO","published":1,"updated":"2023-04-14T13:49:05.863Z","_id":"clggljftg0002hoobbllv4ldm","layout":"post","photos":[],"link":"","content":"<h1 id=\"OpenGl-ES—FBO\"><a href=\"#OpenGl-ES—FBO\" class=\"headerlink\" title=\"OpenGl ES—FBO\"></a>OpenGl ES—FBO</h1><p>（Frame Buffer Object帧缓存对象）</p>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>在OpenGL渲染管线中，几何数据和纹理经过多次转化和多次测试，最后以二维像素的形式显示在屏幕上。OpenGL管线的最终渲染目的地被称作帧缓存（framebuffer）。帧缓冲是一些二维数组和OpenG所使用的存储区的集合：颜色缓存、深度缓存、模板缓存和累计缓存。一般情况下，帧缓存完全由window系统生成和管理，由OpenGL使用。这个默认的帧缓存被称作“window系统生成”（window-system-provided）的帧缓存。</p>\n<span id=\"more\"></span>\n\n<p>在OpenGL扩展中，GL_EXT_framebuffer_object提供了一种创建额外的不能显示的帧缓存对象的接口。为了和默认的“window系统生成”的帧缓存区别，这种帧缓冲成为应用程序帧缓存（application-createdframebuffer）。通过使用帧缓存对象（FBO），OpenGL可以将显示输出到引用程序帧缓存对象，而不是传统的“window系统生成”帧缓存。而且，它完全受OpenGL控制。</p>\n<p>相似于window系统提供的帧缓存，一个FBO也包含一些存储颜色、深度和模板数据的区域。（注意：没有累积缓存）我们把FBO中这些逻辑缓存称之为“帧缓存关联图像”，它们是一些能够和一个帧缓存对象关联起来的二维数组像素。</p>\n<p>有两种类型的“帧缓存关联图像”：纹理图像（texture images）和渲染缓存图像（renderbuffer images）。如果纹理对象的图像数据关联到帧缓存，OpenGL执行的是“渲染到纹理”（render to texture）操作。如果渲染缓存的图像数据关联到帧缓存，OpenGL执行的是离线渲染（offscreen rendering）。</p>\n<p>这里要提到的是，渲染缓存对象是在GL_EXT_framebuffer_object扩展中定义的一种新的存储类型。在渲染过程中它被用作存储单幅二维图像。</p>\n<p>下面这幅图显示了帧缓存对象、纹理对象和渲染缓存对象之间的联系。多多个纹理对象或者渲染缓存对象能够通过关联点关联到一个帧缓存对象上。</p>\n<p><img src=\"/2023/04/14/4-5-FBO/25.png\"></p>\n<p>在一个帧缓存对象中有多个颜色关联点（GL_COLOR_ATTACHMENT0_EXT,…,GL_COLOR_ATTACHMENTn_EXT），一个深度关联点（GL_DEPTH_ATTACHMENT_EXT），和一个模板关联点（GL_STENCIL_ATTACHMENT_EXT）。每个FBO中至少有一个颜色关联点，其数目与实体显卡相关。可以通过GL_MAX_COLOR_ATTACHMENTS_EXT来查询颜色关联点的最大数目。FBO有多个颜色关联点的原因是这样可以同时将颜色而换成渲染到多个FBO关联区。这种“多渲染目标”（multiple rendertargets,MRT）可以通过GL_ARB_draw_buffers扩展实现。需要注意的是：FBO本身并没有任何图像存储区，只有多个关联点。</p>\n<p>FBO提供了一种高效的切换机制；将前面的帧缓存关联图像从FBO分离，然后把新的帧缓存关联图像关联到FBO。在帧缓存关联图像之间切换比在FBO之间切换要快得多。FBO提供了glFramebufferTexture2DEXT()来切换2D纹理对象和glFramebufferRenderbufferEXT()来切换渲染缓存对象。</p>\n<h2 id=\"1、帧缓冲创建\"><a href=\"#1、帧缓冲创建\" class=\"headerlink\" title=\"1、帧缓冲创建\"></a>1、帧缓冲创建</h2><p> 使用glGenFrameBuffer函数来创建一个帧缓冲（FBO） </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint framebuffer;</span><br><span class=\"line\">glGenFramebuffers(<span class=\"number\">1</span>, &amp;framebuffer);</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<span class=\"comment\">//绑定</span></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, <span class=\"number\">0</span>);<span class=\"comment\">//解绑定</span></span><br></pre></td></tr></table></figure>\n\n<p>绑定到GL_FRAMEBUFFER目标后，接下来所有的读、写帧缓冲的操作都会影响到当前绑定的帧缓冲。也可以把帧缓冲分开绑定到读或写目标上，分别使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER来做这件事。如果绑定到了GL_READ_FRAMEBUFFER，就能执行所有读取操作，像glReadPixels这样的函数使用了；绑定到GL_DRAW_FRAMEBUFFER上，就允许进行渲染、清空和其他的写入操作。大多数时候你不必分开用，通常绑定到GL_FRAMEBUFFER上就行。</p>\n<p> 如果要创建一个完整的帧缓冲，需要满足以下条件：<br>- 至少包含一个附件（颜色、深度、或模板）；<br>- 其中至少有一个颜色附件；<br>- 附件要在附着之前创建好，并存储在内存中；<br>- 每个缓冲应该有同样的样本。 </p>\n<p> 假如我们创建好一些附件之后，并已经附着到帧缓冲上了，那么接下来要对它进行检查，判断帧缓冲是否完整。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)</span><br></pre></td></tr></table></figure>\n\n<p> 由于使用自定义的帧缓冲，渲染操作并不是对系统提供的默认的帧缓冲，所以并不会对屏幕上图像产生任何影响。如果要切回默认的帧缓冲，可以通过如下函数： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, 0);</span><br></pre></td></tr></table></figure>\n\n<p> 当我们做完所有帧缓冲操作，不要忘记删除帧缓冲对象： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDeleteFramebuffers(1, &amp;framebuffer);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、帧缓冲上可以附着的两种附件\"><a href=\"#2、帧缓冲上可以附着的两种附件\" class=\"headerlink\" title=\"2、帧缓冲上可以附着的两种附件\"></a>2、帧缓冲上可以附着的两种附件</h2><h3 id=\"2-1、纹理附件\"><a href=\"#2-1、纹理附件\" class=\"headerlink\" title=\"2.1、纹理附件\"></a>2.1、纹理附件</h3><p>纹理附件和通过图片加载的纹理类似，只不过这个纹理附加是通过渲染命令写入到纹理当中的，不是通过图片纹理得到的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint texBuffer;   </span><br><span class=\"line\">glGenTextures(1, &amp;texBuffer);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, texBuffer);</span><br><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, WIDTH, HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, 0);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-2、渲染附件\"><a href=\"#2-2、渲染附件\" class=\"headerlink\" title=\"2.2、渲染附件\"></a>2.2、渲染附件</h3><h2 id=\"3、示例\"><a href=\"#3、示例\" class=\"headerlink\" title=\"3、示例\"></a>3、示例</h2><h3 id=\"1，离屏渲染到2D纹理\"><a href=\"#1，离屏渲染到2D纹理\" class=\"headerlink\" title=\"1，离屏渲染到2D纹理\"></a>1，离屏渲染到2D纹理</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//--------------------1111111111111111----FBO初始化---------------------</span></span><br><span class=\"line\">\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;</span><br><span class=\"line\">\t\tglGenTextures(<span class=\"number\">1</span>,&amp;eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglTexImage2D(GL_TEXTURE_2D,<span class=\"number\">0</span>,GL_RGB,<span class=\"number\">416</span>,<span class=\"number\">416</span>,<span class=\"number\">0</span>,GL_RGB,GL_UNSIGNED_BYTE,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkGlErrorState())</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES id:%d GL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tglGenFramebuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglGenRenderbuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\">\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);<span class=\"comment\">//</span></span><br><span class=\"line\">\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo-&gt;egiTexImage[dmaFbId].Width, eglInfo-&gt;egiTexImage[dmaFbId].Height);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[dmaFbId].Tex, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(glStatus != GL_FRAMEBUFFER_COMPLETE) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;glCheckFramebufferStatusOES Id:%d error 0x%x&quot;</span>,dmaFbId, glStatus);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------</span></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);</span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(window.x, window.y, window.width, window.height);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(<span class=\"number\">416</span>, <span class=\"number\">0</span>, <span class=\"number\">416</span>, <span class=\"number\">416</span>);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">\teglSwapBuffers(eglInfo-&gt;egl_display, eglInfo-&gt;egl_surface);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2，离屏渲染到外部OES纹理\"><a href=\"#2，离屏渲染到外部OES纹理\" class=\"headerlink\" title=\"2，离屏渲染到外部OES纹理\"></a>2，离屏渲染到外部OES纹理</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//--------------------1111111111111111----FBO初始化---------------------</span></span><br><span class=\"line\">\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;</span><br><span class=\"line\">\t\tglGenTextures(<span class=\"number\">1</span>,&amp;eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tpfnglEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkGlErrorState())</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES id:%d GL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tglGenFramebuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglGenRenderbuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\">\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);<span class=\"comment\">//</span></span><br><span class=\"line\">\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo-&gt;egiTexImage[dmaFbId].Width, eglInfo-&gt;egiTexImage[dmaFbId].Height);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[dmaFbId].Tex, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(glStatus != GL_FRAMEBUFFER_COMPLETE) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;glCheckFramebufferStatusOES Id:%d error 0x%x&quot;</span>,dmaFbId, glStatus);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------</span></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);</span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(window.x, window.y, window.width, window.height);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(<span class=\"number\">416</span>, <span class=\"number\">0</span>, <span class=\"number\">416</span>, <span class=\"number\">416</span>);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, <span class=\"number\">0</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">\teglSwapBuffers(eglInfo-&gt;egl_display, eglInfo-&gt;egl_surface);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3，离屏渲染2D或OES纹理（宏方式切换）\"><a href=\"#3，离屏渲染2D或OES纹理（宏方式切换）\" class=\"headerlink\" title=\"3，离屏渲染2D或OES纹理（宏方式切换）\"></a>3，离屏渲染2D或OES纹理（宏方式切换）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//--------------------1111111111111111----FBO初始化---------------------</span></span><br><span class=\"line\">\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglGenTextures(<span class=\"number\">1</span>,&amp;eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> FBO_TEXTURE</span></span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tpfnglEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglTexImage2D(GL_TEXTURE_2D,<span class=\"number\">0</span>,GL_RGB,<span class=\"number\">416</span>,<span class=\"number\">416</span>,<span class=\"number\">0</span>,GL_RGB,GL_UNSIGNED_BYTE,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkGlErrorState())</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES id:%d GL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tglGenFramebuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglGenRenderbuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\">\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);<span class=\"comment\">//</span></span><br><span class=\"line\">\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo-&gt;egiTexImage[dmaFbId].Width, eglInfo-&gt;egiTexImage[dmaFbId].Height);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> FBO_TEXTURE</span></span><br><span class=\"line\">\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[dmaFbId].Tex, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[dmaFbId].Tex, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(glStatus != GL_FRAMEBUFFER_COMPLETE) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;glCheckFramebufferStatusOES Id:%d error 0x%x&quot;</span>,dmaFbId, glStatus);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> FBO_TEXTURE</span></span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------</span></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(window.x, window.y, window.width, window.height);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\"></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(<span class=\"number\">416</span>, <span class=\"number\">0</span>, <span class=\"number\">416</span>, <span class=\"number\">416</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> FBO_TEXTURE</span></span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//2D纹理显示</span></span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">\teglSwapBuffers(eglInfo-&gt;egl_display, eglInfo-&gt;egl_surface);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"style":""}},"length":16357,"excerpt":"<h1 id=\"OpenGl-ES—FBO\"><a href=\"#OpenGl-ES—FBO\" class=\"headerlink\" title=\"OpenGl ES—FBO\"></a>OpenGl ES—FBO</h1><p>（Frame Buffer Object帧缓存对象）</p>\n<h2 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h2><p>在OpenGL渲染管线中，几何数据和纹理经过多次转化和多次测试，最后以二维像素的形式显示在屏幕上。OpenGL管线的最终渲染目的地被称作帧缓存（framebuffer）。帧缓冲是一些二维数组和OpenG所使用的存储区的集合：颜色缓存、深度缓存、模板缓存和累计缓存。一般情况下，帧缓存完全由window系统生成和管理，由OpenGL使用。这个默认的帧缓存被称作“window系统生成”（window-system-provided）的帧缓存。</p>","more":"<p>在OpenGL扩展中，GL_EXT_framebuffer_object提供了一种创建额外的不能显示的帧缓存对象的接口。为了和默认的“window系统生成”的帧缓存区别，这种帧缓冲成为应用程序帧缓存（application-createdframebuffer）。通过使用帧缓存对象（FBO），OpenGL可以将显示输出到引用程序帧缓存对象，而不是传统的“window系统生成”帧缓存。而且，它完全受OpenGL控制。</p>\n<p>相似于window系统提供的帧缓存，一个FBO也包含一些存储颜色、深度和模板数据的区域。（注意：没有累积缓存）我们把FBO中这些逻辑缓存称之为“帧缓存关联图像”，它们是一些能够和一个帧缓存对象关联起来的二维数组像素。</p>\n<p>有两种类型的“帧缓存关联图像”：纹理图像（texture images）和渲染缓存图像（renderbuffer images）。如果纹理对象的图像数据关联到帧缓存，OpenGL执行的是“渲染到纹理”（render to texture）操作。如果渲染缓存的图像数据关联到帧缓存，OpenGL执行的是离线渲染（offscreen rendering）。</p>\n<p>这里要提到的是，渲染缓存对象是在GL_EXT_framebuffer_object扩展中定义的一种新的存储类型。在渲染过程中它被用作存储单幅二维图像。</p>\n<p>下面这幅图显示了帧缓存对象、纹理对象和渲染缓存对象之间的联系。多多个纹理对象或者渲染缓存对象能够通过关联点关联到一个帧缓存对象上。</p>\n<p><img src=\"/2023/04/14/4-5-FBO/25.png\"></p>\n<p>在一个帧缓存对象中有多个颜色关联点（GL_COLOR_ATTACHMENT0_EXT,…,GL_COLOR_ATTACHMENTn_EXT），一个深度关联点（GL_DEPTH_ATTACHMENT_EXT），和一个模板关联点（GL_STENCIL_ATTACHMENT_EXT）。每个FBO中至少有一个颜色关联点，其数目与实体显卡相关。可以通过GL_MAX_COLOR_ATTACHMENTS_EXT来查询颜色关联点的最大数目。FBO有多个颜色关联点的原因是这样可以同时将颜色而换成渲染到多个FBO关联区。这种“多渲染目标”（multiple rendertargets,MRT）可以通过GL_ARB_draw_buffers扩展实现。需要注意的是：FBO本身并没有任何图像存储区，只有多个关联点。</p>\n<p>FBO提供了一种高效的切换机制；将前面的帧缓存关联图像从FBO分离，然后把新的帧缓存关联图像关联到FBO。在帧缓存关联图像之间切换比在FBO之间切换要快得多。FBO提供了glFramebufferTexture2DEXT()来切换2D纹理对象和glFramebufferRenderbufferEXT()来切换渲染缓存对象。</p>\n<h2 id=\"1、帧缓冲创建\"><a href=\"#1、帧缓冲创建\" class=\"headerlink\" title=\"1、帧缓冲创建\"></a>1、帧缓冲创建</h2><p> 使用glGenFrameBuffer函数来创建一个帧缓冲（FBO） </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint framebuffer;</span><br><span class=\"line\">glGenFramebuffers(<span class=\"number\">1</span>, &amp;framebuffer);</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<span class=\"comment\">//绑定</span></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, <span class=\"number\">0</span>);<span class=\"comment\">//解绑定</span></span><br></pre></td></tr></table></figure>\n\n<p>绑定到GL_FRAMEBUFFER目标后，接下来所有的读、写帧缓冲的操作都会影响到当前绑定的帧缓冲。也可以把帧缓冲分开绑定到读或写目标上，分别使用GL_READ_FRAMEBUFFER或GL_DRAW_FRAMEBUFFER来做这件事。如果绑定到了GL_READ_FRAMEBUFFER，就能执行所有读取操作，像glReadPixels这样的函数使用了；绑定到GL_DRAW_FRAMEBUFFER上，就允许进行渲染、清空和其他的写入操作。大多数时候你不必分开用，通常绑定到GL_FRAMEBUFFER上就行。</p>\n<p> 如果要创建一个完整的帧缓冲，需要满足以下条件：<br>- 至少包含一个附件（颜色、深度、或模板）；<br>- 其中至少有一个颜色附件；<br>- 附件要在附着之前创建好，并存储在内存中；<br>- 每个缓冲应该有同样的样本。 </p>\n<p> 假如我们创建好一些附件之后，并已经附着到帧缓冲上了，那么接下来要对它进行检查，判断帧缓冲是否完整。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE)</span><br></pre></td></tr></table></figure>\n\n<p> 由于使用自定义的帧缓冲，渲染操作并不是对系统提供的默认的帧缓冲，所以并不会对屏幕上图像产生任何影响。如果要切回默认的帧缓冲，可以通过如下函数： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, 0);</span><br></pre></td></tr></table></figure>\n\n<p> 当我们做完所有帧缓冲操作，不要忘记删除帧缓冲对象： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glDeleteFramebuffers(1, &amp;framebuffer);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、帧缓冲上可以附着的两种附件\"><a href=\"#2、帧缓冲上可以附着的两种附件\" class=\"headerlink\" title=\"2、帧缓冲上可以附着的两种附件\"></a>2、帧缓冲上可以附着的两种附件</h2><h3 id=\"2-1、纹理附件\"><a href=\"#2-1、纹理附件\" class=\"headerlink\" title=\"2.1、纹理附件\"></a>2.1、纹理附件</h3><p>纹理附件和通过图片加载的纹理类似，只不过这个纹理附加是通过渲染命令写入到纹理当中的，不是通过图片纹理得到的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLuint texBuffer;   </span><br><span class=\"line\">glGenTextures(1, &amp;texBuffer);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, texBuffer);</span><br><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, WIDTH, HEIGHT, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class=\"line\">glBindTexture(GL_TEXTURE_2D, 0);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-2、渲染附件\"><a href=\"#2-2、渲染附件\" class=\"headerlink\" title=\"2.2、渲染附件\"></a>2.2、渲染附件</h3><h2 id=\"3、示例\"><a href=\"#3、示例\" class=\"headerlink\" title=\"3、示例\"></a>3、示例</h2><h3 id=\"1，离屏渲染到2D纹理\"><a href=\"#1，离屏渲染到2D纹理\" class=\"headerlink\" title=\"1，离屏渲染到2D纹理\"></a>1，离屏渲染到2D纹理</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//--------------------1111111111111111----FBO初始化---------------------</span></span><br><span class=\"line\">\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;</span><br><span class=\"line\">\t\tglGenTextures(<span class=\"number\">1</span>,&amp;eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglTexImage2D(GL_TEXTURE_2D,<span class=\"number\">0</span>,GL_RGB,<span class=\"number\">416</span>,<span class=\"number\">416</span>,<span class=\"number\">0</span>,GL_RGB,GL_UNSIGNED_BYTE,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkGlErrorState())</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES id:%d GL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tglGenFramebuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglGenRenderbuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\">\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);<span class=\"comment\">//</span></span><br><span class=\"line\">\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo-&gt;egiTexImage[dmaFbId].Width, eglInfo-&gt;egiTexImage[dmaFbId].Height);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[dmaFbId].Tex, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(glStatus != GL_FRAMEBUFFER_COMPLETE) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;glCheckFramebufferStatusOES Id:%d error 0x%x&quot;</span>,dmaFbId, glStatus);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------</span></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);</span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(window.x, window.y, window.width, window.height);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(<span class=\"number\">416</span>, <span class=\"number\">0</span>, <span class=\"number\">416</span>, <span class=\"number\">416</span>);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">\teglSwapBuffers(eglInfo-&gt;egl_display, eglInfo-&gt;egl_surface);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2，离屏渲染到外部OES纹理\"><a href=\"#2，离屏渲染到外部OES纹理\" class=\"headerlink\" title=\"2，离屏渲染到外部OES纹理\"></a>2，离屏渲染到外部OES纹理</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//--------------------1111111111111111----FBO初始化---------------------</span></span><br><span class=\"line\">\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;</span><br><span class=\"line\">\t\tglGenTextures(<span class=\"number\">1</span>,&amp;eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tpfnglEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkGlErrorState())</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES id:%d GL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tglGenFramebuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglGenRenderbuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\">\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);<span class=\"comment\">//</span></span><br><span class=\"line\">\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo-&gt;egiTexImage[dmaFbId].Width, eglInfo-&gt;egiTexImage[dmaFbId].Height);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[dmaFbId].Tex, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(glStatus != GL_FRAMEBUFFER_COMPLETE) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;glCheckFramebufferStatusOES Id:%d error 0x%x&quot;</span>,dmaFbId, glStatus);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER,<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------</span></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);</span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(window.x, window.y, window.width, window.height);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(<span class=\"number\">416</span>, <span class=\"number\">0</span>, <span class=\"number\">416</span>, <span class=\"number\">416</span>);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, <span class=\"number\">0</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">\teglSwapBuffers(eglInfo-&gt;egl_display, eglInfo-&gt;egl_surface);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3，离屏渲染2D或OES纹理（宏方式切换）\"><a href=\"#3，离屏渲染2D或OES纹理（宏方式切换）\" class=\"headerlink\" title=\"3，离屏渲染2D或OES纹理（宏方式切换）\"></a>3，离屏渲染2D或OES纹理（宏方式切换）</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//--------------------1111111111111111----FBO初始化---------------------</span></span><br><span class=\"line\">\t\tdmaFbId = VTGLR_TEX_IMAGE_DPYFBO_BUF;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglGenTextures(<span class=\"number\">1</span>,&amp;eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> FBO_TEXTURE</span></span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tpfnglEGLImageTargetTexture2DOES(GL_TEXTURE_EXTERNAL_OES, (GLeglImageOES)img);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[dmaFbId].Tex);</span><br><span class=\"line\">\t\tglTexImage2D(GL_TEXTURE_2D,<span class=\"number\">0</span>,GL_RGB,<span class=\"number\">416</span>,<span class=\"number\">416</span>,<span class=\"number\">0</span>,GL_RGB,GL_UNSIGNED_BYTE,<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkGlErrorState())</span><br><span class=\"line\">\t\t&#123;\t</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES id:%d GL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tglGenFramebuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglGenRenderbuffers(<span class=\"number\">1</span>, &amp;eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\">\t\tglBindRenderbuffer(GL_RENDERBUFFER,eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);<span class=\"comment\">//</span></span><br><span class=\"line\">\t\tglRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, eglInfo-&gt;egiTexImage[dmaFbId].Width, eglInfo-&gt;egiTexImage[dmaFbId].Height);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> FBO_TEXTURE</span></span><br><span class=\"line\">\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[dmaFbId].Tex, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[dmaFbId].Tex, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t\tglFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, eglInfo-&gt;egiTexImage[dmaFbId].Depth_Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"type\">uint32_t</span> glStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(glStatus != GL_FRAMEBUFFER_COMPLETE) </span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;glCheckFramebufferStatusOES Id:%d error 0x%x&quot;</span>,dmaFbId, glStatus);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_GL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(checkEglErrorState())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tBUG_ERR(<span class=\"string\">&quot;pfnglEGLImageTargetTexture2DOES Id:%d EGL Failed&quot;</span>,dmaFbId);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> GLR_EGL_IMAGETARGET_TEXTURE2D_EGL_STATE_ERR;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> FBO_TEXTURE</span></span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">\t\tglBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tglBindFramebuffer(GL_FRAMEBUFFER,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//--------------------2222222222222222-----离屏渲染与显示到屏幕验证--------------------</span></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Fb);</span><br><span class=\"line\"></span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(window.x, window.y, window.width, window.height);</span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, VT_GetCamEglTex(camera, gCameraBufIndex[camera]));<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\"></span><br><span class=\"line\">glBindFramebuffer(GL_FRAMEBUFFER, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\tglm::mat4 <span class=\"title function_\">Identity</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span>;</span><br><span class=\"line\">\tglEnable(GL_BLEND);</span><br><span class=\"line\">\tglDisable(GL_DEPTH_TEST);</span><br><span class=\"line\">\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class=\"line\">\tglViewport(<span class=\"number\">416</span>, <span class=\"number\">0</span>, <span class=\"number\">416</span>, <span class=\"number\">416</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">if</span> FBO_TEXTURE</span></span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_CAMVIEW].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_EXTERNAL_OES, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//2D纹理显示</span></span><br><span class=\"line\">\tglUseProgram(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle());</span><br><span class=\"line\">\tglActiveTexture(GL_TEXTURE0);</span><br><span class=\"line\">\tpFNglbindvertexarrayOES(VTGL_Obj[VTGLR_COMMON_WIN_OBJ].vao);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_2D, eglInfo-&gt;egiTexImage[VTGLR_TEX_IMAGE_DPYFBO_BUF].Tex);<span class=\"comment\">//</span></span><br><span class=\"line\">\tglUniform1i(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle(), <span class=\"string\">&quot;myTexture&quot;</span>), <span class=\"number\">0</span>);</span><br><span class=\"line\">\tglUniformMatrix4fv(glGetUniformLocation(CommonRenderProg[VTGLR_COMMON_PROG_2D].Prog-&gt;getHandle(), <span class=\"string\">&quot;mvp&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::value_ptr(Identity));</span><br><span class=\"line\">\tglDrawArrays(GL_TRIANGLES, <span class=\"number\">0</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\">\tglBindTexture(GL_TEXTURE_2D, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">\tpFNglbindvertexarrayOES(<span class=\"number\">0</span>);  </span><br><span class=\"line\">\tglDisable(GL_BLEND);</span><br><span class=\"line\">\tglFlush();</span><br><span class=\"line\">\teglSwapBuffers(eglInfo-&gt;egl_display, eglInfo-&gt;egl_surface);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"OpenGl ES---VBO,VAO","date":"2023-04-14T13:50:11.000Z","comments":0,"description":null,"typora-root-url":"4-6-VBO与VAO","_content":"\n# OpenGl ES---VBO,VAO\n\n## 1.简介\n\nVBO,VAO和EBO:\n\n- VBO(Vertex Buffer Object):顶点缓冲区对象\n\n- VAO(顶点数组对象):顶点数组对象\n\n- EBO（Element Buffer Object）:元素缓冲对象\n\n  \n\n  问：为什么要有VAO与VBO？\n\n  ```c\n  /*\n  起因：\n  在opengl es编程中，用于绘制的顶点数据首先保存在CPU内存，在调用glDrawArrays和 glDrawElements 等进行绘制时，需要将顶点数组数据从CPU内存拷贝到显存。我们没有必要每次绘制都去进行内存拷贝，若可以在显存中缓存这些数据，可以降低内存拷贝带来的开销。\n  所以以上VBO,VAO出现就是为了解决这个问题。\n  \n  VBO,VAO作用：在显存中提前开辟好一块内存，用于缓存顶点数据\n  */\n  ```\n\n<!--more-->\n\n## 2.顶点数组数据和图元索引数据： \n\n```cpp\n// 4 vertices, with(x,y,z) ,(r, g, b, a) per-vertex\nGLfloat vertices[] =\n\t\t{\n\t\t\t\t-0.5f,  0.5f, 0.0f,       // v0\n\t\t\t\t1.0f,  0.0f, 0.0f,        // c0\n\t\t\t\t-0.5f, -0.5f, 0.0f,       // v1\n\t\t\t\t0.0f,  1.0f, 0.0f,        // c1\n\t\t\t\t0.5f, -0.5f, 0.0f,        // v2\n\t\t\t\t0.0f,  0.0f, 1.0f,        // c2\n\t\t\t\t0.5f,  0.5f, 0.0f,        // v3\n\t\t\t\t0.5f,  1.0f, 1.0f,        // c3\n\t\t};\n// Index buffer data\nGLushort indices[6] = { 0, 1, 2, 0, 2, 3};\n\n/*由于顶点位置和颜色数据在同一个数组里，一起更新到VBO里面，需要知道2个属性的步长和偏移量。为获得数据队列中下一个属性值，需向右移动6个float,其中3个是位置值，另外3个是颜色值，所以步长为6*float的字节数。\n同样，需要指定位置属性和颜色属性在VBO内存中的偏移量，对于每个顶点，位置属性在前，偏移量为0，颜色属性偏移量为3sizeof(GLfloat). \n*/\n```\n\n## 3.VBO的创建和更新：\n\n### 1) glGenBuffers()\n\n生成bufferID\n\n### 2) glBindBuffer()\n\n操作它，参数为VBO的bufferID\n\n### 3) glBufferData()\n\n指定里面放的数据和用法\n\n至此想用此VBO时再glBindBuffer()它的bufferID即可，里面一般放顶点数据（包括模型的xyz和纹理坐标uv），另外前提是已经编译和设定好了shader的program\n\n```cpp\n//创建2个VBO\nglGenBuffers(2, m_VboIds);\n//绑定第一个VBO，拷贝顶点数组到显存\nglBindBuffer(GL_ARRAY_BUFFER, m_VboIds[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n//绑定第二个VBO，拷贝图元索引数据到显存\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[1]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n//GL_STATIC_DRAW 标志标识缓冲区对象数据被修改一次，使用多次，用于绘制。\n```\n\n## 4.使用VBO进行渲染： \n\n### 1) glBindBuffer()\n\n操作想使用的VBO，参数为VBO的bufferID\n\n### 2) glEnableVertexAttribArray()\n\n启用与顶点相关的shader的量\n\t\t事先需要获取到它的handle，\n\t\t比如：\n\tmaPositionHandle = GLES20.glGetAttribLocation(mProgram, “aPosition”);\n\n### 3) glVertexAttribPointer ()\n\n指定VBO里的数据的使用方法\n\n这里有可能有多个glVertexAttribPointer ()，它的最后一个参数是使用时每个元素的偏移量，比如顶点是xyzuv的float顶点，每个4*5个字节重复一次，则分开指定xyz坐标和纹理坐标时，最后一个参数的值分别取0和12\n另外，最后不适用VBO时，最后一个参数可以直接指定要渲染的缓冲区\n\n### 4) glDrawArrays()\n\n指定画法（一般为GL_TRIANGLES，即三角形），数量等，即可使用VBO进行绘制\n\n### 5) glDrawElements()\n\n这是另一种画法，可以通过指定顶点索引的方式来画图形\n使用这种方法渲染时，应该生成两块VBO buffer，一个用来存放顶点信息，另一个来存放索引信息，和普通顶点VBO区别是，存放顶点的VBO应该在使用和指定数据时使用GL_ELEMENT_ARRAY_BUFFER，再使用glDrawElements(). 例如\n\n```java\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mBufferHandle[1]); \nglBufferData(GL_ELEMENT_ARRAY_BUFFER,Count,buffer,GL_STATIC_DRAW); \nglDrawElements(GL_TRIANGLES,count,GL_UNSIGNED_SHORT, 0);\n```\n\n### es2.0 VBO例子\n\n```c\nglGenBuffers(VAO_NUM, obj->vert_VBO);//创建VBO\nglBindBuffer(GL_ARRAY_BUFFER, *vert_VBO);//绑定VBO\nglBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * vert_elm_step * vert_rows, &vert_Data[0], GL_DYNAMIC_DRAW);//指定里面放的数据和用法，拷贝顶点数组到显存\n//---------------------------------------------------\nattribute vec4 position;//shader中的输入\n//---------------------------------------------------\nmPositionLocation = glGetAttribLocation(mProgram, \"position\");//获取到position的handle\nglEnableVertexAttribArray(mPositionLocation);//启用与顶点相关的shader的量\nglVertexAttribPointer(mPositionLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);//指定VBO里的数据的使用方法\n```\n\n### es3.0 VBO例子\n\n```c\n//顶点着色器\n#version 300 es                            \nlayout(location = 0) in vec4 a_position;   // 位置变量的属性位置值为 0 \nlayout(location = 1) in vec3 a_color;      // 颜色变量的属性位置值为 1\nout vec3 v_color;                          // 向片段着色器输出一个颜色                          \nvoid main()                                \n{                                          \n    v_color = a_color;                     \n    gl_Position = a_position;              \n};\n\n//片段着色器\n#version 300 es\nprecision mediump float;\nin vec3 v_color;\nout vec4 o_fragColor;\nvoid main()\n{\n    o_fragColor = vec4(v_color, 1.0);\n}\n//---------------------------------------------------\n //创建2个VBO\nglGenBuffers(2, m_VboIds);\n//绑定第一个VBO，拷贝顶点数组到显存\nglBindBuffer(GL_ARRAY_BUFFER, m_VboIds[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n//绑定第二个VBO，拷贝图元索引数据到显存\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[1]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\n//---------------------------------------------------\nglUseProgram(m_ProgramObj);\n//---------------------------------------------------\n//不使用 VBO 的绘制\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), vertices);\n\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (vertices + 3));\n\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices);\n//---------------------------------------------------\n//使用 VBO 的绘制\nglBindBuffer(GL_ARRAY_BUFFER, m_VboIds[0]);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (const void *)0);\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (const void *)(3 *sizeof(GLfloat)));\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[1]);\n\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (const void *)0);\n\n\n```\n\n\n\n## 6.VAO的创建和更新\n\n 顶点数组对象，VAO作用：管理VBO，减少glBindBuffer,glEnableVertexAttribArray,glVertexAttribPointer这些调用操作。 \n\n![](22.png)\n\n\n\n### 1)\tglGenVertexArrays()\n\n### 2)\tglBindVertexArray()\n\n```cpp\n// 创建并绑定 VAO\nglGenVertexArrays(1, &m_VaoId);\nglBindVertexArray(m_VaoId);\n\n// 在绑定 VAO 之后，操作 VBO ，当前 VAO 会记录 VBO 的操作\nglBindBuffer(GL_ARRAY_BUFFER, m_VboIds[0]);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (const void *)0);\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (const void *)(3 *sizeof(GLfloat)));\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[1]);\n\nglBindVertexArray(GL_NONE);\n```\n\n##  7.使用VAO进行渲染：\n\n```cpp\nglUseProgram(m_ProgramObj);\n\nglBindVertexArray(m_VaoId);\n\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (const void *)0);\n```\n\n## 8.如何让OpenES2.0支持VAO？\n\n如果标准里没有定义一个函数, 可以用扩展的形式取得函数指针, 然后判断函数指针是否为空, 不为空就可以使用这个函数了.\n\n例如: 获取 VAO的扩展, 这个在OpenGL2.0标准里没有定义, 只能通过扩展的形式取得.\n\n如：\n\n```cpp\n#include <GLES2/gl2.h>\n        /* VAO   获取VAO扩展 in opengl2.0*/\n           PFNGLGENVERTEXARRAYSOESPROC glGenVertexArrays = (PFNGLGENVERTEXARRAYSOESPROC) eglGetProcAddress(\"glGenVertexArraysOES\");\n           PFNGLBINDVERTEXARRAYOESPROC glBindVertexArray = (PFNGLBINDVERTEXARRAYOESPROC) eglGetProcAddress(\"glBindVertexArrayOES\");\n           PFNGLDELETEVERTEXARRAYSOESPROC glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSOESPROC) eglGetProcAddress(\"glDeleteVertexArraysOES\");\n```\n\nOpenGL ES 扩展头文件GLES2/gl2ext.h\n\n![](24.png)\n\n\n\n### 用扩展的形式获取函数指针来支持VAO\n\n![](23.jpg)\n\n### 1）创建 VAO\n\n(*pFNglGenVertexArraysOES)(VAO_NUM, obj->VAO);\n\n### 2）绑定 VAO\n\npFNglbindvertexarrayOES(obj->VAO);\n\n### 3）解绑 VAO\n\npFNglbindvertexarrayOES(0);//解绑 VAO\n\n\n\n","source":"_posts/4-6-VBO与VAO.md","raw":"---\ntitle: OpenGl ES---VBO,VAO\ndate: 2023-4-14 21:50:11\ncategories: 笔记\ntags: [嵌入式,OpenGL]\ncomments: false\ndescription:\ntypora-root-url: 4-6-VBO与VAO\n\n---\n\n# OpenGl ES---VBO,VAO\n\n## 1.简介\n\nVBO,VAO和EBO:\n\n- VBO(Vertex Buffer Object):顶点缓冲区对象\n\n- VAO(顶点数组对象):顶点数组对象\n\n- EBO（Element Buffer Object）:元素缓冲对象\n\n  \n\n  问：为什么要有VAO与VBO？\n\n  ```c\n  /*\n  起因：\n  在opengl es编程中，用于绘制的顶点数据首先保存在CPU内存，在调用glDrawArrays和 glDrawElements 等进行绘制时，需要将顶点数组数据从CPU内存拷贝到显存。我们没有必要每次绘制都去进行内存拷贝，若可以在显存中缓存这些数据，可以降低内存拷贝带来的开销。\n  所以以上VBO,VAO出现就是为了解决这个问题。\n  \n  VBO,VAO作用：在显存中提前开辟好一块内存，用于缓存顶点数据\n  */\n  ```\n\n<!--more-->\n\n## 2.顶点数组数据和图元索引数据： \n\n```cpp\n// 4 vertices, with(x,y,z) ,(r, g, b, a) per-vertex\nGLfloat vertices[] =\n\t\t{\n\t\t\t\t-0.5f,  0.5f, 0.0f,       // v0\n\t\t\t\t1.0f,  0.0f, 0.0f,        // c0\n\t\t\t\t-0.5f, -0.5f, 0.0f,       // v1\n\t\t\t\t0.0f,  1.0f, 0.0f,        // c1\n\t\t\t\t0.5f, -0.5f, 0.0f,        // v2\n\t\t\t\t0.0f,  0.0f, 1.0f,        // c2\n\t\t\t\t0.5f,  0.5f, 0.0f,        // v3\n\t\t\t\t0.5f,  1.0f, 1.0f,        // c3\n\t\t};\n// Index buffer data\nGLushort indices[6] = { 0, 1, 2, 0, 2, 3};\n\n/*由于顶点位置和颜色数据在同一个数组里，一起更新到VBO里面，需要知道2个属性的步长和偏移量。为获得数据队列中下一个属性值，需向右移动6个float,其中3个是位置值，另外3个是颜色值，所以步长为6*float的字节数。\n同样，需要指定位置属性和颜色属性在VBO内存中的偏移量，对于每个顶点，位置属性在前，偏移量为0，颜色属性偏移量为3sizeof(GLfloat). \n*/\n```\n\n## 3.VBO的创建和更新：\n\n### 1) glGenBuffers()\n\n生成bufferID\n\n### 2) glBindBuffer()\n\n操作它，参数为VBO的bufferID\n\n### 3) glBufferData()\n\n指定里面放的数据和用法\n\n至此想用此VBO时再glBindBuffer()它的bufferID即可，里面一般放顶点数据（包括模型的xyz和纹理坐标uv），另外前提是已经编译和设定好了shader的program\n\n```cpp\n//创建2个VBO\nglGenBuffers(2, m_VboIds);\n//绑定第一个VBO，拷贝顶点数组到显存\nglBindBuffer(GL_ARRAY_BUFFER, m_VboIds[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n//绑定第二个VBO，拷贝图元索引数据到显存\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[1]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n//GL_STATIC_DRAW 标志标识缓冲区对象数据被修改一次，使用多次，用于绘制。\n```\n\n## 4.使用VBO进行渲染： \n\n### 1) glBindBuffer()\n\n操作想使用的VBO，参数为VBO的bufferID\n\n### 2) glEnableVertexAttribArray()\n\n启用与顶点相关的shader的量\n\t\t事先需要获取到它的handle，\n\t\t比如：\n\tmaPositionHandle = GLES20.glGetAttribLocation(mProgram, “aPosition”);\n\n### 3) glVertexAttribPointer ()\n\n指定VBO里的数据的使用方法\n\n这里有可能有多个glVertexAttribPointer ()，它的最后一个参数是使用时每个元素的偏移量，比如顶点是xyzuv的float顶点，每个4*5个字节重复一次，则分开指定xyz坐标和纹理坐标时，最后一个参数的值分别取0和12\n另外，最后不适用VBO时，最后一个参数可以直接指定要渲染的缓冲区\n\n### 4) glDrawArrays()\n\n指定画法（一般为GL_TRIANGLES，即三角形），数量等，即可使用VBO进行绘制\n\n### 5) glDrawElements()\n\n这是另一种画法，可以通过指定顶点索引的方式来画图形\n使用这种方法渲染时，应该生成两块VBO buffer，一个用来存放顶点信息，另一个来存放索引信息，和普通顶点VBO区别是，存放顶点的VBO应该在使用和指定数据时使用GL_ELEMENT_ARRAY_BUFFER，再使用glDrawElements(). 例如\n\n```java\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mBufferHandle[1]); \nglBufferData(GL_ELEMENT_ARRAY_BUFFER,Count,buffer,GL_STATIC_DRAW); \nglDrawElements(GL_TRIANGLES,count,GL_UNSIGNED_SHORT, 0);\n```\n\n### es2.0 VBO例子\n\n```c\nglGenBuffers(VAO_NUM, obj->vert_VBO);//创建VBO\nglBindBuffer(GL_ARRAY_BUFFER, *vert_VBO);//绑定VBO\nglBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * vert_elm_step * vert_rows, &vert_Data[0], GL_DYNAMIC_DRAW);//指定里面放的数据和用法，拷贝顶点数组到显存\n//---------------------------------------------------\nattribute vec4 position;//shader中的输入\n//---------------------------------------------------\nmPositionLocation = glGetAttribLocation(mProgram, \"position\");//获取到position的handle\nglEnableVertexAttribArray(mPositionLocation);//启用与顶点相关的shader的量\nglVertexAttribPointer(mPositionLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);//指定VBO里的数据的使用方法\n```\n\n### es3.0 VBO例子\n\n```c\n//顶点着色器\n#version 300 es                            \nlayout(location = 0) in vec4 a_position;   // 位置变量的属性位置值为 0 \nlayout(location = 1) in vec3 a_color;      // 颜色变量的属性位置值为 1\nout vec3 v_color;                          // 向片段着色器输出一个颜色                          \nvoid main()                                \n{                                          \n    v_color = a_color;                     \n    gl_Position = a_position;              \n};\n\n//片段着色器\n#version 300 es\nprecision mediump float;\nin vec3 v_color;\nout vec4 o_fragColor;\nvoid main()\n{\n    o_fragColor = vec4(v_color, 1.0);\n}\n//---------------------------------------------------\n //创建2个VBO\nglGenBuffers(2, m_VboIds);\n//绑定第一个VBO，拷贝顶点数组到显存\nglBindBuffer(GL_ARRAY_BUFFER, m_VboIds[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n//绑定第二个VBO，拷贝图元索引数据到显存\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[1]);\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);\n\n//---------------------------------------------------\nglUseProgram(m_ProgramObj);\n//---------------------------------------------------\n//不使用 VBO 的绘制\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), vertices);\n\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (vertices + 3));\n\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, indices);\n//---------------------------------------------------\n//使用 VBO 的绘制\nglBindBuffer(GL_ARRAY_BUFFER, m_VboIds[0]);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (const void *)0);\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (const void *)(3 *sizeof(GLfloat)));\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[1]);\n\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (const void *)0);\n\n\n```\n\n\n\n## 6.VAO的创建和更新\n\n 顶点数组对象，VAO作用：管理VBO，减少glBindBuffer,glEnableVertexAttribArray,glVertexAttribPointer这些调用操作。 \n\n![](22.png)\n\n\n\n### 1)\tglGenVertexArrays()\n\n### 2)\tglBindVertexArray()\n\n```cpp\n// 创建并绑定 VAO\nglGenVertexArrays(1, &m_VaoId);\nglBindVertexArray(m_VaoId);\n\n// 在绑定 VAO 之后，操作 VBO ，当前 VAO 会记录 VBO 的操作\nglBindBuffer(GL_ARRAY_BUFFER, m_VboIds[0]);\nglEnableVertexAttribArray(0);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (const void *)0);\nglEnableVertexAttribArray(1);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, (3+3)*sizeof(GLfloat), (const void *)(3 *sizeof(GLfloat)));\n\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[1]);\n\nglBindVertexArray(GL_NONE);\n```\n\n##  7.使用VAO进行渲染：\n\n```cpp\nglUseProgram(m_ProgramObj);\n\nglBindVertexArray(m_VaoId);\n\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, (const void *)0);\n```\n\n## 8.如何让OpenES2.0支持VAO？\n\n如果标准里没有定义一个函数, 可以用扩展的形式取得函数指针, 然后判断函数指针是否为空, 不为空就可以使用这个函数了.\n\n例如: 获取 VAO的扩展, 这个在OpenGL2.0标准里没有定义, 只能通过扩展的形式取得.\n\n如：\n\n```cpp\n#include <GLES2/gl2.h>\n        /* VAO   获取VAO扩展 in opengl2.0*/\n           PFNGLGENVERTEXARRAYSOESPROC glGenVertexArrays = (PFNGLGENVERTEXARRAYSOESPROC) eglGetProcAddress(\"glGenVertexArraysOES\");\n           PFNGLBINDVERTEXARRAYOESPROC glBindVertexArray = (PFNGLBINDVERTEXARRAYOESPROC) eglGetProcAddress(\"glBindVertexArrayOES\");\n           PFNGLDELETEVERTEXARRAYSOESPROC glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSOESPROC) eglGetProcAddress(\"glDeleteVertexArraysOES\");\n```\n\nOpenGL ES 扩展头文件GLES2/gl2ext.h\n\n![](24.png)\n\n\n\n### 用扩展的形式获取函数指针来支持VAO\n\n![](23.jpg)\n\n### 1）创建 VAO\n\n(*pFNglGenVertexArraysOES)(VAO_NUM, obj->VAO);\n\n### 2）绑定 VAO\n\npFNglbindvertexarrayOES(obj->VAO);\n\n### 3）解绑 VAO\n\npFNglbindvertexarrayOES(0);//解绑 VAO\n\n\n\n","slug":"4-6-VBO与VAO","published":1,"updated":"2023-04-14T13:50:55.765Z","_id":"clggljnif0006hoob6539dart","layout":"post","photos":[],"link":"","content":"<h1 id=\"OpenGl-ES—VBO-VAO\"><a href=\"#OpenGl-ES—VBO-VAO\" class=\"headerlink\" title=\"OpenGl ES—VBO,VAO\"></a>OpenGl ES—VBO,VAO</h1><h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p>VBO,VAO和EBO:</p>\n<ul>\n<li><p>VBO(Vertex Buffer Object):顶点缓冲区对象</p>\n</li>\n<li><p>VAO(顶点数组对象):顶点数组对象</p>\n</li>\n<li><p>EBO（Element Buffer Object）:元素缓冲对象</p>\n<p>问：为什么要有VAO与VBO？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">起因：</span></span><br><span class=\"line\"><span class=\"comment\">在opengl es编程中，用于绘制的顶点数据首先保存在CPU内存，在调用glDrawArrays和 glDrawElements 等进行绘制时，需要将顶点数组数据从CPU内存拷贝到显存。我们没有必要每次绘制都去进行内存拷贝，若可以在显存中缓存这些数据，可以降低内存拷贝带来的开销。</span></span><br><span class=\"line\"><span class=\"comment\">所以以上VBO,VAO出现就是为了解决这个问题。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">VBO,VAO作用：在显存中提前开辟好一块内存，用于缓存顶点数据</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"2-顶点数组数据和图元索引数据：\"><a href=\"#2-顶点数组数据和图元索引数据：\" class=\"headerlink\" title=\"2.顶点数组数据和图元索引数据：\"></a>2.顶点数组数据和图元索引数据：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4 vertices, with(x,y,z) ,(r, g, b, a) per-vertex</span></span><br><span class=\"line\">GLfloat vertices[] =</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"number\">-0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,       <span class=\"comment\">// v0</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">1.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,        <span class=\"comment\">// c0</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,       <span class=\"comment\">// v1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.0f</span>,  <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>,        <span class=\"comment\">// c1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,        <span class=\"comment\">// v2</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>,        <span class=\"comment\">// c2</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,        <span class=\"comment\">// v3</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.5f</span>,  <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>,        <span class=\"comment\">// c3</span></span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"><span class=\"comment\">// Index buffer data</span></span><br><span class=\"line\">GLushort indices[<span class=\"number\">6</span>] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*由于顶点位置和颜色数据在同一个数组里，一起更新到VBO里面，需要知道2个属性的步长和偏移量。为获得数据队列中下一个属性值，需向右移动6个float,其中3个是位置值，另外3个是颜色值，所以步长为6*float的字节数。</span></span><br><span class=\"line\"><span class=\"comment\">同样，需要指定位置属性和颜色属性在VBO内存中的偏移量，对于每个顶点，位置属性在前，偏移量为0，颜色属性偏移量为3sizeof(GLfloat). </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-VBO的创建和更新：\"><a href=\"#3-VBO的创建和更新：\" class=\"headerlink\" title=\"3.VBO的创建和更新：\"></a>3.VBO的创建和更新：</h2><h3 id=\"1-glGenBuffers\"><a href=\"#1-glGenBuffers\" class=\"headerlink\" title=\"1) glGenBuffers()\"></a>1) glGenBuffers()</h3><p>生成bufferID</p>\n<h3 id=\"2-glBindBuffer\"><a href=\"#2-glBindBuffer\" class=\"headerlink\" title=\"2) glBindBuffer()\"></a>2) glBindBuffer()</h3><p>操作它，参数为VBO的bufferID</p>\n<h3 id=\"3-glBufferData\"><a href=\"#3-glBufferData\" class=\"headerlink\" title=\"3) glBufferData()\"></a>3) glBufferData()</h3><p>指定里面放的数据和用法</p>\n<p>至此想用此VBO时再glBindBuffer()它的bufferID即可，里面一般放顶点数据（包括模型的xyz和纹理坐标uv），另外前提是已经编译和设定好了shader的program</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建2个VBO</span></span><br><span class=\"line\"><span class=\"built_in\">glGenBuffers</span>(<span class=\"number\">2</span>, m_VboIds);</span><br><span class=\"line\"><span class=\"comment\">//绑定第一个VBO，拷贝顶点数组到显存</span></span><br><span class=\"line\"><span class=\"built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER, m_VboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">glBufferData</span>(GL_ARRAY_BUFFER, <span class=\"built_in\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"><span class=\"comment\">//绑定第二个VBO，拷贝图元索引数据到显存</span></span><br><span class=\"line\"><span class=\"built_in\">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"built_in\">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class=\"built_in\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\"><span class=\"comment\">//GL_STATIC_DRAW 标志标识缓冲区对象数据被修改一次，使用多次，用于绘制。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-使用VBO进行渲染：\"><a href=\"#4-使用VBO进行渲染：\" class=\"headerlink\" title=\"4.使用VBO进行渲染：\"></a>4.使用VBO进行渲染：</h2><h3 id=\"1-glBindBuffer\"><a href=\"#1-glBindBuffer\" class=\"headerlink\" title=\"1) glBindBuffer()\"></a>1) glBindBuffer()</h3><p>操作想使用的VBO，参数为VBO的bufferID</p>\n<h3 id=\"2-glEnableVertexAttribArray\"><a href=\"#2-glEnableVertexAttribArray\" class=\"headerlink\" title=\"2) glEnableVertexAttribArray()\"></a>2) glEnableVertexAttribArray()</h3><p>启用与顶点相关的shader的量<br>        事先需要获取到它的handle，<br>        比如：<br>    maPositionHandle &#x3D; GLES20.glGetAttribLocation(mProgram, “aPosition”);</p>\n<h3 id=\"3-glVertexAttribPointer\"><a href=\"#3-glVertexAttribPointer\" class=\"headerlink\" title=\"3) glVertexAttribPointer ()\"></a>3) glVertexAttribPointer ()</h3><p>指定VBO里的数据的使用方法</p>\n<p>这里有可能有多个glVertexAttribPointer ()，它的最后一个参数是使用时每个元素的偏移量，比如顶点是xyzuv的float顶点，每个4*5个字节重复一次，则分开指定xyz坐标和纹理坐标时，最后一个参数的值分别取0和12<br>另外，最后不适用VBO时，最后一个参数可以直接指定要渲染的缓冲区</p>\n<h3 id=\"4-glDrawArrays\"><a href=\"#4-glDrawArrays\" class=\"headerlink\" title=\"4) glDrawArrays()\"></a>4) glDrawArrays()</h3><p>指定画法（一般为GL_TRIANGLES，即三角形），数量等，即可使用VBO进行绘制</p>\n<h3 id=\"5-glDrawElements\"><a href=\"#5-glDrawElements\" class=\"headerlink\" title=\"5) glDrawElements()\"></a>5) glDrawElements()</h3><p>这是另一种画法，可以通过指定顶点索引的方式来画图形<br>使用这种方法渲染时，应该生成两块VBO buffer，一个用来存放顶点信息，另一个来存放索引信息，和普通顶点VBO区别是，存放顶点的VBO应该在使用和指定数据时使用GL_ELEMENT_ARRAY_BUFFER，再使用glDrawElements(). 例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mBufferHandle[<span class=\"number\">1</span>]); </span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER,Count,buffer,GL_STATIC_DRAW); </span><br><span class=\"line\">glDrawElements(GL_TRIANGLES,count,GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"es2-0-VBO例子\"><a href=\"#es2-0-VBO例子\" class=\"headerlink\" title=\"es2.0 VBO例子\"></a>es2.0 VBO例子</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glGenBuffers(VAO_NUM, obj-&gt;vert_VBO);<span class=\"comment\">//创建VBO</span></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, *vert_VBO);<span class=\"comment\">//绑定VBO</span></span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLfloat) * vert_elm_step * vert_rows, &amp;vert_Data[<span class=\"number\">0</span>], GL_DYNAMIC_DRAW);<span class=\"comment\">//指定里面放的数据和用法，拷贝顶点数组到显存</span></span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\">attribute vec4 position;<span class=\"comment\">//shader中的输入</span></span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\">mPositionLocation = glGetAttribLocation(mProgram, <span class=\"string\">&quot;position&quot;</span>);<span class=\"comment\">//获取到position的handle</span></span><br><span class=\"line\">glEnableVertexAttribArray(mPositionLocation);<span class=\"comment\">//启用与顶点相关的shader的量</span></span><br><span class=\"line\">glVertexAttribPointer(mPositionLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(Vertex), <span class=\"number\">0</span>);<span class=\"comment\">//指定VBO里的数据的使用方法</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"es3-0-VBO例子\"><a href=\"#es3-0-VBO例子\" class=\"headerlink\" title=\"es3.0 VBO例子\"></a>es3.0 VBO例子</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//顶点着色器</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es                            </span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) in vec4 a_position;   <span class=\"comment\">// 位置变量的属性位置值为 0 </span></span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) in vec3 a_color;      <span class=\"comment\">// 颜色变量的属性位置值为 1</span></span><br><span class=\"line\">out vec3 v_color;                          <span class=\"comment\">// 向片段着色器输出一个颜色                          </span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>                                </span><br><span class=\"line\">&#123;                                          </span><br><span class=\"line\">    v_color = a_color;                     </span><br><span class=\"line\">    gl_Position = a_position;              </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//片段着色器</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"type\">float</span>;</span><br><span class=\"line\">in vec3 v_color;</span><br><span class=\"line\">out vec4 o_fragColor;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    o_fragColor = vec4(v_color, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\"> <span class=\"comment\">//创建2个VBO</span></span><br><span class=\"line\">glGenBuffers(<span class=\"number\">2</span>, m_VboIds);</span><br><span class=\"line\"><span class=\"comment\">//绑定第一个VBO，拷贝顶点数组到显存</span></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, m_VboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"><span class=\"comment\">//绑定第二个VBO，拷贝图元索引数据到显存</span></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\">glUseProgram(m_ProgramObj);</span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">//不使用 VBO 的绘制</span></span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"keyword\">sizeof</span>(GLfloat), vertices);</span><br><span class=\"line\"></span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"keyword\">sizeof</span>(GLfloat), (vertices + <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_SHORT, indices);</span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">//使用 VBO 的绘制</span></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, m_VboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">const</span> <span class=\"type\">void</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">const</span> <span class=\"type\">void</span> *)(<span class=\"number\">3</span> *<span class=\"keyword\">sizeof</span>(GLfloat)));</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_SHORT, (<span class=\"type\">const</span> <span class=\"type\">void</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-VAO的创建和更新\"><a href=\"#6-VAO的创建和更新\" class=\"headerlink\" title=\"6.VAO的创建和更新\"></a>6.VAO的创建和更新</h2><p> 顶点数组对象，VAO作用：管理VBO，减少glBindBuffer,glEnableVertexAttribArray,glVertexAttribPointer这些调用操作。 </p>\n<p><img src=\"/2023/04/14/4-6-VBO%E4%B8%8EVAO/22.png\"></p>\n<h3 id=\"1-glGenVertexArrays\"><a href=\"#1-glGenVertexArrays\" class=\"headerlink\" title=\"1)\tglGenVertexArrays()\"></a>1)\tglGenVertexArrays()</h3><h3 id=\"2-glBindVertexArray\"><a href=\"#2-glBindVertexArray\" class=\"headerlink\" title=\"2)\tglBindVertexArray()\"></a>2)\tglBindVertexArray()</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并绑定 VAO</span></span><br><span class=\"line\"><span class=\"built_in\">glGenVertexArrays</span>(<span class=\"number\">1</span>, &amp;m_VaoId);</span><br><span class=\"line\"><span class=\"built_in\">glBindVertexArray</span>(m_VaoId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在绑定 VAO 之后，操作 VBO ，当前 VAO 会记录 VBO 的操作</span></span><br><span class=\"line\"><span class=\"built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER, m_VboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"built_in\">sizeof</span>(GLfloat), (<span class=\"type\">const</span> <span class=\"type\">void</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"built_in\">sizeof</span>(GLfloat), (<span class=\"type\">const</span> <span class=\"type\">void</span> *)(<span class=\"number\">3</span> *<span class=\"built_in\">sizeof</span>(GLfloat)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glBindVertexArray</span>(GL_NONE);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-使用VAO进行渲染：\"><a href=\"#7-使用VAO进行渲染：\" class=\"headerlink\" title=\"7.使用VAO进行渲染：\"></a>7.使用VAO进行渲染：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glUseProgram</span>(m_ProgramObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glBindVertexArray</span>(m_VaoId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glDrawElements</span>(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_SHORT, (<span class=\"type\">const</span> <span class=\"type\">void</span> *)<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-如何让OpenES2-0支持VAO？\"><a href=\"#8-如何让OpenES2-0支持VAO？\" class=\"headerlink\" title=\"8.如何让OpenES2.0支持VAO？\"></a>8.如何让OpenES2.0支持VAO？</h2><p>如果标准里没有定义一个函数, 可以用扩展的形式取得函数指针, 然后判断函数指针是否为空, 不为空就可以使用这个函数了.</p>\n<p>例如: 获取 VAO的扩展, 这个在OpenGL2.0标准里没有定义, 只能通过扩展的形式取得.</p>\n<p>如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;GLES2/gl2.h&gt;</span></span></span><br><span class=\"line\">        <span class=\"comment\">/* VAO   获取VAO扩展 in opengl2.0*/</span></span><br><span class=\"line\">           PFNGLGENVERTEXARRAYSOESPROC glGenVertexArrays = (PFNGLGENVERTEXARRAYSOESPROC) <span class=\"built_in\">eglGetProcAddress</span>(<span class=\"string\">&quot;glGenVertexArraysOES&quot;</span>);</span><br><span class=\"line\">           PFNGLBINDVERTEXARRAYOESPROC glBindVertexArray = (PFNGLBINDVERTEXARRAYOESPROC) <span class=\"built_in\">eglGetProcAddress</span>(<span class=\"string\">&quot;glBindVertexArrayOES&quot;</span>);</span><br><span class=\"line\">           PFNGLDELETEVERTEXARRAYSOESPROC glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSOESPROC) <span class=\"built_in\">eglGetProcAddress</span>(<span class=\"string\">&quot;glDeleteVertexArraysOES&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>OpenGL ES 扩展头文件GLES2&#x2F;gl2ext.h</p>\n<p><img src=\"/2023/04/14/4-6-VBO%E4%B8%8EVAO/24.png\"></p>\n<h3 id=\"用扩展的形式获取函数指针来支持VAO\"><a href=\"#用扩展的形式获取函数指针来支持VAO\" class=\"headerlink\" title=\"用扩展的形式获取函数指针来支持VAO\"></a>用扩展的形式获取函数指针来支持VAO</h3><p><img src=\"/2023/04/14/4-6-VBO%E4%B8%8EVAO/23.jpg\"></p>\n<h3 id=\"1）创建-VAO\"><a href=\"#1）创建-VAO\" class=\"headerlink\" title=\"1）创建 VAO\"></a>1）创建 VAO</h3><p>(*pFNglGenVertexArraysOES)(VAO_NUM, obj-&gt;VAO);</p>\n<h3 id=\"2）绑定-VAO\"><a href=\"#2）绑定-VAO\" class=\"headerlink\" title=\"2）绑定 VAO\"></a>2）绑定 VAO</h3><p>pFNglbindvertexarrayOES(obj-&gt;VAO);</p>\n<h3 id=\"3）解绑-VAO\"><a href=\"#3）解绑-VAO\" class=\"headerlink\" title=\"3）解绑 VAO\"></a>3）解绑 VAO</h3><p>pFNglbindvertexarrayOES(0);&#x2F;&#x2F;解绑 VAO</p>\n","site":{"data":{"style":""}},"length":6026,"excerpt":"<h1 id=\"OpenGl-ES—VBO-VAO\"><a href=\"#OpenGl-ES—VBO-VAO\" class=\"headerlink\" title=\"OpenGl ES—VBO,VAO\"></a>OpenGl ES—VBO,VAO</h1><h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1.简介\"></a>1.简介</h2><p>VBO,VAO和EBO:</p>\n<ul>\n<li><p>VBO(Vertex Buffer Object):顶点缓冲区对象</p>\n</li>\n<li><p>VAO(顶点数组对象):顶点数组对象</p>\n</li>\n<li><p>EBO（Element Buffer Object）:元素缓冲对象</p>\n<p>问：为什么要有VAO与VBO？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">起因：</span></span><br><span class=\"line\"><span class=\"comment\">在opengl es编程中，用于绘制的顶点数据首先保存在CPU内存，在调用glDrawArrays和 glDrawElements 等进行绘制时，需要将顶点数组数据从CPU内存拷贝到显存。我们没有必要每次绘制都去进行内存拷贝，若可以在显存中缓存这些数据，可以降低内存拷贝带来的开销。</span></span><br><span class=\"line\"><span class=\"comment\">所以以上VBO,VAO出现就是为了解决这个问题。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">VBO,VAO作用：在显存中提前开辟好一块内存，用于缓存顶点数据</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n</ul>","more":"<h2 id=\"2-顶点数组数据和图元索引数据：\"><a href=\"#2-顶点数组数据和图元索引数据：\" class=\"headerlink\" title=\"2.顶点数组数据和图元索引数据：\"></a>2.顶点数组数据和图元索引数据：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4 vertices, with(x,y,z) ,(r, g, b, a) per-vertex</span></span><br><span class=\"line\">GLfloat vertices[] =</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"number\">-0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,       <span class=\"comment\">// v0</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">1.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>,        <span class=\"comment\">// c0</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">-0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,       <span class=\"comment\">// v1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.0f</span>,  <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>,        <span class=\"comment\">// c1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.5f</span>, <span class=\"number\">-0.5f</span>, <span class=\"number\">0.0f</span>,        <span class=\"comment\">// v2</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.0f</span>,  <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span>,        <span class=\"comment\">// c2</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.5f</span>,  <span class=\"number\">0.5f</span>, <span class=\"number\">0.0f</span>,        <span class=\"comment\">// v3</span></span><br><span class=\"line\">\t\t\t\t<span class=\"number\">0.5f</span>,  <span class=\"number\">1.0f</span>, <span class=\"number\">1.0f</span>,        <span class=\"comment\">// c3</span></span><br><span class=\"line\">\t\t&#125;;</span><br><span class=\"line\"><span class=\"comment\">// Index buffer data</span></span><br><span class=\"line\">GLushort indices[<span class=\"number\">6</span>] = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*由于顶点位置和颜色数据在同一个数组里，一起更新到VBO里面，需要知道2个属性的步长和偏移量。为获得数据队列中下一个属性值，需向右移动6个float,其中3个是位置值，另外3个是颜色值，所以步长为6*float的字节数。</span></span><br><span class=\"line\"><span class=\"comment\">同样，需要指定位置属性和颜色属性在VBO内存中的偏移量，对于每个顶点，位置属性在前，偏移量为0，颜色属性偏移量为3sizeof(GLfloat). </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-VBO的创建和更新：\"><a href=\"#3-VBO的创建和更新：\" class=\"headerlink\" title=\"3.VBO的创建和更新：\"></a>3.VBO的创建和更新：</h2><h3 id=\"1-glGenBuffers\"><a href=\"#1-glGenBuffers\" class=\"headerlink\" title=\"1) glGenBuffers()\"></a>1) glGenBuffers()</h3><p>生成bufferID</p>\n<h3 id=\"2-glBindBuffer\"><a href=\"#2-glBindBuffer\" class=\"headerlink\" title=\"2) glBindBuffer()\"></a>2) glBindBuffer()</h3><p>操作它，参数为VBO的bufferID</p>\n<h3 id=\"3-glBufferData\"><a href=\"#3-glBufferData\" class=\"headerlink\" title=\"3) glBufferData()\"></a>3) glBufferData()</h3><p>指定里面放的数据和用法</p>\n<p>至此想用此VBO时再glBindBuffer()它的bufferID即可，里面一般放顶点数据（包括模型的xyz和纹理坐标uv），另外前提是已经编译和设定好了shader的program</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建2个VBO</span></span><br><span class=\"line\"><span class=\"built_in\">glGenBuffers</span>(<span class=\"number\">2</span>, m_VboIds);</span><br><span class=\"line\"><span class=\"comment\">//绑定第一个VBO，拷贝顶点数组到显存</span></span><br><span class=\"line\"><span class=\"built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER, m_VboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">glBufferData</span>(GL_ARRAY_BUFFER, <span class=\"built_in\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"><span class=\"comment\">//绑定第二个VBO，拷贝图元索引数据到显存</span></span><br><span class=\"line\"><span class=\"built_in\">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"built_in\">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class=\"built_in\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\"><span class=\"comment\">//GL_STATIC_DRAW 标志标识缓冲区对象数据被修改一次，使用多次，用于绘制。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-使用VBO进行渲染：\"><a href=\"#4-使用VBO进行渲染：\" class=\"headerlink\" title=\"4.使用VBO进行渲染：\"></a>4.使用VBO进行渲染：</h2><h3 id=\"1-glBindBuffer\"><a href=\"#1-glBindBuffer\" class=\"headerlink\" title=\"1) glBindBuffer()\"></a>1) glBindBuffer()</h3><p>操作想使用的VBO，参数为VBO的bufferID</p>\n<h3 id=\"2-glEnableVertexAttribArray\"><a href=\"#2-glEnableVertexAttribArray\" class=\"headerlink\" title=\"2) glEnableVertexAttribArray()\"></a>2) glEnableVertexAttribArray()</h3><p>启用与顶点相关的shader的量<br>        事先需要获取到它的handle，<br>        比如：<br>    maPositionHandle &#x3D; GLES20.glGetAttribLocation(mProgram, “aPosition”);</p>\n<h3 id=\"3-glVertexAttribPointer\"><a href=\"#3-glVertexAttribPointer\" class=\"headerlink\" title=\"3) glVertexAttribPointer ()\"></a>3) glVertexAttribPointer ()</h3><p>指定VBO里的数据的使用方法</p>\n<p>这里有可能有多个glVertexAttribPointer ()，它的最后一个参数是使用时每个元素的偏移量，比如顶点是xyzuv的float顶点，每个4*5个字节重复一次，则分开指定xyz坐标和纹理坐标时，最后一个参数的值分别取0和12<br>另外，最后不适用VBO时，最后一个参数可以直接指定要渲染的缓冲区</p>\n<h3 id=\"4-glDrawArrays\"><a href=\"#4-glDrawArrays\" class=\"headerlink\" title=\"4) glDrawArrays()\"></a>4) glDrawArrays()</h3><p>指定画法（一般为GL_TRIANGLES，即三角形），数量等，即可使用VBO进行绘制</p>\n<h3 id=\"5-glDrawElements\"><a href=\"#5-glDrawElements\" class=\"headerlink\" title=\"5) glDrawElements()\"></a>5) glDrawElements()</h3><p>这是另一种画法，可以通过指定顶点索引的方式来画图形<br>使用这种方法渲染时，应该生成两块VBO buffer，一个用来存放顶点信息，另一个来存放索引信息，和普通顶点VBO区别是，存放顶点的VBO应该在使用和指定数据时使用GL_ELEMENT_ARRAY_BUFFER，再使用glDrawElements(). 例如</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mBufferHandle[<span class=\"number\">1</span>]); </span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER,Count,buffer,GL_STATIC_DRAW); </span><br><span class=\"line\">glDrawElements(GL_TRIANGLES,count,GL_UNSIGNED_SHORT, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"es2-0-VBO例子\"><a href=\"#es2-0-VBO例子\" class=\"headerlink\" title=\"es2.0 VBO例子\"></a>es2.0 VBO例子</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glGenBuffers(VAO_NUM, obj-&gt;vert_VBO);<span class=\"comment\">//创建VBO</span></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, *vert_VBO);<span class=\"comment\">//绑定VBO</span></span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(GLfloat) * vert_elm_step * vert_rows, &amp;vert_Data[<span class=\"number\">0</span>], GL_DYNAMIC_DRAW);<span class=\"comment\">//指定里面放的数据和用法，拷贝顶点数组到显存</span></span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\">attribute vec4 position;<span class=\"comment\">//shader中的输入</span></span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\">mPositionLocation = glGetAttribLocation(mProgram, <span class=\"string\">&quot;position&quot;</span>);<span class=\"comment\">//获取到position的handle</span></span><br><span class=\"line\">glEnableVertexAttribArray(mPositionLocation);<span class=\"comment\">//启用与顶点相关的shader的量</span></span><br><span class=\"line\">glVertexAttribPointer(mPositionLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"keyword\">sizeof</span>(Vertex), <span class=\"number\">0</span>);<span class=\"comment\">//指定VBO里的数据的使用方法</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"es3-0-VBO例子\"><a href=\"#es3-0-VBO例子\" class=\"headerlink\" title=\"es3.0 VBO例子\"></a>es3.0 VBO例子</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//顶点着色器</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es                            </span></span><br><span class=\"line\">layout(location = <span class=\"number\">0</span>) in vec4 a_position;   <span class=\"comment\">// 位置变量的属性位置值为 0 </span></span><br><span class=\"line\">layout(location = <span class=\"number\">1</span>) in vec3 a_color;      <span class=\"comment\">// 颜色变量的属性位置值为 1</span></span><br><span class=\"line\">out vec3 v_color;                          <span class=\"comment\">// 向片段着色器输出一个颜色                          </span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>                                </span><br><span class=\"line\">&#123;                                          </span><br><span class=\"line\">    v_color = a_color;                     </span><br><span class=\"line\">    gl_Position = a_position;              </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//片段着色器</span></span><br><span class=\"line\"><span class=\"meta\">#version 300 es</span></span><br><span class=\"line\">precision mediump <span class=\"type\">float</span>;</span><br><span class=\"line\">in vec3 v_color;</span><br><span class=\"line\">out vec4 o_fragColor;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    o_fragColor = vec4(v_color, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\"> <span class=\"comment\">//创建2个VBO</span></span><br><span class=\"line\">glGenBuffers(<span class=\"number\">2</span>, m_VboIds);</span><br><span class=\"line\"><span class=\"comment\">//绑定第一个VBO，拷贝顶点数组到显存</span></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, m_VboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glBufferData(GL_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class=\"line\"><span class=\"comment\">//绑定第二个VBO，拷贝图元索引数据到显存</span></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class=\"keyword\">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\">glUseProgram(m_ProgramObj);</span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">//不使用 VBO 的绘制</span></span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"keyword\">sizeof</span>(GLfloat), vertices);</span><br><span class=\"line\"></span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"keyword\">sizeof</span>(GLfloat), (vertices + <span class=\"number\">3</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_SHORT, indices);</span><br><span class=\"line\"><span class=\"comment\">//---------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\">//使用 VBO 的绘制</span></span><br><span class=\"line\">glBindBuffer(GL_ARRAY_BUFFER, m_VboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">0</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">const</span> <span class=\"type\">void</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\">glEnableVertexAttribArray(<span class=\"number\">1</span>);</span><br><span class=\"line\">glVertexAttribPointer(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"keyword\">sizeof</span>(GLfloat), (<span class=\"type\">const</span> <span class=\"type\">void</span> *)(<span class=\"number\">3</span> *<span class=\"keyword\">sizeof</span>(GLfloat)));</span><br><span class=\"line\"></span><br><span class=\"line\">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">glDrawElements(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_SHORT, (<span class=\"type\">const</span> <span class=\"type\">void</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-VAO的创建和更新\"><a href=\"#6-VAO的创建和更新\" class=\"headerlink\" title=\"6.VAO的创建和更新\"></a>6.VAO的创建和更新</h2><p> 顶点数组对象，VAO作用：管理VBO，减少glBindBuffer,glEnableVertexAttribArray,glVertexAttribPointer这些调用操作。 </p>\n<p><img src=\"/2023/04/14/4-6-VBO%E4%B8%8EVAO/22.png\"></p>\n<h3 id=\"1-glGenVertexArrays\"><a href=\"#1-glGenVertexArrays\" class=\"headerlink\" title=\"1)\tglGenVertexArrays()\"></a>1)\tglGenVertexArrays()</h3><h3 id=\"2-glBindVertexArray\"><a href=\"#2-glBindVertexArray\" class=\"headerlink\" title=\"2)\tglBindVertexArray()\"></a>2)\tglBindVertexArray()</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建并绑定 VAO</span></span><br><span class=\"line\"><span class=\"built_in\">glGenVertexArrays</span>(<span class=\"number\">1</span>, &amp;m_VaoId);</span><br><span class=\"line\"><span class=\"built_in\">glBindVertexArray</span>(m_VaoId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在绑定 VAO 之后，操作 VBO ，当前 VAO 会记录 VBO 的操作</span></span><br><span class=\"line\"><span class=\"built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER, m_VboIds[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">0</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"built_in\">sizeof</span>(GLfloat), (<span class=\"type\">const</span> <span class=\"type\">void</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, (<span class=\"number\">3</span>+<span class=\"number\">3</span>)*<span class=\"built_in\">sizeof</span>(GLfloat), (<span class=\"type\">const</span> <span class=\"type\">void</span> *)(<span class=\"number\">3</span> *<span class=\"built_in\">sizeof</span>(GLfloat)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_VboIds[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glBindVertexArray</span>(GL_NONE);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-使用VAO进行渲染：\"><a href=\"#7-使用VAO进行渲染：\" class=\"headerlink\" title=\"7.使用VAO进行渲染：\"></a>7.使用VAO进行渲染：</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glUseProgram</span>(m_ProgramObj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glBindVertexArray</span>(m_VaoId);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glDrawElements</span>(GL_TRIANGLES, <span class=\"number\">6</span>, GL_UNSIGNED_SHORT, (<span class=\"type\">const</span> <span class=\"type\">void</span> *)<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-如何让OpenES2-0支持VAO？\"><a href=\"#8-如何让OpenES2-0支持VAO？\" class=\"headerlink\" title=\"8.如何让OpenES2.0支持VAO？\"></a>8.如何让OpenES2.0支持VAO？</h2><p>如果标准里没有定义一个函数, 可以用扩展的形式取得函数指针, 然后判断函数指针是否为空, 不为空就可以使用这个函数了.</p>\n<p>例如: 获取 VAO的扩展, 这个在OpenGL2.0标准里没有定义, 只能通过扩展的形式取得.</p>\n<p>如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;GLES2/gl2.h&gt;</span></span></span><br><span class=\"line\">        <span class=\"comment\">/* VAO   获取VAO扩展 in opengl2.0*/</span></span><br><span class=\"line\">           PFNGLGENVERTEXARRAYSOESPROC glGenVertexArrays = (PFNGLGENVERTEXARRAYSOESPROC) <span class=\"built_in\">eglGetProcAddress</span>(<span class=\"string\">&quot;glGenVertexArraysOES&quot;</span>);</span><br><span class=\"line\">           PFNGLBINDVERTEXARRAYOESPROC glBindVertexArray = (PFNGLBINDVERTEXARRAYOESPROC) <span class=\"built_in\">eglGetProcAddress</span>(<span class=\"string\">&quot;glBindVertexArrayOES&quot;</span>);</span><br><span class=\"line\">           PFNGLDELETEVERTEXARRAYSOESPROC glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSOESPROC) <span class=\"built_in\">eglGetProcAddress</span>(<span class=\"string\">&quot;glDeleteVertexArraysOES&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>OpenGL ES 扩展头文件GLES2&#x2F;gl2ext.h</p>\n<p><img src=\"/2023/04/14/4-6-VBO%E4%B8%8EVAO/24.png\"></p>\n<h3 id=\"用扩展的形式获取函数指针来支持VAO\"><a href=\"#用扩展的形式获取函数指针来支持VAO\" class=\"headerlink\" title=\"用扩展的形式获取函数指针来支持VAO\"></a>用扩展的形式获取函数指针来支持VAO</h3><p><img src=\"/2023/04/14/4-6-VBO%E4%B8%8EVAO/23.jpg\"></p>\n<h3 id=\"1）创建-VAO\"><a href=\"#1）创建-VAO\" class=\"headerlink\" title=\"1）创建 VAO\"></a>1）创建 VAO</h3><p>(*pFNglGenVertexArraysOES)(VAO_NUM, obj-&gt;VAO);</p>\n<h3 id=\"2）绑定-VAO\"><a href=\"#2）绑定-VAO\" class=\"headerlink\" title=\"2）绑定 VAO\"></a>2）绑定 VAO</h3><p>pFNglbindvertexarrayOES(obj-&gt;VAO);</p>\n<h3 id=\"3）解绑-VAO\"><a href=\"#3）解绑-VAO\" class=\"headerlink\" title=\"3）解绑 VAO\"></a>3）解绑 VAO</h3><p>pFNglbindvertexarrayOES(0);&#x2F;&#x2F;解绑 VAO</p>"},{"title":"GLSL着色器语言","date":"2023-04-14T13:53:11.000Z","comments":0,"description":null,"typora-root-url":"4-7-GLSL着色器语言","_content":"\n# GLSL着色器语言\n\n<!--more-->\n\n## 1.OpenGL ES 2.0\n\n（ES2.0也支持OES外部纹理）\n\n```cpp\n/***********************GLRender Normal texture***********************************/\n\nstatic const char CommonVertshader_Normal[] =\n//\" #version 300 es \\n \"//着色器版本声明OpenGL ES 3.0\n\" #version 100 es \\n \"//不添加版本声明或者使用 #version 100 es 声明版本则指定使用 OpenGL ES 2.0\n\" precision mediump float;\\n \"//指定float类型默认的mediump中精度（-2^14 ~ 2^14）\n    \n//\" layout(location = 0) in vec4 vPosition; \\n \"//输入vPosition顶点坐标\n//\" layout(location = 1) in vec2 vTexCoord; \\n \"//输入vTexCoord纹理坐标vec2\n//\" out vec3 TexCoord; \\n \"//输出纹理坐标vec3\n\" attribute vec4 vPosition; \\n \"//ES2.0中attribute，ES3.0中in\n\" attribute vec2 vTexCoord; \\n \"//ES2.0中attribute，ES3.0中in\n\" varying vec3 TexCoord; \\n \"//ES2.0中varying，ES3.0中out\n    \n\" uniform mat4 mvp; \\n\"//uniform用于ES传入数据mvp\n\" void main() \\n \"//主函数\n\" { \\n \"\n\t\"vec4 temPosition = mvp * vec4(vPosition.x, vPosition.y, vPosition.z, 1); \\n\"\n    \" gl_Position = vec4(temPosition.x, -temPosition.y, temPosition.z, temPosition.a); \\n \"//内建变量gl_Position顶点坐标\n    \" TexCoord = vec3(vTexCoord, vPosition.w); \\n \"\n\" } \\n \";\n\nstatic const char CommonFragshader_Normal[] =\n//\"#version 300 es \\n\"\n\"#extension GL_OES_EGL_image_external : require \\n\"//启用扩展（ES2.0也支持OES外部纹理）\n\" precision mediump float;\\n \"//Fragshader使用浮点型时必须指定精度，指定float类型默认的mediump中精度（-2^14 ~ 2^14）\n    \n//\" in vec3 TexCoord; \\n \"//输入vTexCoord纹理坐标vec3,从Vertshader中传入的\n//\" out vec4 fragColor; \\n \"//输出片元颜色\n\" attribute vec3 TexCoord; \\n \"//ES2.0中attribute，ES3.0中in\n\" varying vec4 fragColor; \\n \"//ES2.0中varying，ES3.0中out\n    \n\"uniform sampler2D myTexture;\\n\"//ES 2.0支持sample2D纹理和sampleCube纹理\n\" uniform vec4 myGain; \\n \"//uniform用于ES传入数据myGain\n\" void main() \\n \"//主函数\n\" {\\n \"\n//\"  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, TexCoord.z)+vec4(myGain.xyz,0.0); \\n \"//2.25\n\"  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, 1.0); \\n \"//2.25\n//\"\t fragColor = vec4(0.3, 0.4, 0.5, TexCoord.z)+vec4(myGain.xyz,0.0); \\n \"\n\" }\\n \";\n```\n\n\n\n## 2.OpenGL ES 3.0\n\n```cpp\n/***********************GLRender Normal texture***********************************/\n\nstatic const char CommonVertshader_Normal[] =\n\" #version 300 es \\n \"\n\" precision mediump float;\\n \"\n\" layout(location = 0) in vec4 vPosition; \\n \"\n\" layout(location = 1) in vec2 vTexCoord; \\n \"\n\" out vec3 TexCoord; \\n \"\n\" uniform mat4 mvp; \\n\"\n\" void main() \\n \"\n\" { \\n \"\n\t\"vec4 temPosition = mvp * vec4(vPosition.x, vPosition.y, vPosition.z, 1); \\n\"\n    \" gl_Position = vec4(temPosition.x, -temPosition.y, temPosition.z, temPosition.a); \\n \"\n    \" TexCoord = vec3(vTexCoord, vPosition.w); \\n \"\n\" } \\n \";\n\nstatic const char CommonFragshader_Normal[] =\n\"#version 300 es \\n\"\n#if (!VT_SAMPLE2D_SELECTED && !FIX_CAMERA_IMAGE)\n\"#extension GL_OES_EGL_image_external : require \\n\"\n#endif\n\" precision mediump float;\\n \"\n\" in vec3 TexCoord; \\n \"\n\" out vec4 fragColor; \\n \"\n#if (VT_SAMPLE2D_SELECTED || FIX_CAMERA_IMAGE)\n\"uniform sampler2D myTexture;\\n\"\n#else\n\" uniform samplerExternalOES myTexture; \\n \"\n#endif\n\" uniform vec4 myGain; \\n \"\n\" void main() \\n \"\n\" {\\n \"\n//\"  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, TexCoord.z)+vec4(myGain.xyz,0.0); \\n \"//2.25\n\"  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, 1.0); \\n \"//2.25\n//\"\t fragColor = vec4(0.3, 0.4, 0.5, TexCoord.z)+vec4(myGain.xyz,0.0); \\n \"\n\" }\\n \";\n```\n\n## 3.着色器语言简介\n\nOpenGLES的着色器语言GLSL是一种高级的图形化编程语言，其源自应用广泛的C语言。与传统的C语言不同的是，它提供了更加丰富的针对于图像处理的原生类型，诸如向量、矩阵之类。OpenGLES 主要包含以下特性：\n\n- GLSL是一种面向过程的语言，和Java的面向对象是不同的。\n- GLSL的基本语法与C/C++基本相同。\n- 它完美的支持向量和矩阵操作。\n- 它是通过限定符操作来管理输入输出类型的。\n- GLSL提供了大量的内置函数来提供丰富的扩展功能。\n\n## 4.数据类型\n\nGLSL中的数据类型主要分为标量、向量、矩阵、采样器、结构体、数组、空类型七种类型：\n\n- 标量：标量表示的是只有大小没有方向的量，在GLSL中标量只有bool、int和float三种。对于int，和C一样，可以写为十进制（16）、八进制（020）或者十六进制（0x10）。关于进制不了解的，得自己补补，这是编程基础。**对于标量的运算，我们最需要注意的是精度，防止溢出问题**。\n- 向量：向量我们可以看做是数组，在GLSL通常用于储存颜色、坐标等数据，针对维数，可分为二维、三维和四位向量。针对存储的标量类型，可以分为bool、int和float。共有vec2、vec3、vec4，ivec2、ivec3、ivec4、bvec2、bvec3和bvec4九种类型，数组代表维数、i表示int类型、b表示bool类型。**需要注意的是，GLSL中的向量表示竖向量，所以与矩阵相乘进行变换时，矩阵在前，向量在后（与DirectX正好相反）**。向量在GPU中由硬件支持运算，比CPU快的多。\n\n> 1. 作为颜色向量时，用rgba表示分量，就如同取数组的中具体数据的索引值。三维颜色向量就用rgb表示分量。比如对于颜色向量vec4 color，color[0]和color.r都表示color向量的第一个值，也就是红色的分量。其他相同。\n> 2. 作为位置向量时，用xyzw表示分量，xyz分别表示xyz坐标，w表示向量的模。三维坐标向量为xyz表示分量，二维向量为xy表示分量。\n> 3. 作为纹理向量时，用stpq表示分量，三维用stp表示分量，二维用st表示分量。\n\n- 矩阵：在GLSL中矩阵拥有2*2、3*3、4*4三种类型的矩阵，分别用mat2、mat3、mat4表示。我们可以把矩阵看做是一个二维数组，也可以用二维数组下表的方式取里面具体位置的值。\n- 采样器：采样器是专门用来对纹理进行采样工作的，在GLSL中一般来说，一个采样器变量表示一副或者一套纹理贴图。所谓的纹理贴图可以理解为我们看到的物体上的皮肤。\n- 结构体：和C语言中的结构体相同，用struct来定义结构体，关于结构体参考C语言中的结构体。\n- 数组：数组知识也和C中相同，不同的是数组声明时可以不指定大小，但是建议在不必要的情况下，还是指定大小的好。\n- 空类型：空类型用void表示，仅用来声明不返回任何值得函数。\n\n```c\nfloat a=1.0;\nint b=1;\nbool c=true;\nvec2 d=vec2(1.0,2.0);\nvec3 e=vec3(1.0,2.0,3.0)\nvec4 f=vec4(vec3,1.2);\nvec4 g=vec4(0.2);  //相当于vec(0.2,0.2,0.2,0.2)\nvec4 h=vec4(a,a,1.3,a);\nmat2 i=mat2(0.1,0.5,1.2,2.4);\nmat2 j=mat2(0.8);   //相当于mat2(0.8,0.8,0.8,0.8)\nmat3 k=mat3(e,e,1.2,1.6,1.8);\n```\n\n## 5.运算符\n\nGLSL中的运算符有（越靠前，运算优先级越高）：\n\n1. 索引：[]\n2. 前缀自加和自减：++，–\n3. 一元非和逻辑非：~，！\n4. 加法和减法：+，-\n5. 等于和不等于：==，！=\n6. 逻辑异或：^^\n7. 三元运算符号，选择：？:\n8. 成员选择与混合：.\n9. 后缀自加和自减：++，–\n10. 乘法和除法：*，/\n11. 关系运算符：>，<，=，>=，<=，<>\n12. 逻辑与：&&\n13. 逻辑或：||\n14. 赋值预算：=，+=，-=，*=，/=\n\n## 6.类型转换\n\nGLSL的类型转换与C不同。在GLSL中类型不可以自动提升，比如float a=1;就是一种错误的写法，必须严格的写成float a=1.0，也不可以强制转换，即float a=(float)1;也是错误的写法，但是可以用内置函数来进行转换，如float a=float(1);还有float a=float(true);（true为1.0，false为0.0）等，值得注意的是，**低精度的int不能转换为低精度的float**。\n\n## 7.限定符\n\nGLSL中的限定符号主要有：\n\n- attritude：一般用于各个顶点各不相同的量。如顶点颜色、坐标等。\n- uniform：一般用于对于3D物体中所有顶点都相同的量。比如光源位置，统一变换矩阵等。\n- varying：表示易变量，一般用于顶点着色器传递到片元着色器的量。\n- const：常量。\n\n限定符与java限定符类似，放在变量类型之前，并且只能用于全局变量。在GLSL中，没有默认限定符一说。\n\n## 8.流程控制\n\nGLSL中的流程控制与C中基本相同，主要有：\n\n```c\n    if(){}、if(){}else{}、if(){}else if(){}else{}\n    while(){}和do{}while()\n    for(;;){}\n    break和continue\n```\n\n## 9.函数\n\nGLSL中也可以定义函数，定义函数的方式也与C语言基本相同。函数的返回值可以是GLSL中的除了采样器的任意类型。对于GLSL中函数的参数，可以用参数用途修饰符来进行修饰，常用修饰符如下：\n\n- in：输入参数，无修饰符时默认为此修饰符。\n- out：输出参数。\n- inout：既可以作为输入参数，又可以作为输出参数。\n\n## 10.浮点精度\n\n与顶点着色器不同的是，在片元着色器中使用浮点型时，必须指定浮点类型的精度，否则编译会报错。精度有三种，分别为：\n\n- lowp：低精度。8位。\n- mediump：中精度。10位。\n- highp：高精度。16位。\n\n具体如下表：\n\n![](21.webp)\n\n不仅仅是float可以制定精度，其他（除了bool相关）类型也同样可以，但是int、采样器类型并不一定要求指定精度。加精度的定义如下：\n\n```c\nuniform lowp float a=1.0;\nvarying mediump vec4 c;\n```\n\n当然，也可以在片元着色器中设置默认精度，只需要在片元着色器最上面加上precision <精度> <类型>即可制定某种类型的默认精度。其他情况相同的话，精度越高，画质越好，使用的资源也越多。\n\n```c\nprecision mediump float;\n```\n\n## 11.程序结构\n\nGLSL程序的结构和C语言差不多，main()方法表示入口函数，可以在其上定义函数和变量，在main中可以引用这些变量和函数。定义在函数体以外的叫做全局变量，定义在函数体内的叫做局部变量。与高级语言不通的是，变量和函数在使用前必须声明，不能再使用的后面声明变量或者函数。\n\n## 12.内建变量\n\n在着色器中我们一般都会声明变量来在程序中使用，但是着色器中还有一些特殊的变量，不声明也可以使用。这些变量叫做内建变量。內建变量，相当于着色器硬件的输入和输出点，使用者利用这些输入点输入之后，就会看到屏幕上的输出。通过输出点可以知道输出的某些数据内容。当然，实际上肯定不会这样简单，这么说只是为了帮助理解。在顶点着色器中的内建变量和片元着色器的内建变量是不相同的。着色器中的内建变量有很多，在此，我们只列出最常用的集中内建变量。\n\n 顶点着色器的内建变量\n\n```undefined\n输入变量：\n    gl_Position：顶点坐标\n    gl_PointSize：点的大小，没有赋值则为默认值1，通常设置绘图为点绘制才有意义。\n```\n\n片元着色器的内建变量\n\n```cpp\n1. 输入变量\n    gl_FragCoord：当前片元相对窗口位置所处的坐标。\n    gl_FragFacing：bool型，表示是否为属于光栅化生成此片元的对应图元的正面。\n\n2. 输出变量\n    gl_FragColor：当前片元颜色\n    gl_FragData：vec4类型的数组。向其写入的信息，供渲染管线的后继过程使用。\n```\n\n## 13.常用内置函数\n\n### 13.1常见函数\n\n```css\n    radians(x)：角度转弧度\n    degrees(x)：弧度转角度\n    sin(x)：正弦函数，传入值为弧度。相同的还有cos余弦函数、tan正切函数、asin反正弦、acos反余弦、atan反正切\n    pow(x,y)：xy\n    exp(x)：ex\n    exp2(x)：2x\n    log(x)：logex\n    log2(x)：log2x\n    sqrt(x)：x√\n    inversesqr(x)：1x√\n    abs(x)：取x的绝对值\n    sign(x)：x>0返回1.0，x<0返回-1.0，否则返回0.0\n    ceil(x)：返回大于或者等于x的整数\n    floor(x)：返回小于或者等于x的整数\n    fract(x)：返回x-floor(x)的值\n    mod(x,y)：取模（求余）\n    min(x,y)：获取xy中小的那个\n    max(x,y)：获取xy中大的那个\n    mix(x,y,a)：返回x∗(1−a)+y∗a\n    step(x,a)：x< a返回0.0，否则返回1.0\n    smoothstep(x,y,a)：a < x返回0.0，a>y返回1.0，否则返回0.0-1.0之间平滑的Hermite插值。\n    dFdx(p)：p在x方向上的偏导数\n    dFdy(p)：p在y方向上的偏导数\n    fwidth(p)：p在x和y方向上的偏导数的绝对值之和\n```\n\n### 13.2几何函数\n\n```css\n    length(x)：计算向量x的长度\n    distance(x,y)：返回向量xy之间的距离\n    dot(x,y)：返回向量xy的点积\n    cross(x,y)：返回向量xy的差积\n    normalize(x)：返回与x向量方向相同，长度为1的向量\n```\n\n### 13.3矩阵函数\n\n```css\n    matrixCompMult(x,y)：将矩阵相乘\n    lessThan(x,y)：返回向量xy的各个分量执行x< y的结果，类似的有greaterThan,equal,notEqual\n    lessThanEqual(x,y)：返回向量xy的各个分量执行x<= y的结果，类似的有类似的有greaterThanEqual\n    any(bvec x)：x有一个元素为true，则为true\n    all(bvec x)：x所有元素为true，则返回true，否则返回false\n    not(bvec x)：x所有分量执行逻辑非运算\n```\n\n### 13.4纹理采样函数\n\n纹理采样函数有texture2D、texture2DProj、texture2DLod、texture2DProjLod、textureCube、textureCubeLod及texture3D、texture3DProj、texture3DLod、texture3DProjLod等。\n\n```css\n    texture表示纹理采样，2D表示对2D纹理采样，3D表示对3D纹理采样\n    Lod后缀，只适用于顶点着色器采样\n    Proj表示纹理坐标st会除以q\n```\n\n纹理采样函数中，3D在OpenGLES2.0并不是绝对支持。我们再次暂时不管3D纹理采样函数。重点只对texture2D函数进行说明。texture2D拥有三个参数，第一个参数表示纹理采样器。第二个参数表示纹理坐标，可以是二维、三维、或者四维。第三个参数加入后只能在片元着色器中调用，且只对采样器为mipmap类型纹理时有效。\n\n## 14.attribute、uniform、varying、in、out\n\n### 1.attribute:\n\n根据OpenGL2.0和OpenGLES2.0标准，仅用在VertexShader中，至少支持8个attribute属性。OpenGL3.0里，至少支持16个。通常用来存储位置坐标、法向量、纹理坐标和颜色等。我们在上一阶段的OpenGL学习中每个Shader都有用到。 \n\n```css\nattribute vec4 position;\nattribute vec4 color;\nattribute vec4 texcoord;\nattribute vec4 normal;\n```\n\n####  方法一：\n\n在C++中先获取在哪个属性组： \n\n```css\nmPositionLocation = glGetAttribLocation(mProgram, \"position\");\nmColorLocation = glGetAttribLocation(mProgram, \"color\");\nmTexcoordLocation = glGetAttribLocation(mProgram, \"texcoord\");\nmNormalLocation = glGetAttribLocation(mProgram, \"normal\");\n```\n\n设置VBO与通用属性组关系：\n\n```cpp\nglEnableVertexAttribArray(mPositionLocation);\nglVertexAttribPointer(mPositionLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);\nglEnableVertexAttribArray(mColorLocation);\nglVertexAttribPointer(mColorLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(sizeof(float) * 4));\nglEnableVertexAttribArray(mTexcoordLocation);\nglVertexAttribPointer(mTexcoordLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(sizeof(float) * 8));\nglEnableVertexAttribArray(mNormalLocation);\nglVertexAttribPointer(mNormalLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(sizeof(float) * 12));\n```\n\n#### 方法二：\n\n```cpp\nGLbyte vertexShaderSrc[] =\n\"attribute vec4 a_position; \\n\"\n\"attribute vec4 a_color; \\n\"\n\"varying vec4 v_color; \\n\"\n\"void main() \\n\"\n\"{ \\n\"\n\" v_color = a_color; \\n\"\n\" gl_Position = a_position; \\n\"\n\"}\";\nGLbyte fragmentShaderSrc[] =\n\"varying vec4 v_color; \\n\"\n\"void main() \\n\"\n\"{ \\n\"\n\" gl_FragColor = v_color; \\n\"\n\"}\";\nGLfloat color[4] = { 1.0f, 0.0f, 0.0f, 1.0f };\nGLfloat vertexPos[3 * 3]; // 3 vertices, with (x,y,z) per-vertex\nGLuint shaderObject[2];\nGLuint programObject;\nshaderObject[0] = LoadShader(vertexShaderSrc, GL_VERTEX_SHADER);\nshaderObject[1] = LoadShader(fragmentShaderSrc, GL_FRAGMENT_SHADER);\nprogramObject = glCreateProgram();\nglAttachShader(programObject, shaderObject[0]);\nglAttachShader(programObject, shaderObject[1]);\n\nglVertexAttrib4fv(0, color);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, vertexPos);\nglEnableVertexAttribArray(1);\nglBindAttribLocation(programObject, 0, \"a_color\");\nglBindAttribLocation(programObject, 1, \"a_position\");\nglLinkProgram(programObject);\nglUseProgram(programObject);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n\n\n### 2.unifrom:\n\n可存在所有shader中，OpenGL2.0中，数量至少有128个。可存放矩阵、材质等任何attribute放不下的属性。\n\n```css\nuniform mat4 ModelMatrix;\nuniform mat4 ViewMatrix;\nuniform mat4 ProjectionMatrix;\n```\n\n在C++中，先获取位置：c\n\n```css\nmModelMatrixLocation = glGetUniformLocation(mProgram, \"ModelMatrix\");\nmViewMatrixLocation = glGetUniformLocation(mProgram, \"ViewMatrix\");\nmProjectionMatrixLocation = glGetUniformLocation(mProgram, \"ProjectionMatrix\");\n```\n\n\n设置参数：\n\n```css\nglUniformMatrix4fv(mModelMatrixLocation, 1, GL_FALSE, M);\nglUniformMatrix4fv(mViewMatrixLocation, 1, GL_FALSE, V);\nglUniformMatrix4fv(mProjectionMatrixLocation, 1, GL_FALSE, P);\n```\n\n### 3.varying:\n\n用于shader之间的数据传递，在OpenGL2.0。最多传递8个Vec4大小的数据，即2个mat4矩阵。\n\n```css\nvarying vec4 V_Texcoord;\n```\n\n### 4.in:\n\n表示某个Shader阶段的输入。varying可以改为in。即fs中的输入为vs中的输出。\n\n### 5.out:\n\n代表每个shader的输出。也可以代替varying。in和out在3.0之后的版本使用。","source":"_posts/4-7-GLSL着色器语言.md","raw":"---\ntitle: GLSL着色器语言\ndate: 2023-4-14 21:53:11\ncategories: 笔记\ntags: [嵌入式,OpenGL]\ncomments: false\ndescription:\ntypora-root-url: 4-7-GLSL着色器语言\n\n---\n\n# GLSL着色器语言\n\n<!--more-->\n\n## 1.OpenGL ES 2.0\n\n（ES2.0也支持OES外部纹理）\n\n```cpp\n/***********************GLRender Normal texture***********************************/\n\nstatic const char CommonVertshader_Normal[] =\n//\" #version 300 es \\n \"//着色器版本声明OpenGL ES 3.0\n\" #version 100 es \\n \"//不添加版本声明或者使用 #version 100 es 声明版本则指定使用 OpenGL ES 2.0\n\" precision mediump float;\\n \"//指定float类型默认的mediump中精度（-2^14 ~ 2^14）\n    \n//\" layout(location = 0) in vec4 vPosition; \\n \"//输入vPosition顶点坐标\n//\" layout(location = 1) in vec2 vTexCoord; \\n \"//输入vTexCoord纹理坐标vec2\n//\" out vec3 TexCoord; \\n \"//输出纹理坐标vec3\n\" attribute vec4 vPosition; \\n \"//ES2.0中attribute，ES3.0中in\n\" attribute vec2 vTexCoord; \\n \"//ES2.0中attribute，ES3.0中in\n\" varying vec3 TexCoord; \\n \"//ES2.0中varying，ES3.0中out\n    \n\" uniform mat4 mvp; \\n\"//uniform用于ES传入数据mvp\n\" void main() \\n \"//主函数\n\" { \\n \"\n\t\"vec4 temPosition = mvp * vec4(vPosition.x, vPosition.y, vPosition.z, 1); \\n\"\n    \" gl_Position = vec4(temPosition.x, -temPosition.y, temPosition.z, temPosition.a); \\n \"//内建变量gl_Position顶点坐标\n    \" TexCoord = vec3(vTexCoord, vPosition.w); \\n \"\n\" } \\n \";\n\nstatic const char CommonFragshader_Normal[] =\n//\"#version 300 es \\n\"\n\"#extension GL_OES_EGL_image_external : require \\n\"//启用扩展（ES2.0也支持OES外部纹理）\n\" precision mediump float;\\n \"//Fragshader使用浮点型时必须指定精度，指定float类型默认的mediump中精度（-2^14 ~ 2^14）\n    \n//\" in vec3 TexCoord; \\n \"//输入vTexCoord纹理坐标vec3,从Vertshader中传入的\n//\" out vec4 fragColor; \\n \"//输出片元颜色\n\" attribute vec3 TexCoord; \\n \"//ES2.0中attribute，ES3.0中in\n\" varying vec4 fragColor; \\n \"//ES2.0中varying，ES3.0中out\n    \n\"uniform sampler2D myTexture;\\n\"//ES 2.0支持sample2D纹理和sampleCube纹理\n\" uniform vec4 myGain; \\n \"//uniform用于ES传入数据myGain\n\" void main() \\n \"//主函数\n\" {\\n \"\n//\"  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, TexCoord.z)+vec4(myGain.xyz,0.0); \\n \"//2.25\n\"  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, 1.0); \\n \"//2.25\n//\"\t fragColor = vec4(0.3, 0.4, 0.5, TexCoord.z)+vec4(myGain.xyz,0.0); \\n \"\n\" }\\n \";\n```\n\n\n\n## 2.OpenGL ES 3.0\n\n```cpp\n/***********************GLRender Normal texture***********************************/\n\nstatic const char CommonVertshader_Normal[] =\n\" #version 300 es \\n \"\n\" precision mediump float;\\n \"\n\" layout(location = 0) in vec4 vPosition; \\n \"\n\" layout(location = 1) in vec2 vTexCoord; \\n \"\n\" out vec3 TexCoord; \\n \"\n\" uniform mat4 mvp; \\n\"\n\" void main() \\n \"\n\" { \\n \"\n\t\"vec4 temPosition = mvp * vec4(vPosition.x, vPosition.y, vPosition.z, 1); \\n\"\n    \" gl_Position = vec4(temPosition.x, -temPosition.y, temPosition.z, temPosition.a); \\n \"\n    \" TexCoord = vec3(vTexCoord, vPosition.w); \\n \"\n\" } \\n \";\n\nstatic const char CommonFragshader_Normal[] =\n\"#version 300 es \\n\"\n#if (!VT_SAMPLE2D_SELECTED && !FIX_CAMERA_IMAGE)\n\"#extension GL_OES_EGL_image_external : require \\n\"\n#endif\n\" precision mediump float;\\n \"\n\" in vec3 TexCoord; \\n \"\n\" out vec4 fragColor; \\n \"\n#if (VT_SAMPLE2D_SELECTED || FIX_CAMERA_IMAGE)\n\"uniform sampler2D myTexture;\\n\"\n#else\n\" uniform samplerExternalOES myTexture; \\n \"\n#endif\n\" uniform vec4 myGain; \\n \"\n\" void main() \\n \"\n\" {\\n \"\n//\"  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, TexCoord.z)+vec4(myGain.xyz,0.0); \\n \"//2.25\n\"  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, 1.0); \\n \"//2.25\n//\"\t fragColor = vec4(0.3, 0.4, 0.5, TexCoord.z)+vec4(myGain.xyz,0.0); \\n \"\n\" }\\n \";\n```\n\n## 3.着色器语言简介\n\nOpenGLES的着色器语言GLSL是一种高级的图形化编程语言，其源自应用广泛的C语言。与传统的C语言不同的是，它提供了更加丰富的针对于图像处理的原生类型，诸如向量、矩阵之类。OpenGLES 主要包含以下特性：\n\n- GLSL是一种面向过程的语言，和Java的面向对象是不同的。\n- GLSL的基本语法与C/C++基本相同。\n- 它完美的支持向量和矩阵操作。\n- 它是通过限定符操作来管理输入输出类型的。\n- GLSL提供了大量的内置函数来提供丰富的扩展功能。\n\n## 4.数据类型\n\nGLSL中的数据类型主要分为标量、向量、矩阵、采样器、结构体、数组、空类型七种类型：\n\n- 标量：标量表示的是只有大小没有方向的量，在GLSL中标量只有bool、int和float三种。对于int，和C一样，可以写为十进制（16）、八进制（020）或者十六进制（0x10）。关于进制不了解的，得自己补补，这是编程基础。**对于标量的运算，我们最需要注意的是精度，防止溢出问题**。\n- 向量：向量我们可以看做是数组，在GLSL通常用于储存颜色、坐标等数据，针对维数，可分为二维、三维和四位向量。针对存储的标量类型，可以分为bool、int和float。共有vec2、vec3、vec4，ivec2、ivec3、ivec4、bvec2、bvec3和bvec4九种类型，数组代表维数、i表示int类型、b表示bool类型。**需要注意的是，GLSL中的向量表示竖向量，所以与矩阵相乘进行变换时，矩阵在前，向量在后（与DirectX正好相反）**。向量在GPU中由硬件支持运算，比CPU快的多。\n\n> 1. 作为颜色向量时，用rgba表示分量，就如同取数组的中具体数据的索引值。三维颜色向量就用rgb表示分量。比如对于颜色向量vec4 color，color[0]和color.r都表示color向量的第一个值，也就是红色的分量。其他相同。\n> 2. 作为位置向量时，用xyzw表示分量，xyz分别表示xyz坐标，w表示向量的模。三维坐标向量为xyz表示分量，二维向量为xy表示分量。\n> 3. 作为纹理向量时，用stpq表示分量，三维用stp表示分量，二维用st表示分量。\n\n- 矩阵：在GLSL中矩阵拥有2*2、3*3、4*4三种类型的矩阵，分别用mat2、mat3、mat4表示。我们可以把矩阵看做是一个二维数组，也可以用二维数组下表的方式取里面具体位置的值。\n- 采样器：采样器是专门用来对纹理进行采样工作的，在GLSL中一般来说，一个采样器变量表示一副或者一套纹理贴图。所谓的纹理贴图可以理解为我们看到的物体上的皮肤。\n- 结构体：和C语言中的结构体相同，用struct来定义结构体，关于结构体参考C语言中的结构体。\n- 数组：数组知识也和C中相同，不同的是数组声明时可以不指定大小，但是建议在不必要的情况下，还是指定大小的好。\n- 空类型：空类型用void表示，仅用来声明不返回任何值得函数。\n\n```c\nfloat a=1.0;\nint b=1;\nbool c=true;\nvec2 d=vec2(1.0,2.0);\nvec3 e=vec3(1.0,2.0,3.0)\nvec4 f=vec4(vec3,1.2);\nvec4 g=vec4(0.2);  //相当于vec(0.2,0.2,0.2,0.2)\nvec4 h=vec4(a,a,1.3,a);\nmat2 i=mat2(0.1,0.5,1.2,2.4);\nmat2 j=mat2(0.8);   //相当于mat2(0.8,0.8,0.8,0.8)\nmat3 k=mat3(e,e,1.2,1.6,1.8);\n```\n\n## 5.运算符\n\nGLSL中的运算符有（越靠前，运算优先级越高）：\n\n1. 索引：[]\n2. 前缀自加和自减：++，–\n3. 一元非和逻辑非：~，！\n4. 加法和减法：+，-\n5. 等于和不等于：==，！=\n6. 逻辑异或：^^\n7. 三元运算符号，选择：？:\n8. 成员选择与混合：.\n9. 后缀自加和自减：++，–\n10. 乘法和除法：*，/\n11. 关系运算符：>，<，=，>=，<=，<>\n12. 逻辑与：&&\n13. 逻辑或：||\n14. 赋值预算：=，+=，-=，*=，/=\n\n## 6.类型转换\n\nGLSL的类型转换与C不同。在GLSL中类型不可以自动提升，比如float a=1;就是一种错误的写法，必须严格的写成float a=1.0，也不可以强制转换，即float a=(float)1;也是错误的写法，但是可以用内置函数来进行转换，如float a=float(1);还有float a=float(true);（true为1.0，false为0.0）等，值得注意的是，**低精度的int不能转换为低精度的float**。\n\n## 7.限定符\n\nGLSL中的限定符号主要有：\n\n- attritude：一般用于各个顶点各不相同的量。如顶点颜色、坐标等。\n- uniform：一般用于对于3D物体中所有顶点都相同的量。比如光源位置，统一变换矩阵等。\n- varying：表示易变量，一般用于顶点着色器传递到片元着色器的量。\n- const：常量。\n\n限定符与java限定符类似，放在变量类型之前，并且只能用于全局变量。在GLSL中，没有默认限定符一说。\n\n## 8.流程控制\n\nGLSL中的流程控制与C中基本相同，主要有：\n\n```c\n    if(){}、if(){}else{}、if(){}else if(){}else{}\n    while(){}和do{}while()\n    for(;;){}\n    break和continue\n```\n\n## 9.函数\n\nGLSL中也可以定义函数，定义函数的方式也与C语言基本相同。函数的返回值可以是GLSL中的除了采样器的任意类型。对于GLSL中函数的参数，可以用参数用途修饰符来进行修饰，常用修饰符如下：\n\n- in：输入参数，无修饰符时默认为此修饰符。\n- out：输出参数。\n- inout：既可以作为输入参数，又可以作为输出参数。\n\n## 10.浮点精度\n\n与顶点着色器不同的是，在片元着色器中使用浮点型时，必须指定浮点类型的精度，否则编译会报错。精度有三种，分别为：\n\n- lowp：低精度。8位。\n- mediump：中精度。10位。\n- highp：高精度。16位。\n\n具体如下表：\n\n![](21.webp)\n\n不仅仅是float可以制定精度，其他（除了bool相关）类型也同样可以，但是int、采样器类型并不一定要求指定精度。加精度的定义如下：\n\n```c\nuniform lowp float a=1.0;\nvarying mediump vec4 c;\n```\n\n当然，也可以在片元着色器中设置默认精度，只需要在片元着色器最上面加上precision <精度> <类型>即可制定某种类型的默认精度。其他情况相同的话，精度越高，画质越好，使用的资源也越多。\n\n```c\nprecision mediump float;\n```\n\n## 11.程序结构\n\nGLSL程序的结构和C语言差不多，main()方法表示入口函数，可以在其上定义函数和变量，在main中可以引用这些变量和函数。定义在函数体以外的叫做全局变量，定义在函数体内的叫做局部变量。与高级语言不通的是，变量和函数在使用前必须声明，不能再使用的后面声明变量或者函数。\n\n## 12.内建变量\n\n在着色器中我们一般都会声明变量来在程序中使用，但是着色器中还有一些特殊的变量，不声明也可以使用。这些变量叫做内建变量。內建变量，相当于着色器硬件的输入和输出点，使用者利用这些输入点输入之后，就会看到屏幕上的输出。通过输出点可以知道输出的某些数据内容。当然，实际上肯定不会这样简单，这么说只是为了帮助理解。在顶点着色器中的内建变量和片元着色器的内建变量是不相同的。着色器中的内建变量有很多，在此，我们只列出最常用的集中内建变量。\n\n 顶点着色器的内建变量\n\n```undefined\n输入变量：\n    gl_Position：顶点坐标\n    gl_PointSize：点的大小，没有赋值则为默认值1，通常设置绘图为点绘制才有意义。\n```\n\n片元着色器的内建变量\n\n```cpp\n1. 输入变量\n    gl_FragCoord：当前片元相对窗口位置所处的坐标。\n    gl_FragFacing：bool型，表示是否为属于光栅化生成此片元的对应图元的正面。\n\n2. 输出变量\n    gl_FragColor：当前片元颜色\n    gl_FragData：vec4类型的数组。向其写入的信息，供渲染管线的后继过程使用。\n```\n\n## 13.常用内置函数\n\n### 13.1常见函数\n\n```css\n    radians(x)：角度转弧度\n    degrees(x)：弧度转角度\n    sin(x)：正弦函数，传入值为弧度。相同的还有cos余弦函数、tan正切函数、asin反正弦、acos反余弦、atan反正切\n    pow(x,y)：xy\n    exp(x)：ex\n    exp2(x)：2x\n    log(x)：logex\n    log2(x)：log2x\n    sqrt(x)：x√\n    inversesqr(x)：1x√\n    abs(x)：取x的绝对值\n    sign(x)：x>0返回1.0，x<0返回-1.0，否则返回0.0\n    ceil(x)：返回大于或者等于x的整数\n    floor(x)：返回小于或者等于x的整数\n    fract(x)：返回x-floor(x)的值\n    mod(x,y)：取模（求余）\n    min(x,y)：获取xy中小的那个\n    max(x,y)：获取xy中大的那个\n    mix(x,y,a)：返回x∗(1−a)+y∗a\n    step(x,a)：x< a返回0.0，否则返回1.0\n    smoothstep(x,y,a)：a < x返回0.0，a>y返回1.0，否则返回0.0-1.0之间平滑的Hermite插值。\n    dFdx(p)：p在x方向上的偏导数\n    dFdy(p)：p在y方向上的偏导数\n    fwidth(p)：p在x和y方向上的偏导数的绝对值之和\n```\n\n### 13.2几何函数\n\n```css\n    length(x)：计算向量x的长度\n    distance(x,y)：返回向量xy之间的距离\n    dot(x,y)：返回向量xy的点积\n    cross(x,y)：返回向量xy的差积\n    normalize(x)：返回与x向量方向相同，长度为1的向量\n```\n\n### 13.3矩阵函数\n\n```css\n    matrixCompMult(x,y)：将矩阵相乘\n    lessThan(x,y)：返回向量xy的各个分量执行x< y的结果，类似的有greaterThan,equal,notEqual\n    lessThanEqual(x,y)：返回向量xy的各个分量执行x<= y的结果，类似的有类似的有greaterThanEqual\n    any(bvec x)：x有一个元素为true，则为true\n    all(bvec x)：x所有元素为true，则返回true，否则返回false\n    not(bvec x)：x所有分量执行逻辑非运算\n```\n\n### 13.4纹理采样函数\n\n纹理采样函数有texture2D、texture2DProj、texture2DLod、texture2DProjLod、textureCube、textureCubeLod及texture3D、texture3DProj、texture3DLod、texture3DProjLod等。\n\n```css\n    texture表示纹理采样，2D表示对2D纹理采样，3D表示对3D纹理采样\n    Lod后缀，只适用于顶点着色器采样\n    Proj表示纹理坐标st会除以q\n```\n\n纹理采样函数中，3D在OpenGLES2.0并不是绝对支持。我们再次暂时不管3D纹理采样函数。重点只对texture2D函数进行说明。texture2D拥有三个参数，第一个参数表示纹理采样器。第二个参数表示纹理坐标，可以是二维、三维、或者四维。第三个参数加入后只能在片元着色器中调用，且只对采样器为mipmap类型纹理时有效。\n\n## 14.attribute、uniform、varying、in、out\n\n### 1.attribute:\n\n根据OpenGL2.0和OpenGLES2.0标准，仅用在VertexShader中，至少支持8个attribute属性。OpenGL3.0里，至少支持16个。通常用来存储位置坐标、法向量、纹理坐标和颜色等。我们在上一阶段的OpenGL学习中每个Shader都有用到。 \n\n```css\nattribute vec4 position;\nattribute vec4 color;\nattribute vec4 texcoord;\nattribute vec4 normal;\n```\n\n####  方法一：\n\n在C++中先获取在哪个属性组： \n\n```css\nmPositionLocation = glGetAttribLocation(mProgram, \"position\");\nmColorLocation = glGetAttribLocation(mProgram, \"color\");\nmTexcoordLocation = glGetAttribLocation(mProgram, \"texcoord\");\nmNormalLocation = glGetAttribLocation(mProgram, \"normal\");\n```\n\n设置VBO与通用属性组关系：\n\n```cpp\nglEnableVertexAttribArray(mPositionLocation);\nglVertexAttribPointer(mPositionLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0);\nglEnableVertexAttribArray(mColorLocation);\nglVertexAttribPointer(mColorLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(sizeof(float) * 4));\nglEnableVertexAttribArray(mTexcoordLocation);\nglVertexAttribPointer(mTexcoordLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(sizeof(float) * 8));\nglEnableVertexAttribArray(mNormalLocation);\nglVertexAttribPointer(mNormalLocation, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(sizeof(float) * 12));\n```\n\n#### 方法二：\n\n```cpp\nGLbyte vertexShaderSrc[] =\n\"attribute vec4 a_position; \\n\"\n\"attribute vec4 a_color; \\n\"\n\"varying vec4 v_color; \\n\"\n\"void main() \\n\"\n\"{ \\n\"\n\" v_color = a_color; \\n\"\n\" gl_Position = a_position; \\n\"\n\"}\";\nGLbyte fragmentShaderSrc[] =\n\"varying vec4 v_color; \\n\"\n\"void main() \\n\"\n\"{ \\n\"\n\" gl_FragColor = v_color; \\n\"\n\"}\";\nGLfloat color[4] = { 1.0f, 0.0f, 0.0f, 1.0f };\nGLfloat vertexPos[3 * 3]; // 3 vertices, with (x,y,z) per-vertex\nGLuint shaderObject[2];\nGLuint programObject;\nshaderObject[0] = LoadShader(vertexShaderSrc, GL_VERTEX_SHADER);\nshaderObject[1] = LoadShader(fragmentShaderSrc, GL_FRAGMENT_SHADER);\nprogramObject = glCreateProgram();\nglAttachShader(programObject, shaderObject[0]);\nglAttachShader(programObject, shaderObject[1]);\n\nglVertexAttrib4fv(0, color);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, vertexPos);\nglEnableVertexAttribArray(1);\nglBindAttribLocation(programObject, 0, \"a_color\");\nglBindAttribLocation(programObject, 1, \"a_position\");\nglLinkProgram(programObject);\nglUseProgram(programObject);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n\n\n### 2.unifrom:\n\n可存在所有shader中，OpenGL2.0中，数量至少有128个。可存放矩阵、材质等任何attribute放不下的属性。\n\n```css\nuniform mat4 ModelMatrix;\nuniform mat4 ViewMatrix;\nuniform mat4 ProjectionMatrix;\n```\n\n在C++中，先获取位置：c\n\n```css\nmModelMatrixLocation = glGetUniformLocation(mProgram, \"ModelMatrix\");\nmViewMatrixLocation = glGetUniformLocation(mProgram, \"ViewMatrix\");\nmProjectionMatrixLocation = glGetUniformLocation(mProgram, \"ProjectionMatrix\");\n```\n\n\n设置参数：\n\n```css\nglUniformMatrix4fv(mModelMatrixLocation, 1, GL_FALSE, M);\nglUniformMatrix4fv(mViewMatrixLocation, 1, GL_FALSE, V);\nglUniformMatrix4fv(mProjectionMatrixLocation, 1, GL_FALSE, P);\n```\n\n### 3.varying:\n\n用于shader之间的数据传递，在OpenGL2.0。最多传递8个Vec4大小的数据，即2个mat4矩阵。\n\n```css\nvarying vec4 V_Texcoord;\n```\n\n### 4.in:\n\n表示某个Shader阶段的输入。varying可以改为in。即fs中的输入为vs中的输出。\n\n### 5.out:\n\n代表每个shader的输出。也可以代替varying。in和out在3.0之后的版本使用。","slug":"4-7-GLSL着色器语言","published":1,"updated":"2023-04-14T13:53:39.662Z","_id":"clggljw630007hoobbo9uenee","layout":"post","photos":[],"link":"","content":"<h1 id=\"GLSL着色器语言\"><a href=\"#GLSL着色器语言\" class=\"headerlink\" title=\"GLSL着色器语言\"></a>GLSL着色器语言</h1><span id=\"more\"></span>\n\n<h2 id=\"1-OpenGL-ES-2-0\"><a href=\"#1-OpenGL-ES-2-0\" class=\"headerlink\" title=\"1.OpenGL ES 2.0\"></a>1.OpenGL ES 2.0</h2><p>（ES2.0也支持OES外部纹理）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***********************GLRender Normal texture***********************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> CommonVertshader_Normal[] =</span><br><span class=\"line\"><span class=\"comment\">//&quot; #version 300 es \\n &quot;//着色器版本声明OpenGL ES 3.0</span></span><br><span class=\"line\"><span class=\"string\">&quot; #version 100 es \\n &quot;</span><span class=\"comment\">//不添加版本声明或者使用 #version 100 es 声明版本则指定使用 OpenGL ES 2.0</span></span><br><span class=\"line\"><span class=\"string\">&quot; precision mediump float;\\n &quot;</span><span class=\"comment\">//指定float类型默认的mediump中精度（-2^14 ~ 2^14）</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//&quot; layout(location = 0) in vec4 vPosition; \\n &quot;//输入vPosition顶点坐标</span></span><br><span class=\"line\"><span class=\"comment\">//&quot; layout(location = 1) in vec2 vTexCoord; \\n &quot;//输入vTexCoord纹理坐标vec2</span></span><br><span class=\"line\"><span class=\"comment\">//&quot; out vec3 TexCoord; \\n &quot;//输出纹理坐标vec3</span></span><br><span class=\"line\"><span class=\"string\">&quot; attribute vec4 vPosition; \\n &quot;</span><span class=\"comment\">//ES2.0中attribute，ES3.0中in</span></span><br><span class=\"line\"><span class=\"string\">&quot; attribute vec2 vTexCoord; \\n &quot;</span><span class=\"comment\">//ES2.0中attribute，ES3.0中in</span></span><br><span class=\"line\"><span class=\"string\">&quot; varying vec3 TexCoord; \\n &quot;</span><span class=\"comment\">//ES2.0中varying，ES3.0中out</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"string\">&quot; uniform mat4 mvp; \\n&quot;</span><span class=\"comment\">//uniform用于ES传入数据mvp</span></span><br><span class=\"line\"><span class=\"string\">&quot; void main() \\n &quot;</span><span class=\"comment\">//主函数</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#123; \\n &quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;vec4 temPosition = mvp * vec4(vPosition.x, vPosition.y, vPosition.z, 1); \\n&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot; gl_Position = vec4(temPosition.x, -temPosition.y, temPosition.z, temPosition.a); \\n &quot;</span><span class=\"comment\">//内建变量gl_Position顶点坐标</span></span><br><span class=\"line\">    <span class=\"string\">&quot; TexCoord = vec3(vTexCoord, vPosition.w); \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#125; \\n &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> CommonFragshader_Normal[] =</span><br><span class=\"line\"><span class=\"comment\">//&quot;#version 300 es \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;#extension GL_OES_EGL_image_external : require \\n&quot;</span><span class=\"comment\">//启用扩展（ES2.0也支持OES外部纹理）</span></span><br><span class=\"line\"><span class=\"string\">&quot; precision mediump float;\\n &quot;</span><span class=\"comment\">//Fragshader使用浮点型时必须指定精度，指定float类型默认的mediump中精度（-2^14 ~ 2^14）</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//&quot; in vec3 TexCoord; \\n &quot;//输入vTexCoord纹理坐标vec3,从Vertshader中传入的</span></span><br><span class=\"line\"><span class=\"comment\">//&quot; out vec4 fragColor; \\n &quot;//输出片元颜色</span></span><br><span class=\"line\"><span class=\"string\">&quot; attribute vec3 TexCoord; \\n &quot;</span><span class=\"comment\">//ES2.0中attribute，ES3.0中in</span></span><br><span class=\"line\"><span class=\"string\">&quot; varying vec4 fragColor; \\n &quot;</span><span class=\"comment\">//ES2.0中varying，ES3.0中out</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"string\">&quot;uniform sampler2D myTexture;\\n&quot;</span><span class=\"comment\">//ES 2.0支持sample2D纹理和sampleCube纹理</span></span><br><span class=\"line\"><span class=\"string\">&quot; uniform vec4 myGain; \\n &quot;</span><span class=\"comment\">//uniform用于ES传入数据myGain</span></span><br><span class=\"line\"><span class=\"string\">&quot; void main() \\n &quot;</span><span class=\"comment\">//主函数</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#123;\\n &quot;</span></span><br><span class=\"line\"><span class=\"comment\">//&quot;  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, TexCoord.z)+vec4(myGain.xyz,0.0); \\n &quot;//2.25</span></span><br><span class=\"line\"><span class=\"string\">&quot;  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, 1.0); \\n &quot;</span><span class=\"comment\">//2.25</span></span><br><span class=\"line\"><span class=\"comment\">//&quot;\t fragColor = vec4(0.3, 0.4, 0.5, TexCoord.z)+vec4(myGain.xyz,0.0); \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#125;\\n &quot;</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-OpenGL-ES-3-0\"><a href=\"#2-OpenGL-ES-3-0\" class=\"headerlink\" title=\"2.OpenGL ES 3.0\"></a>2.OpenGL ES 3.0</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***********************GLRender Normal texture***********************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> CommonVertshader_Normal[] =</span><br><span class=\"line\"><span class=\"string\">&quot; #version 300 es \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; precision mediump float;\\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; layout(location = 0) in vec4 vPosition; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; layout(location = 1) in vec2 vTexCoord; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; out vec3 TexCoord; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; uniform mat4 mvp; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; void main() \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#123; \\n &quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;vec4 temPosition = mvp * vec4(vPosition.x, vPosition.y, vPosition.z, 1); \\n&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot; gl_Position = vec4(temPosition.x, -temPosition.y, temPosition.z, temPosition.a); \\n &quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot; TexCoord = vec3(vTexCoord, vPosition.w); \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#125; \\n &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> CommonFragshader_Normal[] =</span><br><span class=\"line\"><span class=\"string\">&quot;#version 300 es \\n&quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> (!VT_SAMPLE2D_SELECTED &amp;&amp; !FIX_CAMERA_IMAGE)</span></span><br><span class=\"line\"><span class=\"string\">&quot;#extension GL_OES_EGL_image_external : require \\n&quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"string\">&quot; precision mediump float;\\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; in vec3 TexCoord; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; out vec4 fragColor; \\n &quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> (VT_SAMPLE2D_SELECTED || FIX_CAMERA_IMAGE)</span></span><br><span class=\"line\"><span class=\"string\">&quot;uniform sampler2D myTexture;\\n&quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"string\">&quot; uniform samplerExternalOES myTexture; \\n &quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"string\">&quot; uniform vec4 myGain; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; void main() \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#123;\\n &quot;</span></span><br><span class=\"line\"><span class=\"comment\">//&quot;  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, TexCoord.z)+vec4(myGain.xyz,0.0); \\n &quot;//2.25</span></span><br><span class=\"line\"><span class=\"string\">&quot;  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, 1.0); \\n &quot;</span><span class=\"comment\">//2.25</span></span><br><span class=\"line\"><span class=\"comment\">//&quot;\t fragColor = vec4(0.3, 0.4, 0.5, TexCoord.z)+vec4(myGain.xyz,0.0); \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#125;\\n &quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-着色器语言简介\"><a href=\"#3-着色器语言简介\" class=\"headerlink\" title=\"3.着色器语言简介\"></a>3.着色器语言简介</h2><p>OpenGLES的着色器语言GLSL是一种高级的图形化编程语言，其源自应用广泛的C语言。与传统的C语言不同的是，它提供了更加丰富的针对于图像处理的原生类型，诸如向量、矩阵之类。OpenGLES 主要包含以下特性：</p>\n<ul>\n<li>GLSL是一种面向过程的语言，和Java的面向对象是不同的。</li>\n<li>GLSL的基本语法与C&#x2F;C++基本相同。</li>\n<li>它完美的支持向量和矩阵操作。</li>\n<li>它是通过限定符操作来管理输入输出类型的。</li>\n<li>GLSL提供了大量的内置函数来提供丰富的扩展功能。</li>\n</ul>\n<h2 id=\"4-数据类型\"><a href=\"#4-数据类型\" class=\"headerlink\" title=\"4.数据类型\"></a>4.数据类型</h2><p>GLSL中的数据类型主要分为标量、向量、矩阵、采样器、结构体、数组、空类型七种类型：</p>\n<ul>\n<li>标量：标量表示的是只有大小没有方向的量，在GLSL中标量只有bool、int和float三种。对于int，和C一样，可以写为十进制（16）、八进制（020）或者十六进制（0x10）。关于进制不了解的，得自己补补，这是编程基础。<strong>对于标量的运算，我们最需要注意的是精度，防止溢出问题</strong>。</li>\n<li>向量：向量我们可以看做是数组，在GLSL通常用于储存颜色、坐标等数据，针对维数，可分为二维、三维和四位向量。针对存储的标量类型，可以分为bool、int和float。共有vec2、vec3、vec4，ivec2、ivec3、ivec4、bvec2、bvec3和bvec4九种类型，数组代表维数、i表示int类型、b表示bool类型。<strong>需要注意的是，GLSL中的向量表示竖向量，所以与矩阵相乘进行变换时，矩阵在前，向量在后（与DirectX正好相反）</strong>。向量在GPU中由硬件支持运算，比CPU快的多。</li>\n</ul>\n<blockquote>\n<ol>\n<li>作为颜色向量时，用rgba表示分量，就如同取数组的中具体数据的索引值。三维颜色向量就用rgb表示分量。比如对于颜色向量vec4 color，color[0]和color.r都表示color向量的第一个值，也就是红色的分量。其他相同。</li>\n<li>作为位置向量时，用xyzw表示分量，xyz分别表示xyz坐标，w表示向量的模。三维坐标向量为xyz表示分量，二维向量为xy表示分量。</li>\n<li>作为纹理向量时，用stpq表示分量，三维用stp表示分量，二维用st表示分量。</li>\n</ol>\n</blockquote>\n<ul>\n<li>矩阵：在GLSL中矩阵拥有2<em>2、3</em>3、4*4三种类型的矩阵，分别用mat2、mat3、mat4表示。我们可以把矩阵看做是一个二维数组，也可以用二维数组下表的方式取里面具体位置的值。</li>\n<li>采样器：采样器是专门用来对纹理进行采样工作的，在GLSL中一般来说，一个采样器变量表示一副或者一套纹理贴图。所谓的纹理贴图可以理解为我们看到的物体上的皮肤。</li>\n<li>结构体：和C语言中的结构体相同，用struct来定义结构体，关于结构体参考C语言中的结构体。</li>\n<li>数组：数组知识也和C中相同，不同的是数组声明时可以不指定大小，但是建议在不必要的情况下，还是指定大小的好。</li>\n<li>空类型：空类型用void表示，仅用来声明不返回任何值得函数。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> a=<span class=\"number\">1.0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> b=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">bool</span> c=<span class=\"literal\">true</span>;</span><br><span class=\"line\">vec2 d=vec2(<span class=\"number\">1.0</span>,<span class=\"number\">2.0</span>);</span><br><span class=\"line\">vec3 e=vec3(<span class=\"number\">1.0</span>,<span class=\"number\">2.0</span>,<span class=\"number\">3.0</span>)</span><br><span class=\"line\">vec4 f=vec4(vec3,<span class=\"number\">1.2</span>);</span><br><span class=\"line\">vec4 g=vec4(<span class=\"number\">0.2</span>);  <span class=\"comment\">//相当于vec(0.2,0.2,0.2,0.2)</span></span><br><span class=\"line\">vec4 h=vec4(a,a,<span class=\"number\">1.3</span>,a);</span><br><span class=\"line\">mat2 i=mat2(<span class=\"number\">0.1</span>,<span class=\"number\">0.5</span>,<span class=\"number\">1.2</span>,<span class=\"number\">2.4</span>);</span><br><span class=\"line\">mat2 j=mat2(<span class=\"number\">0.8</span>);   <span class=\"comment\">//相当于mat2(0.8,0.8,0.8,0.8)</span></span><br><span class=\"line\">mat3 k=mat3(e,e,<span class=\"number\">1.2</span>,<span class=\"number\">1.6</span>,<span class=\"number\">1.8</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-运算符\"><a href=\"#5-运算符\" class=\"headerlink\" title=\"5.运算符\"></a>5.运算符</h2><p>GLSL中的运算符有（越靠前，运算优先级越高）：</p>\n<ol>\n<li>索引：[]</li>\n<li>前缀自加和自减：++，–</li>\n<li>一元非和逻辑非：~，！</li>\n<li>加法和减法：+，-</li>\n<li>等于和不等于：&#x3D;&#x3D;，！&#x3D;</li>\n<li>逻辑异或：^^</li>\n<li>三元运算符号，选择：？:</li>\n<li>成员选择与混合：.</li>\n<li>后缀自加和自减：++，–</li>\n<li>乘法和除法：*，&#x2F;</li>\n<li>关系运算符：&gt;，&lt;，&#x3D;，&gt;&#x3D;，&lt;&#x3D;，&lt;&gt;</li>\n<li>逻辑与：&amp;&amp;</li>\n<li>逻辑或：||</li>\n<li>赋值预算：&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</li>\n</ol>\n<h2 id=\"6-类型转换\"><a href=\"#6-类型转换\" class=\"headerlink\" title=\"6.类型转换\"></a>6.类型转换</h2><p>GLSL的类型转换与C不同。在GLSL中类型不可以自动提升，比如float a&#x3D;1;就是一种错误的写法，必须严格的写成float a&#x3D;1.0，也不可以强制转换，即float a&#x3D;(float)1;也是错误的写法，但是可以用内置函数来进行转换，如float a&#x3D;float(1);还有float a&#x3D;float(true);（true为1.0，false为0.0）等，值得注意的是，<strong>低精度的int不能转换为低精度的float</strong>。</p>\n<h2 id=\"7-限定符\"><a href=\"#7-限定符\" class=\"headerlink\" title=\"7.限定符\"></a>7.限定符</h2><p>GLSL中的限定符号主要有：</p>\n<ul>\n<li>attritude：一般用于各个顶点各不相同的量。如顶点颜色、坐标等。</li>\n<li>uniform：一般用于对于3D物体中所有顶点都相同的量。比如光源位置，统一变换矩阵等。</li>\n<li>varying：表示易变量，一般用于顶点着色器传递到片元着色器的量。</li>\n<li>const：常量。</li>\n</ul>\n<p>限定符与java限定符类似，放在变量类型之前，并且只能用于全局变量。在GLSL中，没有默认限定符一说。</p>\n<h2 id=\"8-流程控制\"><a href=\"#8-流程控制\" class=\"headerlink\" title=\"8.流程控制\"></a>8.流程控制</h2><p>GLSL中的流程控制与C中基本相同，主要有：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>()&#123;&#125;、<span class=\"keyword\">if</span>()&#123;&#125;<span class=\"keyword\">else</span>&#123;&#125;、<span class=\"keyword\">if</span>()&#123;&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>()&#123;&#125;<span class=\"keyword\">else</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span>()&#123;&#125;和<span class=\"keyword\">do</span>&#123;&#125;<span class=\"keyword\">while</span>()</span><br><span class=\"line\"><span class=\"keyword\">for</span>(;;)&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">break</span>和<span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-函数\"><a href=\"#9-函数\" class=\"headerlink\" title=\"9.函数\"></a>9.函数</h2><p>GLSL中也可以定义函数，定义函数的方式也与C语言基本相同。函数的返回值可以是GLSL中的除了采样器的任意类型。对于GLSL中函数的参数，可以用参数用途修饰符来进行修饰，常用修饰符如下：</p>\n<ul>\n<li>in：输入参数，无修饰符时默认为此修饰符。</li>\n<li>out：输出参数。</li>\n<li>inout：既可以作为输入参数，又可以作为输出参数。</li>\n</ul>\n<h2 id=\"10-浮点精度\"><a href=\"#10-浮点精度\" class=\"headerlink\" title=\"10.浮点精度\"></a>10.浮点精度</h2><p>与顶点着色器不同的是，在片元着色器中使用浮点型时，必须指定浮点类型的精度，否则编译会报错。精度有三种，分别为：</p>\n<ul>\n<li>lowp：低精度。8位。</li>\n<li>mediump：中精度。10位。</li>\n<li>highp：高精度。16位。</li>\n</ul>\n<p>具体如下表：</p>\n<p><img src=\"/2023/04/14/4-7-GLSL%E7%9D%80%E8%89%B2%E5%99%A8%E8%AF%AD%E8%A8%80/21.webp\"></p>\n<p>不仅仅是float可以制定精度，其他（除了bool相关）类型也同样可以，但是int、采样器类型并不一定要求指定精度。加精度的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform lowp <span class=\"type\">float</span> a=<span class=\"number\">1.0</span>;</span><br><span class=\"line\">varying mediump vec4 c;</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以在片元着色器中设置默认精度，只需要在片元着色器最上面加上precision &lt;精度&gt; &lt;类型&gt;即可制定某种类型的默认精度。其他情况相同的话，精度越高，画质越好，使用的资源也越多。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precision mediump <span class=\"type\">float</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-程序结构\"><a href=\"#11-程序结构\" class=\"headerlink\" title=\"11.程序结构\"></a>11.程序结构</h2><p>GLSL程序的结构和C语言差不多，main()方法表示入口函数，可以在其上定义函数和变量，在main中可以引用这些变量和函数。定义在函数体以外的叫做全局变量，定义在函数体内的叫做局部变量。与高级语言不通的是，变量和函数在使用前必须声明，不能再使用的后面声明变量或者函数。</p>\n<h2 id=\"12-内建变量\"><a href=\"#12-内建变量\" class=\"headerlink\" title=\"12.内建变量\"></a>12.内建变量</h2><p>在着色器中我们一般都会声明变量来在程序中使用，但是着色器中还有一些特殊的变量，不声明也可以使用。这些变量叫做内建变量。內建变量，相当于着色器硬件的输入和输出点，使用者利用这些输入点输入之后，就会看到屏幕上的输出。通过输出点可以知道输出的某些数据内容。当然，实际上肯定不会这样简单，这么说只是为了帮助理解。在顶点着色器中的内建变量和片元着色器的内建变量是不相同的。着色器中的内建变量有很多，在此，我们只列出最常用的集中内建变量。</p>\n<p> 顶点着色器的内建变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入变量：</span><br><span class=\"line\">    gl_Position：顶点坐标</span><br><span class=\"line\">    gl_PointSize：点的大小，没有赋值则为默认值1，通常设置绘图为点绘制才有意义。</span><br></pre></td></tr></table></figure>\n\n<p>片元着色器的内建变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 输入变量</span><br><span class=\"line\">    gl_FragCoord：当前片元相对窗口位置所处的坐标。</span><br><span class=\"line\">    gl_FragFacing：<span class=\"type\">bool</span>型，表示是否为属于光栅化生成此片元的对应图元的正面。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 输出变量</span><br><span class=\"line\">    gl_FragColor：当前片元颜色</span><br><span class=\"line\">    gl_FragData：vec4类型的数组。向其写入的信息，供渲染管线的后继过程使用。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-常用内置函数\"><a href=\"#13-常用内置函数\" class=\"headerlink\" title=\"13.常用内置函数\"></a>13.常用内置函数</h2><h3 id=\"13-1常见函数\"><a href=\"#13-1常见函数\" class=\"headerlink\" title=\"13.1常见函数\"></a>13.1常见函数</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">radians(x)：角度转弧度</span><br><span class=\"line\">degrees(x)：弧度转角度</span><br><span class=\"line\">sin(x)：正弦函数，传入值为弧度。相同的还有cos余弦函数、tan正切函数、asin反正弦、acos反余弦、atan反正切</span><br><span class=\"line\">pow(x,y)：xy</span><br><span class=\"line\">exp(x)：ex</span><br><span class=\"line\">exp2(x)：<span class=\"number\">2</span>x</span><br><span class=\"line\">log(x)：logex</span><br><span class=\"line\">log2(x)：log2x</span><br><span class=\"line\">sqrt(x)：x√</span><br><span class=\"line\">inversesqr(x)：<span class=\"number\">1</span>x√</span><br><span class=\"line\">abs(x)：取x的绝对值</span><br><span class=\"line\">sign(x)：x&gt;<span class=\"number\">0</span>返回<span class=\"number\">1.0</span>，x&lt;<span class=\"number\">0</span>返回-<span class=\"number\">1.0</span>，否则返回<span class=\"number\">0.0</span></span><br><span class=\"line\">ceil(x)：返回大于或者等于x的整数</span><br><span class=\"line\">floor(x)：返回小于或者等于x的整数</span><br><span class=\"line\">fract(x)：返回x-floor(x)的值</span><br><span class=\"line\">mod(x,y)：取模（求余）</span><br><span class=\"line\">min(x,y)：获取xy中小的那个</span><br><span class=\"line\">max(x,y)：获取xy中大的那个</span><br><span class=\"line\">mix(x,y,<span class=\"selector-tag\">a</span>)：返回x∗(<span class=\"number\">1</span>−<span class=\"selector-tag\">a</span>)+y∗<span class=\"selector-tag\">a</span></span><br><span class=\"line\">step(x,<span class=\"selector-tag\">a</span>)：x&lt; <span class=\"selector-tag\">a</span>返回<span class=\"number\">0.0</span>，否则返回<span class=\"number\">1.0</span></span><br><span class=\"line\">smoothstep(x,y,<span class=\"selector-tag\">a</span>)：<span class=\"selector-tag\">a</span> &lt; x返回<span class=\"number\">0.0</span>，<span class=\"selector-tag\">a</span>&gt;y返回<span class=\"number\">1.0</span>，否则返回<span class=\"number\">0.0</span>-<span class=\"number\">1.0</span>之间平滑的Hermite插值。</span><br><span class=\"line\">dFdx(<span class=\"selector-tag\">p</span>)：<span class=\"selector-tag\">p</span>在x方向上的偏导数</span><br><span class=\"line\">dFdy(<span class=\"selector-tag\">p</span>)：<span class=\"selector-tag\">p</span>在y方向上的偏导数</span><br><span class=\"line\">fwidth(<span class=\"selector-tag\">p</span>)：<span class=\"selector-tag\">p</span>在x和y方向上的偏导数的绝对值之和</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2几何函数\"><a href=\"#13-2几何函数\" class=\"headerlink\" title=\"13.2几何函数\"></a>13.2几何函数</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">length(x)：计算向量x的长度</span><br><span class=\"line\">distance(x,y)：返回向量xy之间的距离</span><br><span class=\"line\">dot(x,y)：返回向量xy的点积</span><br><span class=\"line\">cross(x,y)：返回向量xy的差积</span><br><span class=\"line\">normalize(x)：返回与x向量方向相同，长度为<span class=\"number\">1</span>的向量</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-3矩阵函数\"><a href=\"#13-3矩阵函数\" class=\"headerlink\" title=\"13.3矩阵函数\"></a>13.3矩阵函数</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrixCompMult(x,y)：将矩阵相乘</span><br><span class=\"line\">lessThan(x,y)：返回向量xy的各个分量执行x&lt; y的结果，类似的有greaterThan,equal,notEqual</span><br><span class=\"line\">lessThanEqual(x,y)：返回向量xy的各个分量执行x&lt;= y的结果，类似的有类似的有greaterThanEqual</span><br><span class=\"line\">any(bvec x)：x有一个元素为true，则为true</span><br><span class=\"line\"><span class=\"attribute\">all</span>(bvec x)：x所有元素为true，则返回true，否则返回false</span><br><span class=\"line\">not(bvec x)：x所有分量执行逻辑非运算</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-4纹理采样函数\"><a href=\"#13-4纹理采样函数\" class=\"headerlink\" title=\"13.4纹理采样函数\"></a>13.4纹理采样函数</h3><p>纹理采样函数有texture2D、texture2DProj、texture2DLod、texture2DProjLod、textureCube、textureCubeLod及texture3D、texture3DProj、texture3DLod、texture3DProjLod等。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">texture表示纹理采样，<span class=\"number\">2</span>D表示对<span class=\"number\">2</span>D纹理采样，<span class=\"number\">3</span>D表示对<span class=\"number\">3</span>D纹理采样</span><br><span class=\"line\">Lod后缀，只适用于顶点着色器采样</span><br><span class=\"line\">Proj表示纹理坐标st会除以<span class=\"selector-tag\">q</span></span><br></pre></td></tr></table></figure>\n\n<p>纹理采样函数中，3D在OpenGLES2.0并不是绝对支持。我们再次暂时不管3D纹理采样函数。重点只对texture2D函数进行说明。texture2D拥有三个参数，第一个参数表示纹理采样器。第二个参数表示纹理坐标，可以是二维、三维、或者四维。第三个参数加入后只能在片元着色器中调用，且只对采样器为mipmap类型纹理时有效。</p>\n<h2 id=\"14-attribute、uniform、varying、in、out\"><a href=\"#14-attribute、uniform、varying、in、out\" class=\"headerlink\" title=\"14.attribute、uniform、varying、in、out\"></a>14.attribute、uniform、varying、in、out</h2><h3 id=\"1-attribute\"><a href=\"#1-attribute\" class=\"headerlink\" title=\"1.attribute:\"></a>1.attribute:</h3><p>根据OpenGL2.0和OpenGLES2.0标准，仅用在VertexShader中，至少支持8个attribute属性。OpenGL3.0里，至少支持16个。通常用来存储位置坐标、法向量、纹理坐标和颜色等。我们在上一阶段的OpenGL学习中每个Shader都有用到。 </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec4 <span class=\"attribute\">position</span>;</span><br><span class=\"line\">attribute vec4 <span class=\"attribute\">color</span>;</span><br><span class=\"line\">attribute vec4 texcoord;</span><br><span class=\"line\">attribute vec4 <span class=\"attribute\">normal</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h4><p>在C++中先获取在哪个属性组： </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mPositionLocation = glGetAttribLocation(mProgram, &quot;<span class=\"attribute\">position</span>&quot;);</span><br><span class=\"line\">mColorLocation = glGetAttribLocation(mProgram, &quot;<span class=\"attribute\">color</span>&quot;);</span><br><span class=\"line\">mTexcoordLocation = glGetAttribLocation(mProgram, &quot;texcoord&quot;);</span><br><span class=\"line\">mNormalLocation = glGetAttribLocation(mProgram, &quot;<span class=\"attribute\">normal</span>&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>设置VBO与通用属性组关系：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(mPositionLocation);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(mPositionLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"built_in\">sizeof</span>(Vertex), <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(mColorLocation);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(mColorLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"built_in\">sizeof</span>(Vertex), (<span class=\"type\">void</span>*)(<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>) * <span class=\"number\">4</span>));</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(mTexcoordLocation);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(mTexcoordLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"built_in\">sizeof</span>(Vertex), (<span class=\"type\">void</span>*)(<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>) * <span class=\"number\">8</span>));</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(mNormalLocation);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(mNormalLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"built_in\">sizeof</span>(Vertex), (<span class=\"type\">void</span>*)(<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>) * <span class=\"number\">12</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLbyte vertexShaderSrc[] =</span><br><span class=\"line\"><span class=\"string\">&quot;attribute vec4 a_position; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;attribute vec4 a_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;varying vec4 v_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;void main() \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#123; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; v_color = a_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; gl_Position = a_position; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\">GLbyte fragmentShaderSrc[] =</span><br><span class=\"line\"><span class=\"string\">&quot;varying vec4 v_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;void main() \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#123; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; gl_FragColor = v_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\">GLfloat color[<span class=\"number\">4</span>] = &#123; <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span> &#125;;</span><br><span class=\"line\">GLfloat vertexPos[<span class=\"number\">3</span> * <span class=\"number\">3</span>]; <span class=\"comment\">// 3 vertices, with (x,y,z) per-vertex</span></span><br><span class=\"line\">GLuint shaderObject[<span class=\"number\">2</span>];</span><br><span class=\"line\">GLuint programObject;</span><br><span class=\"line\">shaderObject[<span class=\"number\">0</span>] = <span class=\"built_in\">LoadShader</span>(vertexShaderSrc, GL_VERTEX_SHADER);</span><br><span class=\"line\">shaderObject[<span class=\"number\">1</span>] = <span class=\"built_in\">LoadShader</span>(fragmentShaderSrc, GL_FRAGMENT_SHADER);</span><br><span class=\"line\">programObject = <span class=\"built_in\">glCreateProgram</span>();</span><br><span class=\"line\"><span class=\"built_in\">glAttachShader</span>(programObject, shaderObject[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">glAttachShader</span>(programObject, shaderObject[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glVertexAttrib4fv</span>(<span class=\"number\">0</span>, color);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vertexPos);</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">glBindAttribLocation</span>(programObject, <span class=\"number\">0</span>, <span class=\"string\">&quot;a_color&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">glBindAttribLocation</span>(programObject, <span class=\"number\">1</span>, <span class=\"string\">&quot;a_position&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">glLinkProgram</span>(programObject);</span><br><span class=\"line\"><span class=\"built_in\">glUseProgram</span>(programObject);</span><br><span class=\"line\"><span class=\"built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-unifrom\"><a href=\"#2-unifrom\" class=\"headerlink\" title=\"2.unifrom:\"></a>2.unifrom:</h3><p>可存在所有shader中，OpenGL2.0中，数量至少有128个。可存放矩阵、材质等任何attribute放不下的属性。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 ModelMatrix;</span><br><span class=\"line\">uniform mat4 ViewMatrix;</span><br><span class=\"line\">uniform mat4 ProjectionMatrix;</span><br></pre></td></tr></table></figure>\n\n<p>在C++中，先获取位置：c</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mModelMatrixLocation = glGetUniformLocation(mProgram, &quot;ModelMatrix&quot;);</span><br><span class=\"line\">mViewMatrixLocation = glGetUniformLocation(mProgram, &quot;ViewMatrix&quot;);</span><br><span class=\"line\">mProjectionMatrixLocation = glGetUniformLocation(mProgram, &quot;ProjectionMatrix&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<p>设置参数：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glUniformMatrix4fv(mModelMatrixLocation, <span class=\"number\">1</span>, GL_FALSE, M);</span><br><span class=\"line\">glUniformMatrix4fv(mViewMatrixLocation, <span class=\"number\">1</span>, GL_FALSE, V);</span><br><span class=\"line\">glUniformMatrix4fv(mProjectionMatrixLocation, <span class=\"number\">1</span>, GL_FALSE, <span class=\"selector-tag\">P</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-varying\"><a href=\"#3-varying\" class=\"headerlink\" title=\"3.varying:\"></a>3.varying:</h3><p>用于shader之间的数据传递，在OpenGL2.0。最多传递8个Vec4大小的数据，即2个mat4矩阵。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying vec4 V_Texcoord;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-in\"><a href=\"#4-in\" class=\"headerlink\" title=\"4.in:\"></a>4.in:</h3><p>表示某个Shader阶段的输入。varying可以改为in。即fs中的输入为vs中的输出。</p>\n<h3 id=\"5-out\"><a href=\"#5-out\" class=\"headerlink\" title=\"5.out:\"></a>5.out:</h3><p>代表每个shader的输出。也可以代替varying。in和out在3.0之后的版本使用。</p>\n","site":{"data":{"style":""}},"length":11462,"excerpt":"<h1 id=\"GLSL着色器语言\"><a href=\"#GLSL着色器语言\" class=\"headerlink\" title=\"GLSL着色器语言\"></a>GLSL着色器语言</h1>","more":"<h2 id=\"1-OpenGL-ES-2-0\"><a href=\"#1-OpenGL-ES-2-0\" class=\"headerlink\" title=\"1.OpenGL ES 2.0\"></a>1.OpenGL ES 2.0</h2><p>（ES2.0也支持OES外部纹理）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***********************GLRender Normal texture***********************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> CommonVertshader_Normal[] =</span><br><span class=\"line\"><span class=\"comment\">//&quot; #version 300 es \\n &quot;//着色器版本声明OpenGL ES 3.0</span></span><br><span class=\"line\"><span class=\"string\">&quot; #version 100 es \\n &quot;</span><span class=\"comment\">//不添加版本声明或者使用 #version 100 es 声明版本则指定使用 OpenGL ES 2.0</span></span><br><span class=\"line\"><span class=\"string\">&quot; precision mediump float;\\n &quot;</span><span class=\"comment\">//指定float类型默认的mediump中精度（-2^14 ~ 2^14）</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//&quot; layout(location = 0) in vec4 vPosition; \\n &quot;//输入vPosition顶点坐标</span></span><br><span class=\"line\"><span class=\"comment\">//&quot; layout(location = 1) in vec2 vTexCoord; \\n &quot;//输入vTexCoord纹理坐标vec2</span></span><br><span class=\"line\"><span class=\"comment\">//&quot; out vec3 TexCoord; \\n &quot;//输出纹理坐标vec3</span></span><br><span class=\"line\"><span class=\"string\">&quot; attribute vec4 vPosition; \\n &quot;</span><span class=\"comment\">//ES2.0中attribute，ES3.0中in</span></span><br><span class=\"line\"><span class=\"string\">&quot; attribute vec2 vTexCoord; \\n &quot;</span><span class=\"comment\">//ES2.0中attribute，ES3.0中in</span></span><br><span class=\"line\"><span class=\"string\">&quot; varying vec3 TexCoord; \\n &quot;</span><span class=\"comment\">//ES2.0中varying，ES3.0中out</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"string\">&quot; uniform mat4 mvp; \\n&quot;</span><span class=\"comment\">//uniform用于ES传入数据mvp</span></span><br><span class=\"line\"><span class=\"string\">&quot; void main() \\n &quot;</span><span class=\"comment\">//主函数</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#123; \\n &quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;vec4 temPosition = mvp * vec4(vPosition.x, vPosition.y, vPosition.z, 1); \\n&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot; gl_Position = vec4(temPosition.x, -temPosition.y, temPosition.z, temPosition.a); \\n &quot;</span><span class=\"comment\">//内建变量gl_Position顶点坐标</span></span><br><span class=\"line\">    <span class=\"string\">&quot; TexCoord = vec3(vTexCoord, vPosition.w); \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#125; \\n &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> CommonFragshader_Normal[] =</span><br><span class=\"line\"><span class=\"comment\">//&quot;#version 300 es \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;#extension GL_OES_EGL_image_external : require \\n&quot;</span><span class=\"comment\">//启用扩展（ES2.0也支持OES外部纹理）</span></span><br><span class=\"line\"><span class=\"string\">&quot; precision mediump float;\\n &quot;</span><span class=\"comment\">//Fragshader使用浮点型时必须指定精度，指定float类型默认的mediump中精度（-2^14 ~ 2^14）</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">//&quot; in vec3 TexCoord; \\n &quot;//输入vTexCoord纹理坐标vec3,从Vertshader中传入的</span></span><br><span class=\"line\"><span class=\"comment\">//&quot; out vec4 fragColor; \\n &quot;//输出片元颜色</span></span><br><span class=\"line\"><span class=\"string\">&quot; attribute vec3 TexCoord; \\n &quot;</span><span class=\"comment\">//ES2.0中attribute，ES3.0中in</span></span><br><span class=\"line\"><span class=\"string\">&quot; varying vec4 fragColor; \\n &quot;</span><span class=\"comment\">//ES2.0中varying，ES3.0中out</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"string\">&quot;uniform sampler2D myTexture;\\n&quot;</span><span class=\"comment\">//ES 2.0支持sample2D纹理和sampleCube纹理</span></span><br><span class=\"line\"><span class=\"string\">&quot; uniform vec4 myGain; \\n &quot;</span><span class=\"comment\">//uniform用于ES传入数据myGain</span></span><br><span class=\"line\"><span class=\"string\">&quot; void main() \\n &quot;</span><span class=\"comment\">//主函数</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#123;\\n &quot;</span></span><br><span class=\"line\"><span class=\"comment\">//&quot;  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, TexCoord.z)+vec4(myGain.xyz,0.0); \\n &quot;//2.25</span></span><br><span class=\"line\"><span class=\"string\">&quot;  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, 1.0); \\n &quot;</span><span class=\"comment\">//2.25</span></span><br><span class=\"line\"><span class=\"comment\">//&quot;\t fragColor = vec4(0.3, 0.4, 0.5, TexCoord.z)+vec4(myGain.xyz,0.0); \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#125;\\n &quot;</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-OpenGL-ES-3-0\"><a href=\"#2-OpenGL-ES-3-0\" class=\"headerlink\" title=\"2.OpenGL ES 3.0\"></a>2.OpenGL ES 3.0</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/***********************GLRender Normal texture***********************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> CommonVertshader_Normal[] =</span><br><span class=\"line\"><span class=\"string\">&quot; #version 300 es \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; precision mediump float;\\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; layout(location = 0) in vec4 vPosition; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; layout(location = 1) in vec2 vTexCoord; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; out vec3 TexCoord; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; uniform mat4 mvp; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; void main() \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#123; \\n &quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;vec4 temPosition = mvp * vec4(vPosition.x, vPosition.y, vPosition.z, 1); \\n&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot; gl_Position = vec4(temPosition.x, -temPosition.y, temPosition.z, temPosition.a); \\n &quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot; TexCoord = vec3(vTexCoord, vPosition.w); \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#125; \\n &quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span> CommonFragshader_Normal[] =</span><br><span class=\"line\"><span class=\"string\">&quot;#version 300 es \\n&quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> (!VT_SAMPLE2D_SELECTED &amp;&amp; !FIX_CAMERA_IMAGE)</span></span><br><span class=\"line\"><span class=\"string\">&quot;#extension GL_OES_EGL_image_external : require \\n&quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"string\">&quot; precision mediump float;\\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; in vec3 TexCoord; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; out vec4 fragColor; \\n &quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> (VT_SAMPLE2D_SELECTED || FIX_CAMERA_IMAGE)</span></span><br><span class=\"line\"><span class=\"string\">&quot;uniform sampler2D myTexture;\\n&quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\"><span class=\"string\">&quot; uniform samplerExternalOES myTexture; \\n &quot;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"string\">&quot; uniform vec4 myGain; \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; void main() \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#123;\\n &quot;</span></span><br><span class=\"line\"><span class=\"comment\">//&quot;  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, TexCoord.z)+vec4(myGain.xyz,0.0); \\n &quot;//2.25</span></span><br><span class=\"line\"><span class=\"string\">&quot;  \t\tfragColor = vec4(texture(myTexture, TexCoord.xy).rgb, 1.0); \\n &quot;</span><span class=\"comment\">//2.25</span></span><br><span class=\"line\"><span class=\"comment\">//&quot;\t fragColor = vec4(0.3, 0.4, 0.5, TexCoord.z)+vec4(myGain.xyz,0.0); \\n &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; &#125;\\n &quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-着色器语言简介\"><a href=\"#3-着色器语言简介\" class=\"headerlink\" title=\"3.着色器语言简介\"></a>3.着色器语言简介</h2><p>OpenGLES的着色器语言GLSL是一种高级的图形化编程语言，其源自应用广泛的C语言。与传统的C语言不同的是，它提供了更加丰富的针对于图像处理的原生类型，诸如向量、矩阵之类。OpenGLES 主要包含以下特性：</p>\n<ul>\n<li>GLSL是一种面向过程的语言，和Java的面向对象是不同的。</li>\n<li>GLSL的基本语法与C&#x2F;C++基本相同。</li>\n<li>它完美的支持向量和矩阵操作。</li>\n<li>它是通过限定符操作来管理输入输出类型的。</li>\n<li>GLSL提供了大量的内置函数来提供丰富的扩展功能。</li>\n</ul>\n<h2 id=\"4-数据类型\"><a href=\"#4-数据类型\" class=\"headerlink\" title=\"4.数据类型\"></a>4.数据类型</h2><p>GLSL中的数据类型主要分为标量、向量、矩阵、采样器、结构体、数组、空类型七种类型：</p>\n<ul>\n<li>标量：标量表示的是只有大小没有方向的量，在GLSL中标量只有bool、int和float三种。对于int，和C一样，可以写为十进制（16）、八进制（020）或者十六进制（0x10）。关于进制不了解的，得自己补补，这是编程基础。<strong>对于标量的运算，我们最需要注意的是精度，防止溢出问题</strong>。</li>\n<li>向量：向量我们可以看做是数组，在GLSL通常用于储存颜色、坐标等数据，针对维数，可分为二维、三维和四位向量。针对存储的标量类型，可以分为bool、int和float。共有vec2、vec3、vec4，ivec2、ivec3、ivec4、bvec2、bvec3和bvec4九种类型，数组代表维数、i表示int类型、b表示bool类型。<strong>需要注意的是，GLSL中的向量表示竖向量，所以与矩阵相乘进行变换时，矩阵在前，向量在后（与DirectX正好相反）</strong>。向量在GPU中由硬件支持运算，比CPU快的多。</li>\n</ul>\n<blockquote>\n<ol>\n<li>作为颜色向量时，用rgba表示分量，就如同取数组的中具体数据的索引值。三维颜色向量就用rgb表示分量。比如对于颜色向量vec4 color，color[0]和color.r都表示color向量的第一个值，也就是红色的分量。其他相同。</li>\n<li>作为位置向量时，用xyzw表示分量，xyz分别表示xyz坐标，w表示向量的模。三维坐标向量为xyz表示分量，二维向量为xy表示分量。</li>\n<li>作为纹理向量时，用stpq表示分量，三维用stp表示分量，二维用st表示分量。</li>\n</ol>\n</blockquote>\n<ul>\n<li>矩阵：在GLSL中矩阵拥有2<em>2、3</em>3、4*4三种类型的矩阵，分别用mat2、mat3、mat4表示。我们可以把矩阵看做是一个二维数组，也可以用二维数组下表的方式取里面具体位置的值。</li>\n<li>采样器：采样器是专门用来对纹理进行采样工作的，在GLSL中一般来说，一个采样器变量表示一副或者一套纹理贴图。所谓的纹理贴图可以理解为我们看到的物体上的皮肤。</li>\n<li>结构体：和C语言中的结构体相同，用struct来定义结构体，关于结构体参考C语言中的结构体。</li>\n<li>数组：数组知识也和C中相同，不同的是数组声明时可以不指定大小，但是建议在不必要的情况下，还是指定大小的好。</li>\n<li>空类型：空类型用void表示，仅用来声明不返回任何值得函数。</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> a=<span class=\"number\">1.0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> b=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">bool</span> c=<span class=\"literal\">true</span>;</span><br><span class=\"line\">vec2 d=vec2(<span class=\"number\">1.0</span>,<span class=\"number\">2.0</span>);</span><br><span class=\"line\">vec3 e=vec3(<span class=\"number\">1.0</span>,<span class=\"number\">2.0</span>,<span class=\"number\">3.0</span>)</span><br><span class=\"line\">vec4 f=vec4(vec3,<span class=\"number\">1.2</span>);</span><br><span class=\"line\">vec4 g=vec4(<span class=\"number\">0.2</span>);  <span class=\"comment\">//相当于vec(0.2,0.2,0.2,0.2)</span></span><br><span class=\"line\">vec4 h=vec4(a,a,<span class=\"number\">1.3</span>,a);</span><br><span class=\"line\">mat2 i=mat2(<span class=\"number\">0.1</span>,<span class=\"number\">0.5</span>,<span class=\"number\">1.2</span>,<span class=\"number\">2.4</span>);</span><br><span class=\"line\">mat2 j=mat2(<span class=\"number\">0.8</span>);   <span class=\"comment\">//相当于mat2(0.8,0.8,0.8,0.8)</span></span><br><span class=\"line\">mat3 k=mat3(e,e,<span class=\"number\">1.2</span>,<span class=\"number\">1.6</span>,<span class=\"number\">1.8</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-运算符\"><a href=\"#5-运算符\" class=\"headerlink\" title=\"5.运算符\"></a>5.运算符</h2><p>GLSL中的运算符有（越靠前，运算优先级越高）：</p>\n<ol>\n<li>索引：[]</li>\n<li>前缀自加和自减：++，–</li>\n<li>一元非和逻辑非：~，！</li>\n<li>加法和减法：+，-</li>\n<li>等于和不等于：&#x3D;&#x3D;，！&#x3D;</li>\n<li>逻辑异或：^^</li>\n<li>三元运算符号，选择：？:</li>\n<li>成员选择与混合：.</li>\n<li>后缀自加和自减：++，–</li>\n<li>乘法和除法：*，&#x2F;</li>\n<li>关系运算符：&gt;，&lt;，&#x3D;，&gt;&#x3D;，&lt;&#x3D;，&lt;&gt;</li>\n<li>逻辑与：&amp;&amp;</li>\n<li>逻辑或：||</li>\n<li>赋值预算：&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</li>\n</ol>\n<h2 id=\"6-类型转换\"><a href=\"#6-类型转换\" class=\"headerlink\" title=\"6.类型转换\"></a>6.类型转换</h2><p>GLSL的类型转换与C不同。在GLSL中类型不可以自动提升，比如float a&#x3D;1;就是一种错误的写法，必须严格的写成float a&#x3D;1.0，也不可以强制转换，即float a&#x3D;(float)1;也是错误的写法，但是可以用内置函数来进行转换，如float a&#x3D;float(1);还有float a&#x3D;float(true);（true为1.0，false为0.0）等，值得注意的是，<strong>低精度的int不能转换为低精度的float</strong>。</p>\n<h2 id=\"7-限定符\"><a href=\"#7-限定符\" class=\"headerlink\" title=\"7.限定符\"></a>7.限定符</h2><p>GLSL中的限定符号主要有：</p>\n<ul>\n<li>attritude：一般用于各个顶点各不相同的量。如顶点颜色、坐标等。</li>\n<li>uniform：一般用于对于3D物体中所有顶点都相同的量。比如光源位置，统一变换矩阵等。</li>\n<li>varying：表示易变量，一般用于顶点着色器传递到片元着色器的量。</li>\n<li>const：常量。</li>\n</ul>\n<p>限定符与java限定符类似，放在变量类型之前，并且只能用于全局变量。在GLSL中，没有默认限定符一说。</p>\n<h2 id=\"8-流程控制\"><a href=\"#8-流程控制\" class=\"headerlink\" title=\"8.流程控制\"></a>8.流程控制</h2><p>GLSL中的流程控制与C中基本相同，主要有：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>()&#123;&#125;、<span class=\"keyword\">if</span>()&#123;&#125;<span class=\"keyword\">else</span>&#123;&#125;、<span class=\"keyword\">if</span>()&#123;&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>()&#123;&#125;<span class=\"keyword\">else</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span>()&#123;&#125;和<span class=\"keyword\">do</span>&#123;&#125;<span class=\"keyword\">while</span>()</span><br><span class=\"line\"><span class=\"keyword\">for</span>(;;)&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">break</span>和<span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-函数\"><a href=\"#9-函数\" class=\"headerlink\" title=\"9.函数\"></a>9.函数</h2><p>GLSL中也可以定义函数，定义函数的方式也与C语言基本相同。函数的返回值可以是GLSL中的除了采样器的任意类型。对于GLSL中函数的参数，可以用参数用途修饰符来进行修饰，常用修饰符如下：</p>\n<ul>\n<li>in：输入参数，无修饰符时默认为此修饰符。</li>\n<li>out：输出参数。</li>\n<li>inout：既可以作为输入参数，又可以作为输出参数。</li>\n</ul>\n<h2 id=\"10-浮点精度\"><a href=\"#10-浮点精度\" class=\"headerlink\" title=\"10.浮点精度\"></a>10.浮点精度</h2><p>与顶点着色器不同的是，在片元着色器中使用浮点型时，必须指定浮点类型的精度，否则编译会报错。精度有三种，分别为：</p>\n<ul>\n<li>lowp：低精度。8位。</li>\n<li>mediump：中精度。10位。</li>\n<li>highp：高精度。16位。</li>\n</ul>\n<p>具体如下表：</p>\n<p><img src=\"/2023/04/14/4-7-GLSL%E7%9D%80%E8%89%B2%E5%99%A8%E8%AF%AD%E8%A8%80/21.webp\"></p>\n<p>不仅仅是float可以制定精度，其他（除了bool相关）类型也同样可以，但是int、采样器类型并不一定要求指定精度。加精度的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform lowp <span class=\"type\">float</span> a=<span class=\"number\">1.0</span>;</span><br><span class=\"line\">varying mediump vec4 c;</span><br></pre></td></tr></table></figure>\n\n<p>当然，也可以在片元着色器中设置默认精度，只需要在片元着色器最上面加上precision &lt;精度&gt; &lt;类型&gt;即可制定某种类型的默认精度。其他情况相同的话，精度越高，画质越好，使用的资源也越多。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precision mediump <span class=\"type\">float</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-程序结构\"><a href=\"#11-程序结构\" class=\"headerlink\" title=\"11.程序结构\"></a>11.程序结构</h2><p>GLSL程序的结构和C语言差不多，main()方法表示入口函数，可以在其上定义函数和变量，在main中可以引用这些变量和函数。定义在函数体以外的叫做全局变量，定义在函数体内的叫做局部变量。与高级语言不通的是，变量和函数在使用前必须声明，不能再使用的后面声明变量或者函数。</p>\n<h2 id=\"12-内建变量\"><a href=\"#12-内建变量\" class=\"headerlink\" title=\"12.内建变量\"></a>12.内建变量</h2><p>在着色器中我们一般都会声明变量来在程序中使用，但是着色器中还有一些特殊的变量，不声明也可以使用。这些变量叫做内建变量。內建变量，相当于着色器硬件的输入和输出点，使用者利用这些输入点输入之后，就会看到屏幕上的输出。通过输出点可以知道输出的某些数据内容。当然，实际上肯定不会这样简单，这么说只是为了帮助理解。在顶点着色器中的内建变量和片元着色器的内建变量是不相同的。着色器中的内建变量有很多，在此，我们只列出最常用的集中内建变量。</p>\n<p> 顶点着色器的内建变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入变量：</span><br><span class=\"line\">    gl_Position：顶点坐标</span><br><span class=\"line\">    gl_PointSize：点的大小，没有赋值则为默认值1，通常设置绘图为点绘制才有意义。</span><br></pre></td></tr></table></figure>\n\n<p>片元着色器的内建变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 输入变量</span><br><span class=\"line\">    gl_FragCoord：当前片元相对窗口位置所处的坐标。</span><br><span class=\"line\">    gl_FragFacing：<span class=\"type\">bool</span>型，表示是否为属于光栅化生成此片元的对应图元的正面。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 输出变量</span><br><span class=\"line\">    gl_FragColor：当前片元颜色</span><br><span class=\"line\">    gl_FragData：vec4类型的数组。向其写入的信息，供渲染管线的后继过程使用。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"13-常用内置函数\"><a href=\"#13-常用内置函数\" class=\"headerlink\" title=\"13.常用内置函数\"></a>13.常用内置函数</h2><h3 id=\"13-1常见函数\"><a href=\"#13-1常见函数\" class=\"headerlink\" title=\"13.1常见函数\"></a>13.1常见函数</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">radians(x)：角度转弧度</span><br><span class=\"line\">degrees(x)：弧度转角度</span><br><span class=\"line\">sin(x)：正弦函数，传入值为弧度。相同的还有cos余弦函数、tan正切函数、asin反正弦、acos反余弦、atan反正切</span><br><span class=\"line\">pow(x,y)：xy</span><br><span class=\"line\">exp(x)：ex</span><br><span class=\"line\">exp2(x)：<span class=\"number\">2</span>x</span><br><span class=\"line\">log(x)：logex</span><br><span class=\"line\">log2(x)：log2x</span><br><span class=\"line\">sqrt(x)：x√</span><br><span class=\"line\">inversesqr(x)：<span class=\"number\">1</span>x√</span><br><span class=\"line\">abs(x)：取x的绝对值</span><br><span class=\"line\">sign(x)：x&gt;<span class=\"number\">0</span>返回<span class=\"number\">1.0</span>，x&lt;<span class=\"number\">0</span>返回-<span class=\"number\">1.0</span>，否则返回<span class=\"number\">0.0</span></span><br><span class=\"line\">ceil(x)：返回大于或者等于x的整数</span><br><span class=\"line\">floor(x)：返回小于或者等于x的整数</span><br><span class=\"line\">fract(x)：返回x-floor(x)的值</span><br><span class=\"line\">mod(x,y)：取模（求余）</span><br><span class=\"line\">min(x,y)：获取xy中小的那个</span><br><span class=\"line\">max(x,y)：获取xy中大的那个</span><br><span class=\"line\">mix(x,y,<span class=\"selector-tag\">a</span>)：返回x∗(<span class=\"number\">1</span>−<span class=\"selector-tag\">a</span>)+y∗<span class=\"selector-tag\">a</span></span><br><span class=\"line\">step(x,<span class=\"selector-tag\">a</span>)：x&lt; <span class=\"selector-tag\">a</span>返回<span class=\"number\">0.0</span>，否则返回<span class=\"number\">1.0</span></span><br><span class=\"line\">smoothstep(x,y,<span class=\"selector-tag\">a</span>)：<span class=\"selector-tag\">a</span> &lt; x返回<span class=\"number\">0.0</span>，<span class=\"selector-tag\">a</span>&gt;y返回<span class=\"number\">1.0</span>，否则返回<span class=\"number\">0.0</span>-<span class=\"number\">1.0</span>之间平滑的Hermite插值。</span><br><span class=\"line\">dFdx(<span class=\"selector-tag\">p</span>)：<span class=\"selector-tag\">p</span>在x方向上的偏导数</span><br><span class=\"line\">dFdy(<span class=\"selector-tag\">p</span>)：<span class=\"selector-tag\">p</span>在y方向上的偏导数</span><br><span class=\"line\">fwidth(<span class=\"selector-tag\">p</span>)：<span class=\"selector-tag\">p</span>在x和y方向上的偏导数的绝对值之和</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2几何函数\"><a href=\"#13-2几何函数\" class=\"headerlink\" title=\"13.2几何函数\"></a>13.2几何函数</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">length(x)：计算向量x的长度</span><br><span class=\"line\">distance(x,y)：返回向量xy之间的距离</span><br><span class=\"line\">dot(x,y)：返回向量xy的点积</span><br><span class=\"line\">cross(x,y)：返回向量xy的差积</span><br><span class=\"line\">normalize(x)：返回与x向量方向相同，长度为<span class=\"number\">1</span>的向量</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-3矩阵函数\"><a href=\"#13-3矩阵函数\" class=\"headerlink\" title=\"13.3矩阵函数\"></a>13.3矩阵函数</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrixCompMult(x,y)：将矩阵相乘</span><br><span class=\"line\">lessThan(x,y)：返回向量xy的各个分量执行x&lt; y的结果，类似的有greaterThan,equal,notEqual</span><br><span class=\"line\">lessThanEqual(x,y)：返回向量xy的各个分量执行x&lt;= y的结果，类似的有类似的有greaterThanEqual</span><br><span class=\"line\">any(bvec x)：x有一个元素为true，则为true</span><br><span class=\"line\"><span class=\"attribute\">all</span>(bvec x)：x所有元素为true，则返回true，否则返回false</span><br><span class=\"line\">not(bvec x)：x所有分量执行逻辑非运算</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-4纹理采样函数\"><a href=\"#13-4纹理采样函数\" class=\"headerlink\" title=\"13.4纹理采样函数\"></a>13.4纹理采样函数</h3><p>纹理采样函数有texture2D、texture2DProj、texture2DLod、texture2DProjLod、textureCube、textureCubeLod及texture3D、texture3DProj、texture3DLod、texture3DProjLod等。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">texture表示纹理采样，<span class=\"number\">2</span>D表示对<span class=\"number\">2</span>D纹理采样，<span class=\"number\">3</span>D表示对<span class=\"number\">3</span>D纹理采样</span><br><span class=\"line\">Lod后缀，只适用于顶点着色器采样</span><br><span class=\"line\">Proj表示纹理坐标st会除以<span class=\"selector-tag\">q</span></span><br></pre></td></tr></table></figure>\n\n<p>纹理采样函数中，3D在OpenGLES2.0并不是绝对支持。我们再次暂时不管3D纹理采样函数。重点只对texture2D函数进行说明。texture2D拥有三个参数，第一个参数表示纹理采样器。第二个参数表示纹理坐标，可以是二维、三维、或者四维。第三个参数加入后只能在片元着色器中调用，且只对采样器为mipmap类型纹理时有效。</p>\n<h2 id=\"14-attribute、uniform、varying、in、out\"><a href=\"#14-attribute、uniform、varying、in、out\" class=\"headerlink\" title=\"14.attribute、uniform、varying、in、out\"></a>14.attribute、uniform、varying、in、out</h2><h3 id=\"1-attribute\"><a href=\"#1-attribute\" class=\"headerlink\" title=\"1.attribute:\"></a>1.attribute:</h3><p>根据OpenGL2.0和OpenGLES2.0标准，仅用在VertexShader中，至少支持8个attribute属性。OpenGL3.0里，至少支持16个。通常用来存储位置坐标、法向量、纹理坐标和颜色等。我们在上一阶段的OpenGL学习中每个Shader都有用到。 </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">attribute vec4 <span class=\"attribute\">position</span>;</span><br><span class=\"line\">attribute vec4 <span class=\"attribute\">color</span>;</span><br><span class=\"line\">attribute vec4 texcoord;</span><br><span class=\"line\">attribute vec4 <span class=\"attribute\">normal</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法一：\"><a href=\"#方法一：\" class=\"headerlink\" title=\"方法一：\"></a>方法一：</h4><p>在C++中先获取在哪个属性组： </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mPositionLocation = glGetAttribLocation(mProgram, &quot;<span class=\"attribute\">position</span>&quot;);</span><br><span class=\"line\">mColorLocation = glGetAttribLocation(mProgram, &quot;<span class=\"attribute\">color</span>&quot;);</span><br><span class=\"line\">mTexcoordLocation = glGetAttribLocation(mProgram, &quot;texcoord&quot;);</span><br><span class=\"line\">mNormalLocation = glGetAttribLocation(mProgram, &quot;<span class=\"attribute\">normal</span>&quot;);</span><br></pre></td></tr></table></figure>\n\n<p>设置VBO与通用属性组关系：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(mPositionLocation);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(mPositionLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"built_in\">sizeof</span>(Vertex), <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(mColorLocation);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(mColorLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"built_in\">sizeof</span>(Vertex), (<span class=\"type\">void</span>*)(<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>) * <span class=\"number\">4</span>));</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(mTexcoordLocation);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(mTexcoordLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"built_in\">sizeof</span>(Vertex), (<span class=\"type\">void</span>*)(<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>) * <span class=\"number\">8</span>));</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(mNormalLocation);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(mNormalLocation, <span class=\"number\">4</span>, GL_FLOAT, GL_FALSE, <span class=\"built_in\">sizeof</span>(Vertex), (<span class=\"type\">void</span>*)(<span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>) * <span class=\"number\">12</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"方法二：\"><a href=\"#方法二：\" class=\"headerlink\" title=\"方法二：\"></a>方法二：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GLbyte vertexShaderSrc[] =</span><br><span class=\"line\"><span class=\"string\">&quot;attribute vec4 a_position; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;attribute vec4 a_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;varying vec4 v_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;void main() \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#123; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; v_color = a_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; gl_Position = a_position; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\">GLbyte fragmentShaderSrc[] =</span><br><span class=\"line\"><span class=\"string\">&quot;varying vec4 v_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;void main() \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#123; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; gl_FragColor = v_color; \\n&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\">GLfloat color[<span class=\"number\">4</span>] = &#123; <span class=\"number\">1.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">0.0f</span>, <span class=\"number\">1.0f</span> &#125;;</span><br><span class=\"line\">GLfloat vertexPos[<span class=\"number\">3</span> * <span class=\"number\">3</span>]; <span class=\"comment\">// 3 vertices, with (x,y,z) per-vertex</span></span><br><span class=\"line\">GLuint shaderObject[<span class=\"number\">2</span>];</span><br><span class=\"line\">GLuint programObject;</span><br><span class=\"line\">shaderObject[<span class=\"number\">0</span>] = <span class=\"built_in\">LoadShader</span>(vertexShaderSrc, GL_VERTEX_SHADER);</span><br><span class=\"line\">shaderObject[<span class=\"number\">1</span>] = <span class=\"built_in\">LoadShader</span>(fragmentShaderSrc, GL_FRAGMENT_SHADER);</span><br><span class=\"line\">programObject = <span class=\"built_in\">glCreateProgram</span>();</span><br><span class=\"line\"><span class=\"built_in\">glAttachShader</span>(programObject, shaderObject[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"built_in\">glAttachShader</span>(programObject, shaderObject[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">glVertexAttrib4fv</span>(<span class=\"number\">0</span>, color);</span><br><span class=\"line\"><span class=\"built_in\">glVertexAttribPointer</span>(<span class=\"number\">1</span>, <span class=\"number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"number\">0</span>, vertexPos);</span><br><span class=\"line\"><span class=\"built_in\">glEnableVertexAttribArray</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">glBindAttribLocation</span>(programObject, <span class=\"number\">0</span>, <span class=\"string\">&quot;a_color&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">glBindAttribLocation</span>(programObject, <span class=\"number\">1</span>, <span class=\"string\">&quot;a_position&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">glLinkProgram</span>(programObject);</span><br><span class=\"line\"><span class=\"built_in\">glUseProgram</span>(programObject);</span><br><span class=\"line\"><span class=\"built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-unifrom\"><a href=\"#2-unifrom\" class=\"headerlink\" title=\"2.unifrom:\"></a>2.unifrom:</h3><p>可存在所有shader中，OpenGL2.0中，数量至少有128个。可存放矩阵、材质等任何attribute放不下的属性。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uniform mat4 ModelMatrix;</span><br><span class=\"line\">uniform mat4 ViewMatrix;</span><br><span class=\"line\">uniform mat4 ProjectionMatrix;</span><br></pre></td></tr></table></figure>\n\n<p>在C++中，先获取位置：c</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mModelMatrixLocation = glGetUniformLocation(mProgram, &quot;ModelMatrix&quot;);</span><br><span class=\"line\">mViewMatrixLocation = glGetUniformLocation(mProgram, &quot;ViewMatrix&quot;);</span><br><span class=\"line\">mProjectionMatrixLocation = glGetUniformLocation(mProgram, &quot;ProjectionMatrix&quot;);</span><br></pre></td></tr></table></figure>\n\n\n<p>设置参数：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glUniformMatrix4fv(mModelMatrixLocation, <span class=\"number\">1</span>, GL_FALSE, M);</span><br><span class=\"line\">glUniformMatrix4fv(mViewMatrixLocation, <span class=\"number\">1</span>, GL_FALSE, V);</span><br><span class=\"line\">glUniformMatrix4fv(mProjectionMatrixLocation, <span class=\"number\">1</span>, GL_FALSE, <span class=\"selector-tag\">P</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-varying\"><a href=\"#3-varying\" class=\"headerlink\" title=\"3.varying:\"></a>3.varying:</h3><p>用于shader之间的数据传递，在OpenGL2.0。最多传递8个Vec4大小的数据，即2个mat4矩阵。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">varying vec4 V_Texcoord;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-in\"><a href=\"#4-in\" class=\"headerlink\" title=\"4.in:\"></a>4.in:</h3><p>表示某个Shader阶段的输入。varying可以改为in。即fs中的输入为vs中的输出。</p>\n<h3 id=\"5-out\"><a href=\"#5-out\" class=\"headerlink\" title=\"5.out:\"></a>5.out:</h3><p>代表每个shader的输出。也可以代替varying。in和out在3.0之后的版本使用。</p>"},{"title":"OpenGL矩阵运算---GLM库的使用","date":"2023-04-14T13:55:11.000Z","comments":0,"description":null,"typora-root-url":"4-8-OpenGL矩阵运算-GLM库的使用","_content":"\n# OpenGL矩阵运算---GLM库的使用\n\n## GLM库简介\n\nOpenGL没有内建矩阵运算方法，常用的第三方库为GLM。GLM是OpenGL Mathematics的缩写。作为一个header only库，GLM只要包括了相应的头文件就可以使用它提供的类和函数。GLM是C++语言编写的，故不适用于C语言工程。\n\n<!--more-->\n\n## 头文件\n\n- GLM对于矩阵数据类型的定义位于glm/glm.hpp头文件中。\n- 生成变换矩阵的函数位于glm/gtc/matrix_transform.hpp头文件中。\n- 生成投影矩阵的函数位于glm/ext/matrix_clip_space.hpp头文件中。\n- 将数组转换成矩阵的函数位于头文件glm/gtc/type_ptr.hpp中。\n- glm::value_ptr函数位于头文件glm/gtc/type_ptr.hpp中\n\n## GLM常用数据类型\n\n- vec2 二维向量\n- vec3 三维向量\n- vec4 四维向量\n- mat2 二阶矩阵\n- mat3 三阶矩阵\n- mat4 四阶矩阵\n\n## GLM常用函数\n\n- glm::radians()\n\n  角度制转弧度制，可应用于glm::rotate()中。\n\n- glm::translate()\n\n  返回一个平移矩阵，第一个参数是目标矩阵，第二个参数是平移的方向向量。\n\n- glm::rotate()\n\n  返回一个将点绕某个轴逆时针旋转一定弧度的旋转矩阵，第一个参数是弧度，第二个参数是旋转轴。\n\n- glm::scale()\n\n  返回一个缩放矩阵，第一个参数是目标矩阵，第二个参数是在各坐标轴上的缩放系数\n\n- glm::ortho(float left, float right, float bottom, float top, float zNear, float zFar);\n\n  正交投影矩阵。前四个参数分别是视口的左、右、上、下坐标。第五和第六个参数则定义了近平面和远平面的距离。\n\n- glm::perspective(float fovy, float aspect, float zNear, float zFar);\n\n  透视投影矩阵。第一个参数为视锥上下面之间的夹角，第二个参数为视口宽高比，第三、四个参数分别为近平面和远平面的深度。\n\n- glm::value_ptr()\n\n  传入一个矩阵，返回一个数组。\n\n- glm::lookAt(eye, center, up) \n\n- 用于产生视图矩阵（view matrix）\n\n  ```\n  eye实际上就是摄像机的位置\n  center就是摄像机的方向，您正在查看的位置(一个位置)，相机所看的点(场景的中心)\n  up就是上轴，定义您世界的\"向上\"方向的向量\n  \n  eye -> cameraPos\n  center -> cameraPos + cameraFront\n  up -> cameraUp\n  ```\n\n  \n\n## GLM矩阵的默认构造\n\nGLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵。如果使用0.9.9及以上的版本，需要在声明矩阵时传入参数1，例如glm::mat4 mat(1.0f)。\n\n## 向着色器中输入矩阵\n\n### glm::value_ptr函数\n\nGLM的glm::value_ptr()函数可以返回一个数组，其中按列优先储存了矩阵的元素。例如：\n\n```cpp\n#include <glm/glm.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <iostream>\n#include <typeinfo>\n\nint main() {\n\tglm::mat4 trans(1.0f);\n    trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0, 1, 0));\n    //0  0  1  0\n\t//0  1  0  0\n\t//-1 0  0  0\n\t//0  0  0  1\n    float *p = glm::value_ptr(trans);\n\tstd::cout << typeid(p).name() << std::endl;\n\tfor (int i=0; i < 16; i++) {\n\t\tstd::cout << *p << ' ';\n\t\tp++;\n\t}\n\tstd::cout << std::endl;\n\treturn 0;\n}\n//输出结果：\n//float *\n//0 0 -1 0 0 1 0 0 1 0 0 0 0 0 0 1\n\n```\n\n 我们可以用glm::value_ptr()搭配glUniformMatrix4fv函数向着色器传入矩阵： \n\n```cpp\nglUniformMatrix4fv(glGetUniformLocation(ID, \"name\"), 1, GL_FALSE, glm::value_ptr(trans));\n//ID为着色器程序的位置，glCreateProgram()的返回值\n//name为自己在着色器中定义的uniform，如：uniform mat4 transform\n\n```\n\n### glUniform3Matrix4fv函数\n\nvoid glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)\n\n- location: uniform的位置。\n- count: 需要加载数据的数组元素的数量或者需要修改的矩阵的数量。\n- transpose: 列优先矩阵传false,行优先矩阵传true。\n- value: 指向由count个元素的数组的指针。\n\n## GLSL中的向量*向量运算\n\n需要注意的是，在GLSL中，vec4 * vec4是逐元乘法（component wise），例如：\n\n```cpp\nvec4 a = vec4(1.0, 2.0, 3.0, 4.0);\nvec4 b = vec4(0.1, 0.2, 0.3, 0.4);\nvec4 c = a * b;\n//c: vec4(0.1, 0.4, 0.9, 1.6)\n```\n\n","source":"_posts/4-8-OpenGL矩阵运算-GLM库的使用.md","raw":"---\ntitle: OpenGL矩阵运算---GLM库的使用\ndate: 2023-4-14 21:55:11\ncategories: 笔记\ntags: [嵌入式,OpenGL]\ncomments: false\ndescription:\ntypora-root-url: 4-8-OpenGL矩阵运算-GLM库的使用\n---\n\n# OpenGL矩阵运算---GLM库的使用\n\n## GLM库简介\n\nOpenGL没有内建矩阵运算方法，常用的第三方库为GLM。GLM是OpenGL Mathematics的缩写。作为一个header only库，GLM只要包括了相应的头文件就可以使用它提供的类和函数。GLM是C++语言编写的，故不适用于C语言工程。\n\n<!--more-->\n\n## 头文件\n\n- GLM对于矩阵数据类型的定义位于glm/glm.hpp头文件中。\n- 生成变换矩阵的函数位于glm/gtc/matrix_transform.hpp头文件中。\n- 生成投影矩阵的函数位于glm/ext/matrix_clip_space.hpp头文件中。\n- 将数组转换成矩阵的函数位于头文件glm/gtc/type_ptr.hpp中。\n- glm::value_ptr函数位于头文件glm/gtc/type_ptr.hpp中\n\n## GLM常用数据类型\n\n- vec2 二维向量\n- vec3 三维向量\n- vec4 四维向量\n- mat2 二阶矩阵\n- mat3 三阶矩阵\n- mat4 四阶矩阵\n\n## GLM常用函数\n\n- glm::radians()\n\n  角度制转弧度制，可应用于glm::rotate()中。\n\n- glm::translate()\n\n  返回一个平移矩阵，第一个参数是目标矩阵，第二个参数是平移的方向向量。\n\n- glm::rotate()\n\n  返回一个将点绕某个轴逆时针旋转一定弧度的旋转矩阵，第一个参数是弧度，第二个参数是旋转轴。\n\n- glm::scale()\n\n  返回一个缩放矩阵，第一个参数是目标矩阵，第二个参数是在各坐标轴上的缩放系数\n\n- glm::ortho(float left, float right, float bottom, float top, float zNear, float zFar);\n\n  正交投影矩阵。前四个参数分别是视口的左、右、上、下坐标。第五和第六个参数则定义了近平面和远平面的距离。\n\n- glm::perspective(float fovy, float aspect, float zNear, float zFar);\n\n  透视投影矩阵。第一个参数为视锥上下面之间的夹角，第二个参数为视口宽高比，第三、四个参数分别为近平面和远平面的深度。\n\n- glm::value_ptr()\n\n  传入一个矩阵，返回一个数组。\n\n- glm::lookAt(eye, center, up) \n\n- 用于产生视图矩阵（view matrix）\n\n  ```\n  eye实际上就是摄像机的位置\n  center就是摄像机的方向，您正在查看的位置(一个位置)，相机所看的点(场景的中心)\n  up就是上轴，定义您世界的\"向上\"方向的向量\n  \n  eye -> cameraPos\n  center -> cameraPos + cameraFront\n  up -> cameraUp\n  ```\n\n  \n\n## GLM矩阵的默认构造\n\nGLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵。如果使用0.9.9及以上的版本，需要在声明矩阵时传入参数1，例如glm::mat4 mat(1.0f)。\n\n## 向着色器中输入矩阵\n\n### glm::value_ptr函数\n\nGLM的glm::value_ptr()函数可以返回一个数组，其中按列优先储存了矩阵的元素。例如：\n\n```cpp\n#include <glm/glm.hpp>\n#include <glm/gtc/type_ptr.hpp>\n#include <iostream>\n#include <typeinfo>\n\nint main() {\n\tglm::mat4 trans(1.0f);\n    trans = glm::rotate(trans, glm::radians(90.0f), glm::vec3(0, 1, 0));\n    //0  0  1  0\n\t//0  1  0  0\n\t//-1 0  0  0\n\t//0  0  0  1\n    float *p = glm::value_ptr(trans);\n\tstd::cout << typeid(p).name() << std::endl;\n\tfor (int i=0; i < 16; i++) {\n\t\tstd::cout << *p << ' ';\n\t\tp++;\n\t}\n\tstd::cout << std::endl;\n\treturn 0;\n}\n//输出结果：\n//float *\n//0 0 -1 0 0 1 0 0 1 0 0 0 0 0 0 1\n\n```\n\n 我们可以用glm::value_ptr()搭配glUniformMatrix4fv函数向着色器传入矩阵： \n\n```cpp\nglUniformMatrix4fv(glGetUniformLocation(ID, \"name\"), 1, GL_FALSE, glm::value_ptr(trans));\n//ID为着色器程序的位置，glCreateProgram()的返回值\n//name为自己在着色器中定义的uniform，如：uniform mat4 transform\n\n```\n\n### glUniform3Matrix4fv函数\n\nvoid glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)\n\n- location: uniform的位置。\n- count: 需要加载数据的数组元素的数量或者需要修改的矩阵的数量。\n- transpose: 列优先矩阵传false,行优先矩阵传true。\n- value: 指向由count个元素的数组的指针。\n\n## GLSL中的向量*向量运算\n\n需要注意的是，在GLSL中，vec4 * vec4是逐元乘法（component wise），例如：\n\n```cpp\nvec4 a = vec4(1.0, 2.0, 3.0, 4.0);\nvec4 b = vec4(0.1, 0.2, 0.3, 0.4);\nvec4 c = a * b;\n//c: vec4(0.1, 0.4, 0.9, 1.6)\n```\n\n","slug":"4-8-OpenGL矩阵运算-GLM库的使用","published":1,"updated":"2023-04-14T13:54:54.331Z","_id":"clgglk1jk0008hoob1vpaeq3r","layout":"post","photos":[],"link":"","content":"<h1 id=\"OpenGL矩阵运算—GLM库的使用\"><a href=\"#OpenGL矩阵运算—GLM库的使用\" class=\"headerlink\" title=\"OpenGL矩阵运算—GLM库的使用\"></a>OpenGL矩阵运算—GLM库的使用</h1><h2 id=\"GLM库简介\"><a href=\"#GLM库简介\" class=\"headerlink\" title=\"GLM库简介\"></a>GLM库简介</h2><p>OpenGL没有内建矩阵运算方法，常用的第三方库为GLM。GLM是OpenGL Mathematics的缩写。作为一个header only库，GLM只要包括了相应的头文件就可以使用它提供的类和函数。GLM是C++语言编写的，故不适用于C语言工程。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><ul>\n<li>GLM对于矩阵数据类型的定义位于glm&#x2F;glm.hpp头文件中。</li>\n<li>生成变换矩阵的函数位于glm&#x2F;gtc&#x2F;matrix_transform.hpp头文件中。</li>\n<li>生成投影矩阵的函数位于glm&#x2F;ext&#x2F;matrix_clip_space.hpp头文件中。</li>\n<li>将数组转换成矩阵的函数位于头文件glm&#x2F;gtc&#x2F;type_ptr.hpp中。</li>\n<li>glm::value_ptr函数位于头文件glm&#x2F;gtc&#x2F;type_ptr.hpp中</li>\n</ul>\n<h2 id=\"GLM常用数据类型\"><a href=\"#GLM常用数据类型\" class=\"headerlink\" title=\"GLM常用数据类型\"></a>GLM常用数据类型</h2><ul>\n<li>vec2 二维向量</li>\n<li>vec3 三维向量</li>\n<li>vec4 四维向量</li>\n<li>mat2 二阶矩阵</li>\n<li>mat3 三阶矩阵</li>\n<li>mat4 四阶矩阵</li>\n</ul>\n<h2 id=\"GLM常用函数\"><a href=\"#GLM常用函数\" class=\"headerlink\" title=\"GLM常用函数\"></a>GLM常用函数</h2><ul>\n<li><p>glm::radians()</p>\n<p>角度制转弧度制，可应用于glm::rotate()中。</p>\n</li>\n<li><p>glm::translate()</p>\n<p>返回一个平移矩阵，第一个参数是目标矩阵，第二个参数是平移的方向向量。</p>\n</li>\n<li><p>glm::rotate()</p>\n<p>返回一个将点绕某个轴逆时针旋转一定弧度的旋转矩阵，第一个参数是弧度，第二个参数是旋转轴。</p>\n</li>\n<li><p>glm::scale()</p>\n<p>返回一个缩放矩阵，第一个参数是目标矩阵，第二个参数是在各坐标轴上的缩放系数</p>\n</li>\n<li><p>glm::ortho(float left, float right, float bottom, float top, float zNear, float zFar);</p>\n<p>正交投影矩阵。前四个参数分别是视口的左、右、上、下坐标。第五和第六个参数则定义了近平面和远平面的距离。</p>\n</li>\n<li><p>glm::perspective(float fovy, float aspect, float zNear, float zFar);</p>\n<p>透视投影矩阵。第一个参数为视锥上下面之间的夹角，第二个参数为视口宽高比，第三、四个参数分别为近平面和远平面的深度。</p>\n</li>\n<li><p>glm::value_ptr()</p>\n<p>传入一个矩阵，返回一个数组。</p>\n</li>\n<li><p>glm::lookAt(eye, center, up) </p>\n</li>\n<li><p>用于产生视图矩阵（view matrix）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eye实际上就是摄像机的位置</span><br><span class=\"line\">center就是摄像机的方向，您正在查看的位置(一个位置)，相机所看的点(场景的中心)</span><br><span class=\"line\">up就是上轴，定义您世界的&quot;向上&quot;方向的向量</span><br><span class=\"line\"></span><br><span class=\"line\">eye -&gt; cameraPos</span><br><span class=\"line\">center -&gt; cameraPos + cameraFront</span><br><span class=\"line\">up -&gt; cameraUp</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"GLM矩阵的默认构造\"><a href=\"#GLM矩阵的默认构造\" class=\"headerlink\" title=\"GLM矩阵的默认构造\"></a>GLM矩阵的默认构造</h2><p>GLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵。如果使用0.9.9及以上的版本，需要在声明矩阵时传入参数1，例如glm::mat4 mat(1.0f)。</p>\n<h2 id=\"向着色器中输入矩阵\"><a href=\"#向着色器中输入矩阵\" class=\"headerlink\" title=\"向着色器中输入矩阵\"></a>向着色器中输入矩阵</h2><h3 id=\"glm-value-ptr函数\"><a href=\"#glm-value-ptr函数\" class=\"headerlink\" title=\"glm::value_ptr函数\"></a>glm::value_ptr函数</h3><p>GLM的glm::value_ptr()函数可以返回一个数组，其中按列优先储存了矩阵的元素。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;glm/glm.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;typeinfo&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">glm::mat4 <span class=\"title\">trans</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span></span>;</span><br><span class=\"line\">    trans = glm::<span class=\"built_in\">rotate</span>(trans, glm::<span class=\"built_in\">radians</span>(<span class=\"number\">90.0f</span>), glm::<span class=\"built_in\">vec3</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//0  0  1  0</span></span><br><span class=\"line\">\t<span class=\"comment\">//0  1  0  0</span></span><br><span class=\"line\">\t<span class=\"comment\">//-1 0  0  0</span></span><br><span class=\"line\">\t<span class=\"comment\">//0  0  0  1</span></span><br><span class=\"line\">    <span class=\"type\">float</span> *p = glm::<span class=\"built_in\">value_ptr</span>(trans);</span><br><span class=\"line\">\tstd::cout &lt;&lt; <span class=\"built_in\">typeid</span>(p).<span class=\"built_in\">name</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i++) &#123;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; *p &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tp++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::cout &lt;&lt; std::endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">//float *</span></span><br><span class=\"line\"><span class=\"comment\">//0 0 -1 0 0 1 0 0 1 0 0 0 0 0 0 1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 我们可以用glm::value_ptr()搭配glUniformMatrix4fv函数向着色器传入矩阵： </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glUniformMatrix4fv</span>(<span class=\"built_in\">glGetUniformLocation</span>(ID, <span class=\"string\">&quot;name&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::<span class=\"built_in\">value_ptr</span>(trans));</span><br><span class=\"line\"><span class=\"comment\">//ID为着色器程序的位置，glCreateProgram()的返回值</span></span><br><span class=\"line\"><span class=\"comment\">//name为自己在着色器中定义的uniform，如：uniform mat4 transform</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"glUniform3Matrix4fv函数\"><a href=\"#glUniform3Matrix4fv函数\" class=\"headerlink\" title=\"glUniform3Matrix4fv函数\"></a>glUniform3Matrix4fv函数</h3><p>void glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)</p>\n<ul>\n<li>location: uniform的位置。</li>\n<li>count: 需要加载数据的数组元素的数量或者需要修改的矩阵的数量。</li>\n<li>transpose: 列优先矩阵传false,行优先矩阵传true。</li>\n<li>value: 指向由count个元素的数组的指针。</li>\n</ul>\n<h2 id=\"GLSL中的向量-向量运算\"><a href=\"#GLSL中的向量-向量运算\" class=\"headerlink\" title=\"GLSL中的向量*向量运算\"></a>GLSL中的向量*向量运算</h2><p>需要注意的是，在GLSL中，vec4 * vec4是逐元乘法（component wise），例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 a = <span class=\"built_in\">vec4</span>(<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>);</span><br><span class=\"line\">vec4 b = <span class=\"built_in\">vec4</span>(<span class=\"number\">0.1</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.3</span>, <span class=\"number\">0.4</span>);</span><br><span class=\"line\">vec4 c = a * b;</span><br><span class=\"line\"><span class=\"comment\">//c: vec4(0.1, 0.4, 0.9, 1.6)</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"style":""}},"length":2437,"excerpt":"<h1 id=\"OpenGL矩阵运算—GLM库的使用\"><a href=\"#OpenGL矩阵运算—GLM库的使用\" class=\"headerlink\" title=\"OpenGL矩阵运算—GLM库的使用\"></a>OpenGL矩阵运算—GLM库的使用</h1><h2 id=\"GLM库简介\"><a href=\"#GLM库简介\" class=\"headerlink\" title=\"GLM库简介\"></a>GLM库简介</h2><p>OpenGL没有内建矩阵运算方法，常用的第三方库为GLM。GLM是OpenGL Mathematics的缩写。作为一个header only库，GLM只要包括了相应的头文件就可以使用它提供的类和函数。GLM是C++语言编写的，故不适用于C语言工程。</p>","more":"<h2 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h2><ul>\n<li>GLM对于矩阵数据类型的定义位于glm&#x2F;glm.hpp头文件中。</li>\n<li>生成变换矩阵的函数位于glm&#x2F;gtc&#x2F;matrix_transform.hpp头文件中。</li>\n<li>生成投影矩阵的函数位于glm&#x2F;ext&#x2F;matrix_clip_space.hpp头文件中。</li>\n<li>将数组转换成矩阵的函数位于头文件glm&#x2F;gtc&#x2F;type_ptr.hpp中。</li>\n<li>glm::value_ptr函数位于头文件glm&#x2F;gtc&#x2F;type_ptr.hpp中</li>\n</ul>\n<h2 id=\"GLM常用数据类型\"><a href=\"#GLM常用数据类型\" class=\"headerlink\" title=\"GLM常用数据类型\"></a>GLM常用数据类型</h2><ul>\n<li>vec2 二维向量</li>\n<li>vec3 三维向量</li>\n<li>vec4 四维向量</li>\n<li>mat2 二阶矩阵</li>\n<li>mat3 三阶矩阵</li>\n<li>mat4 四阶矩阵</li>\n</ul>\n<h2 id=\"GLM常用函数\"><a href=\"#GLM常用函数\" class=\"headerlink\" title=\"GLM常用函数\"></a>GLM常用函数</h2><ul>\n<li><p>glm::radians()</p>\n<p>角度制转弧度制，可应用于glm::rotate()中。</p>\n</li>\n<li><p>glm::translate()</p>\n<p>返回一个平移矩阵，第一个参数是目标矩阵，第二个参数是平移的方向向量。</p>\n</li>\n<li><p>glm::rotate()</p>\n<p>返回一个将点绕某个轴逆时针旋转一定弧度的旋转矩阵，第一个参数是弧度，第二个参数是旋转轴。</p>\n</li>\n<li><p>glm::scale()</p>\n<p>返回一个缩放矩阵，第一个参数是目标矩阵，第二个参数是在各坐标轴上的缩放系数</p>\n</li>\n<li><p>glm::ortho(float left, float right, float bottom, float top, float zNear, float zFar);</p>\n<p>正交投影矩阵。前四个参数分别是视口的左、右、上、下坐标。第五和第六个参数则定义了近平面和远平面的距离。</p>\n</li>\n<li><p>glm::perspective(float fovy, float aspect, float zNear, float zFar);</p>\n<p>透视投影矩阵。第一个参数为视锥上下面之间的夹角，第二个参数为视口宽高比，第三、四个参数分别为近平面和远平面的深度。</p>\n</li>\n<li><p>glm::value_ptr()</p>\n<p>传入一个矩阵，返回一个数组。</p>\n</li>\n<li><p>glm::lookAt(eye, center, up) </p>\n</li>\n<li><p>用于产生视图矩阵（view matrix）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eye实际上就是摄像机的位置</span><br><span class=\"line\">center就是摄像机的方向，您正在查看的位置(一个位置)，相机所看的点(场景的中心)</span><br><span class=\"line\">up就是上轴，定义您世界的&quot;向上&quot;方向的向量</span><br><span class=\"line\"></span><br><span class=\"line\">eye -&gt; cameraPos</span><br><span class=\"line\">center -&gt; cameraPos + cameraFront</span><br><span class=\"line\">up -&gt; cameraUp</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"GLM矩阵的默认构造\"><a href=\"#GLM矩阵的默认构造\" class=\"headerlink\" title=\"GLM矩阵的默认构造\"></a>GLM矩阵的默认构造</h2><p>GLM库从0.9.9版本起，默认会将矩阵类型初始化为一个零矩阵（所有元素均为0），而不是单位矩阵。如果使用0.9.9及以上的版本，需要在声明矩阵时传入参数1，例如glm::mat4 mat(1.0f)。</p>\n<h2 id=\"向着色器中输入矩阵\"><a href=\"#向着色器中输入矩阵\" class=\"headerlink\" title=\"向着色器中输入矩阵\"></a>向着色器中输入矩阵</h2><h3 id=\"glm-value-ptr函数\"><a href=\"#glm-value-ptr函数\" class=\"headerlink\" title=\"glm::value_ptr函数\"></a>glm::value_ptr函数</h3><p>GLM的glm::value_ptr()函数可以返回一个数组，其中按列优先储存了矩阵的元素。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;glm/glm.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;glm/gtc/type_ptr.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;typeinfo&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">glm::mat4 <span class=\"title\">trans</span><span class=\"params\">(<span class=\"number\">1.0f</span>)</span></span>;</span><br><span class=\"line\">    trans = glm::<span class=\"built_in\">rotate</span>(trans, glm::<span class=\"built_in\">radians</span>(<span class=\"number\">90.0f</span>), glm::<span class=\"built_in\">vec3</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//0  0  1  0</span></span><br><span class=\"line\">\t<span class=\"comment\">//0  1  0  0</span></span><br><span class=\"line\">\t<span class=\"comment\">//-1 0  0  0</span></span><br><span class=\"line\">\t<span class=\"comment\">//0  0  0  1</span></span><br><span class=\"line\">    <span class=\"type\">float</span> *p = glm::<span class=\"built_in\">value_ptr</span>(trans);</span><br><span class=\"line\">\tstd::cout &lt;&lt; <span class=\"built_in\">typeid</span>(p).<span class=\"built_in\">name</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"number\">16</span>; i++) &#123;</span><br><span class=\"line\">\t\tstd::cout &lt;&lt; *p &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\tp++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstd::cout &lt;&lt; std::endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出结果：</span></span><br><span class=\"line\"><span class=\"comment\">//float *</span></span><br><span class=\"line\"><span class=\"comment\">//0 0 -1 0 0 1 0 0 1 0 0 0 0 0 0 1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> 我们可以用glm::value_ptr()搭配glUniformMatrix4fv函数向着色器传入矩阵： </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glUniformMatrix4fv</span>(<span class=\"built_in\">glGetUniformLocation</span>(ID, <span class=\"string\">&quot;name&quot;</span>), <span class=\"number\">1</span>, GL_FALSE, glm::<span class=\"built_in\">value_ptr</span>(trans));</span><br><span class=\"line\"><span class=\"comment\">//ID为着色器程序的位置，glCreateProgram()的返回值</span></span><br><span class=\"line\"><span class=\"comment\">//name为自己在着色器中定义的uniform，如：uniform mat4 transform</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"glUniform3Matrix4fv函数\"><a href=\"#glUniform3Matrix4fv函数\" class=\"headerlink\" title=\"glUniform3Matrix4fv函数\"></a>glUniform3Matrix4fv函数</h3><p>void glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)</p>\n<ul>\n<li>location: uniform的位置。</li>\n<li>count: 需要加载数据的数组元素的数量或者需要修改的矩阵的数量。</li>\n<li>transpose: 列优先矩阵传false,行优先矩阵传true。</li>\n<li>value: 指向由count个元素的数组的指针。</li>\n</ul>\n<h2 id=\"GLSL中的向量-向量运算\"><a href=\"#GLSL中的向量-向量运算\" class=\"headerlink\" title=\"GLSL中的向量*向量运算\"></a>GLSL中的向量*向量运算</h2><p>需要注意的是，在GLSL中，vec4 * vec4是逐元乘法（component wise），例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec4 a = <span class=\"built_in\">vec4</span>(<span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>, <span class=\"number\">3.0</span>, <span class=\"number\">4.0</span>);</span><br><span class=\"line\">vec4 b = <span class=\"built_in\">vec4</span>(<span class=\"number\">0.1</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.3</span>, <span class=\"number\">0.4</span>);</span><br><span class=\"line\">vec4 c = a * b;</span><br><span class=\"line\"><span class=\"comment\">//c: vec4(0.1, 0.4, 0.9, 1.6)</span></span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/1-V4l2/1.png","slug":"1.png","post":"clgelnnse0002rgob33xj3z9r","modified":0,"renderable":0},{"_id":"source/_posts/1-V4l2/2.png","slug":"2.png","post":"clgelnnse0002rgob33xj3z9r","modified":0,"renderable":0},{"_id":"source/_posts/1-V4l2/3.png","slug":"3.png","post":"clgelnnse0002rgob33xj3z9r","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/1.png","slug":"1.png","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/10.jpg","slug":"10.jpg","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/11.jpg","slug":"11.jpg","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/12.jpg","slug":"12.jpg","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/2.png","slug":"2.png","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/3.png","slug":"3.png","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/4.png","slug":"4.png","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/5.png","slug":"5.png","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/6.png","slug":"6.png","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/7.png","slug":"7.png","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/8.png","slug":"8.png","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/2-YUV&RGB/9.jpg","slug":"9.jpg","post":"clgeng1v90000vwobec6993p8","modified":0,"renderable":0},{"_id":"source/_posts/3-G2D/1.png","slug":"1.png","post":"clggksiep0007n0obbpfcealk","modified":0,"renderable":0},{"_id":"source/_posts/4-1-OpenGL/1.png","slug":"1.png","post":"clggl89ar0000y4obh6kl4xmf","modified":0,"renderable":0},{"_id":"source/_posts/4-1-OpenGL/15.png","slug":"15.png","post":"clggl89ar0000y4obh6kl4xmf","modified":0,"renderable":0},{"_id":"source/_posts/4-1-OpenGL/2.png","slug":"2.png","post":"clggl89ar0000y4obh6kl4xmf","modified":0,"renderable":0},{"_id":"source/_posts/4-1-OpenGL/3.png","slug":"3.png","post":"clggl89ar0000y4obh6kl4xmf","modified":0,"renderable":0},{"_id":"source/_posts/4-1-OpenGL/4.png","slug":"4.png","post":"clggl89ar0000y4obh6kl4xmf","modified":0,"renderable":0},{"_id":"source/_posts/4-1-OpenGL/5.png","slug":"5.png","post":"clggl89ar0000y4obh6kl4xmf","modified":0,"renderable":0},{"_id":"source/_posts/4-1-OpenGL/6.png","slug":"6.png","post":"clggl89ar0000y4obh6kl4xmf","modified":0,"renderable":0},{"_id":"source/_posts/4-1-OpenGL/7.png","slug":"7.png","post":"clggl89ar0000y4obh6kl4xmf","modified":0,"renderable":0},{"_id":"source/_posts/4-1-OpenGL/9.jpg","slug":"9.jpg","post":"clggl89ar0000y4obh6kl4xmf","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/9.jpg","slug":"9.jpg","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/10.jpg","slug":"10.jpg","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/8.png","slug":"8.png","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/11.jpg","slug":"11.jpg","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/12.jpg","slug":"12.jpg","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/14.webp","slug":"14.webp","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/13.jpg","slug":"13.jpg","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/20.jpg","slug":"20.jpg","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/16.jpg","slug":"16.jpg","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/19.jpg","slug":"19.jpg","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/18.webp","slug":"18.webp","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-2-OpenGL ES/17坐标系.png","slug":"17坐标系.png","post":"clggl89av0001y4ob4jhh8njg","modified":0,"renderable":0},{"_id":"source/_posts/4-5-FBO/25.png","slug":"25.png","post":"clggljftg0002hoobbllv4ldm","modified":0,"renderable":0},{"_id":"source/_posts/4-6-VBO与VAO/22.png","slug":"22.png","post":"clggljnif0006hoob6539dart","modified":0,"renderable":0},{"_id":"source/_posts/4-6-VBO与VAO/24.png","slug":"24.png","post":"clggljnif0006hoob6539dart","modified":0,"renderable":0},{"_id":"source/_posts/4-6-VBO与VAO/23.jpg","slug":"23.jpg","post":"clggljnif0006hoob6539dart","modified":0,"renderable":0},{"_id":"source/_posts/4-7-GLSL着色器语言/21.webp","slug":"21.webp","post":"clggljw630007hoobbo9uenee","modified":0,"renderable":0}],"PostCategory":[{"post_id":"clgbv7k4o00018cob88lof603","category_id":"clgbv7k4s00038cobeihkgvvw","_id":"clgbv7k4w00098cobhk31glwc"},{"post_id":"clgbycqco0001s8obco3m00nq","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clgbycqct0003s8obaok2cuwd"},{"post_id":"clgbz5hpe0000s8ob1fr65els","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clgbz5hpi0001s8ob2dae83di"},{"post_id":"clgelnnse0002rgob33xj3z9r","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clgelnnse0003rgobcwd161ag"},{"post_id":"clgeng1v90000vwobec6993p8","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clgeng1vc0002vwob9f0m5p3l"},{"post_id":"clggksiep0007n0obbpfcealk","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clggksier0009n0ob8hgigraq"},{"post_id":"clggl89ar0000y4obh6kl4xmf","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clggl89az0005y4obd2ap1e6b"},{"post_id":"clggl89av0001y4ob4jhh8njg","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clggla66q0002p8ob6zjlgqbs"},{"post_id":"clggljftg0002hoobbllv4ldm","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clggljfti0005hoobaprb9nj3"},{"post_id":"clgglizt30000hoobe91vdfjh","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clggln2fk000bhoobdzdrfbmy"},{"post_id":"clgglj63u0001hoobbl2j93xk","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clgglqftv000228ob9t5k0wjj"},{"post_id":"clggljnif0006hoob6539dart","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clggltcj40002ugob1ov480vs"},{"post_id":"clggljw630007hoobbo9uenee","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clgglyzkj000260ob213g9gj0"},{"post_id":"clgglk1jk0008hoob1vpaeq3r","category_id":"clgbycqcr0002s8ob1ym92rhv","_id":"clggm1bco000560obchn79y69"}],"PostTag":[{"post_id":"clgbv7k4o00018cob88lof603","tag_id":"clgbv7k4u00048cobd5kgce2l","_id":"clgbv7k4w00088cob32qgehla"},{"post_id":"clgelnnse0002rgob33xj3z9r","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clgem4vub0005rgob6ytt9z3q"},{"post_id":"clgeng1v90000vwobec6993p8","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clgeng1vc0001vwob10971og9"},{"post_id":"clggksiep0007n0obbpfcealk","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clggksier0008n0obefpcby6a"},{"post_id":"clggl89ar0000y4obh6kl4xmf","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clggl89ax0002y4ob1y6sag6b"},{"post_id":"clggl89ar0000y4obh6kl4xmf","tag_id":"clggkqo5z0000n0ob87x06zoy","_id":"clggl89ay0004y4obgmj25djw"},{"post_id":"clggl89av0001y4ob4jhh8njg","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clggla66q0000p8ob41szftb6"},{"post_id":"clggl89av0001y4ob4jhh8njg","tag_id":"clggkqo5z0000n0ob87x06zoy","_id":"clggla66q0001p8obds0ide59"},{"post_id":"clggljftg0002hoobbllv4ldm","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clggljfti0003hooba5z2dk8i"},{"post_id":"clggljftg0002hoobbllv4ldm","tag_id":"clggkqo5z0000n0ob87x06zoy","_id":"clggljfti0004hoob4gl7eiyp"},{"post_id":"clgglizt30000hoobe91vdfjh","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clggln2fk0009hoob4lst2e44"},{"post_id":"clgglizt30000hoobe91vdfjh","tag_id":"clggkqo5z0000n0ob87x06zoy","_id":"clggln2fk000ahoob7vk6b7ds"},{"post_id":"clgglj63u0001hoobbl2j93xk","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clgglqftv000028obhgla6fcu"},{"post_id":"clgglj63u0001hoobbl2j93xk","tag_id":"clggkqo5z0000n0ob87x06zoy","_id":"clgglqftv000128ob80m4dp6e"},{"post_id":"clggljnif0006hoob6539dart","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clggltcj30000ugob42a8bh6s"},{"post_id":"clggljnif0006hoob6539dart","tag_id":"clggkqo5z0000n0ob87x06zoy","_id":"clggltcj40001ugobbxue3nov"},{"post_id":"clggljw630007hoobbo9uenee","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clgglyzki000060obh8hdaxr7"},{"post_id":"clggljw630007hoobbo9uenee","tag_id":"clggkqo5z0000n0ob87x06zoy","_id":"clgglyzkj000160ob5t5v23fr"},{"post_id":"clgglk1jk0008hoob1vpaeq3r","tag_id":"clgem4vua0004rgob32sbbs7t","_id":"clggm1bco000360ob1rj76uot"},{"post_id":"clgglk1jk0008hoob1vpaeq3r","tag_id":"clggkqo5z0000n0ob87x06zoy","_id":"clggm1bco000460ob0bxzf6dy"}],"Tag":[{"name":"读书","_id":"clgbv7k4u00048cobd5kgce2l"},{"name":"嵌入式","_id":"clgem4vua0004rgob32sbbs7t"},{"name":"嵌入式 OpenGL","_id":"clggkmiib00012oobhstm9hfa"},{"name":"嵌入式，OpenGL","_id":"clggkokw8000024ob00942tf1"},{"name":"嵌入式OpenGL","_id":"clggkomap000224ob6m6o2apk"},{"name":"嵌入式;OpenGL","_id":"clggkp83t00005cob4g9zhp12"},{"name":"OpenGL","_id":"clggkqo5z0000n0ob87x06zoy"}]}}