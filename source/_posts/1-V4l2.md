---
title: Video for Linux two(简称v4l2)
date: 2023-4-13 11:56:11
categories: 笔记
tags: 嵌入式
comments: false
description: 
typora-root-url: 1-V4l2
---

<div align = "center">Video for Linux two(简称v4l2)</div>


# 一、概述

 vl42是video for Linux 2的缩写，是一套Linux内核视频设备的驱动框架，该驱动框架为应用层提供一套统一的操作接口(一系列的ioctl)。包括一套数据结构和底层V4L2驱动接口。只能在Linux下使用。

<!--more-->

V4L2在设计时，是要支持很多广泛的设备的，它们之中只有一部分在本质上是真正的视频设备，可以支持多种设备,它可以有以下几种接口

video capture interface：视频采集接口，这种接口应用于摄像头，v4l2在最初设计的时候就是应用于这种功能

video output interface：视频输出接口，将静止图像或图像序列编码为模拟视频信号，通过此接口，应用程序可以控制编码过程并将图像从用户空间移动到驱动程序

video overlay interface：视频直接传输接口，可以将采集到的视频数据直接传输到显示设备，不需要cpu参与，这种方式的显示图像的效率比其他方式高得多

其他接口这里就不介绍了，下面来看一下v4l2的API


# 二、作用

它使程序有发现设备和操作设备的能力。它主要是用一系列的回调函数来实现这些功能。像设置摄像头的频率、帧频、视频压缩格式和图像参数等等。并使得它们的输出标准化。当然也可以用于其他多媒体的开发，如音频等。

# 三、存放位置

在Linux下，所有外设都被看成一种特殊的文件，成为“设备文件”，可以象访问普通文件一样对其进行读写。一般来说，采用V4L2驱动的摄像头设备文是/dev/v4l/video0。为了通用，可以建立一个到/dev/video0的链接。V4L2支持两种方式来采集图像：内存映射方式(mmap)和直接读取方式(read)。V4L2在include/linux/videodev.h文件中定义了一些重要的数据结构，在采集图像的过程中，就是通过对这些数据的操作来获得最终的图像数据。Linux系统V4L2的能力可在Linux内核编译阶段配置，默认情况下都有此开发接口。V4L2从Linux 2.5.x版本的内核中开始出现。结构体详细参数可以在/include/uapi/linux/videodev2.h中查看。

# 四、V4l2框架操作流程

```c
//1.打开视频设备文件
int fd = open("/dev/video0",O_RDWR);
//2.查询视频设备属性，如：是否具有视频输入或者音频输入输出等
ioctl(fd,VIDIOC_QUERYCAP,&cap);
//3.选择视频输入，一个视频设备可以有多个视频输入
//4.设置视频采集的参数:视频的制式，图像的采集窗口，帧格式，帧率，旋转方式
ioctl(fd,VIDIOC_S_FMT,&fmt);
//5.向驱动申请视频流数据的帧缓冲区，一般为4个。
ioctl(fd, VIDIOC_REQBUFS, &req);
//6.查询帧缓冲区在内核空间中的长度和偏移量 
ioctl(fd, VIDIOC_QUERYBUF, &buf);
//7.将申请到的帧缓冲映射到用户空间mmap，这样可以直接操作采集到的帧，不用复制
buffers[i].length = buf.length;
buffers[i].start = mmap(NULL, buffers[i].length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffers[i].offset);;
//8.将申请到的帧缓冲全部放入视频采集输出队列，以便存放采集的数据
ioctl (fd, VIDIOC_QBUF, &buf);
//9.开始视频采集
ioctl (fd, VIDIOC_STREAMON, &type);
//10.出列以取得已采集数据的帧缓冲，取得原始数据
ioctl (fd, VIDIOC_DQBUF, &buf);
//此时应用程序处理该帧缓冲区的数据，如：进行数据的处理和保存，
fp = fopen(picture.yuv,"w");//保存图片"w"，保存视频"a"追加写
fwrite(addr,1,length,fp);
fclose(fp);
//11.处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集
ioctl (fd, VIDIOC_QBUF, &buf);
//12.停止视频的采集
ioctl (fd, VIDIOC_STREAMOFF, &type);
//13.释放申请的视频帧缓冲区
unmap;
//14.关闭视频设备文件
close(fd);
```



# 五、V4l2的常用IOCTL接口命令-->>结构体介绍

## 1、常用的IOCTL接口命令

在内核目录include/linux/videodev2.h中定义

```c
VIDIOC_QUERYCAP        //查询驱动功能 
VIDIOC_QUERYSTD     //检查当前视频设备支持的标准，例如PAL或NTSC。
VIDIOC_S_INPUT
VIDIOC_ENUMINPUT	//枚举所有可用的输入
VIDIOC_S_PARM
VIDIOC_ENUM_FMT        //获取当前驱动支持的视频格式 
VIDIOC_S_FMT        //设置当前驱动的频捕获格式 
VIDIOC_G_FMT        //读取当前驱动的频捕获格式 
VIDIOC_TRY_FMT        //验证当前驱动的显示格式 
VIDIOC_CROPCAP        //查询驱动的修剪能力 
VIDIOC_S_CROP        //设置视频信号的矩形边框 
VIDIOC_G_CROP        //读取视频信号的矩形边框
VIDIOC_REQBUFS		 //分配内存 
VIDIOC_QUERYBUF //把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址
VIDIOC_QBUF        //把数据从缓存中读取出来 
VIDIOC_DQBUF        //把数据放回缓存队列 
VIDIOC_STREAMON        //开始视频显示函数 
VIDIOC_STREAMOFF        //结束视频显示函数 
VIDIOC_EXPBUF        //
```

## 2、常用的结构体

在内核目录include/linux/videodev2.h中定义。参见/include/uapi/linux/videodev2.h

```c
struct v4l2_capability        //视频设备的功能，对应命令VIDIOC_QUERYCAP 
struct v4l2_std_id        //视频制式
struct v4l2_input        //视频输入信息，对应命令VIDIOC_ENUMINPUT
struct v4l2_streamparm //结构体v4l2_streamparm来描述视频流的属性
struct v4l2_standard        //视频的制式，比如PAL，NTSC，对应命令VIDIOC_ENUMSTD 
struct v4l2_format        //帧的格式，对应命令VIDIOC_G_FMT、VIDIOC_S_FMT等
struct v4l2_crop        //视频信号矩形边框
struct v4l2_requestbuffers        //申请帧缓冲，对应命令VIDIOC_REQBUFS
struct v4l2_buffer        //驱动中的一帧图像缓存，对应命令VIDIOC_QUERYBUF
struct v4l2_exportbuffer //导出fd
```

### 1、v4l2_capability

```c
struct v4l2_capability
{
	u8 driver[16]; // 驱动名字
	u8 card[32]; // 设备名字
	u8 bus_info[32]; // 设备在系统中的位置
	u32 version; // 驱动版本号
	u32 capabilities; // 设备支持的操作
	u32 reserved[4]; // 保留字段
};
```

其中域 capabilities 代表设备支持的操作模式，常见的值有 V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING 表示是一个视频捕捉设备并且具有数据流控制模式；另外 driver 域需要和 struct video_device 中的 name 匹配。

### 2、v4l2_input

```c
struct v4l2_input {
	__u32	     index;		/*  Which input */
	__u8	     name[32];		/*  Label */
	__u32	     type;		/*  Type of input */
	__u32	     audioset;		/*  Associated audios (bitfield) */
	__u32        tuner;             /*  Associated tuner */
	v4l2_std_id  std;
	__u32	     status;
	__u32	     reserved[4];
};
```

视频捕获的应用首先要通过VIDIOC_ENUMINPUT命令来枚举所有可用的输入。在V4L2层，这个调用会转换成调用一个驱动中对应的回调函数：
 int (*vidioc_enum_input)(struct file *file, void *private_data,  struct v4l2_input *input);

### 3、v4l2_format

```c
struct v4l2_format { 
    enum v4l2_buf_type type; 
    union { 
        struct v4l2_pix_format         pix;     /* V4L2_BUF_TYPE_VIDEO_CAPTURE */ 
        struct v4l2_window             win;     /* V4L2_BUF_TYPE_VIDEO_OVERLAY */ 
        struct v4l2_vbi_format         vbi;     /* V4L2_BUF_TYPE_VBI_CAPTURE */ 
        struct v4l2_sliced_vbi_format  sliced;  /* V4L2_BUF_TYPE_SLICED_VBI_CAPTURE */ 
        __u8   raw_data[200];                   /* user-defined */ 
    } fmt; 
}; 
 
enum v4l2_buf_type { 
    V4L2_BUF_TYPE_VIDEO_CAPTURE        = 1, //视频捕获模式
    V4L2_BUF_TYPE_VIDEO_OUTPUT         = 2, 
    V4L2_BUF_TYPE_VIDEO_OVERLAY        = 3, 
    ... 
    V4L2_BUF_TYPE_PRIVATE              = 0x80, 
}; 
   
struct v4l2_pix_format { 
    __u32                   width; //视频的宽
    __u32                   height; //视频的高
    __u32                   pixelformat; //视频数据格式
    enum v4l2_field         field; 
    __u32                   bytesperline;   /* for padding, zero if unused */ 
    __u32                   sizeimage; 
    enum v4l2_colorspace    colorspace; 
    __u32                   priv;           /* private data, depends on pixelformat */ 
};
```

常见的捕获模式为 V4L2_BUF_TYPE_VIDEO_CAPTURE 即视频捕捉模式，在此模式下 fmt 联合体采用域 v4l2_pix_format：其中 width 为视频的宽、height 为视频的高、pixelformat 为视频数据格式（常见的值有 V4L2_PIX_FMT_YUV422P | V4L2_PIX_FMT_RGB565）、bytesperline 为一行图像占用的字节数、sizeimage 则为图像占用的总字节数、colorspace 指定设备的颜色空间。

### 4、v4l2_requestbuffers

```c
struct v4l2_requestbuffers {
    __u32                   count;
    enum v4l2_buf_type      type;
    enum v4l2_memory        memory;
    __u32                   reserved[2];
};
enum v4l2_memory {
    V4L2_MEMORY_MMAP             = 1,
    V4L2_MEMORY_USERPTR          = 2,
    V4L2_MEMORY_OVERLAY          = 3,
};
```

VIDIOC_REQBUFS 命令通过结构 v4l2_requestbuffers 请求驱动申请一片连续的内存用于缓存视频信息;count 指定根据图像占用空间大小申请的缓存区个数，type 为视频捕获模式，memory 为内存区的使用方式.

### 5、v4l2_buffer

```c
struct v4l2_buffer {
    __u32   index;	//buffer 序号 
    enum v4l2_buf_type    type;	//buffer 类型 
    __u32    bytesused;	//缓存已使用空间大小，buffer 中已使用的字节数
    __u32    flags;	//区分是MMAP 还是USERPTR
    enum v4l2_field  field;
    struct timeval    timestamp;	//获取第一个字节时的系统时间 
    struct v4l2_timecode   timecode;
    __u32     sequence;	//队列中的序号
  
    /* memory location */
    enum v4l2_memory    memory;	//缓存使用方式
    union {
            __u32   offset;//当前缓存与内存区起始地址的偏移，缓冲帧地址，只对MMAP 有效  
            unsigned long   userptr;
            struct v4l2_plane *planes;
    } m;
    __u32    length;	//缓冲帧长度
    __u32    input;
    __u32    reserved;	//一般用于传递物理地址值
};

struct v4l2_plane {
	__u32			bytesused;
	__u32			length;
	union {
		__u32		mem_offset;//offset是放在m.mem_offset中返回用户空间的
		unsigned long	userptr;
		__s32		fd;
	} m;
	__u32			data_offset;
	__u32			reserved[11];
};
```

flags 为缓存当前状态（常见值有 V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_QUEUED | V4L2_BUF_FLAG_DONE，分别代表当前缓存已经映射、缓存可以采集数据、缓存可以提取数据）

另外 VIDIOC_QUERYBUF，VIDIOC_QBUF 和 VIDIOC_DQBUF 命令都采用结构 v4l2_buffer 与驱动通信：VIDIOC_QBUF 命令向驱动传递应用程序已经处理完的缓存，即将缓存加入空闲可捕获视频的队列，传递的主要参数为 index；VIDIOC_DQBUF 命令向驱动获取已经存放有视频数据的缓存，v4l2_buffer 的各个域几乎都会被更新，但主要的参数也是 index，应用程序会根据 index 确定可用数据的起始地址和范围。

### 6、v4l2_captureparm

设置Stream参数。(主要是采集帧数)

```c
struct v4l2_streamparm parms;
parms.parm.capture.timeperframe.numerator=1;
parms.parm.capture.timeperframe.denominator=60;
rel = ioctl(fdUsbCam,VIDIOC_S_PARM, setfps);
```

对于捕获设备而言，parm.capture字段是要关注的内容，这个结构体如下：

```c
struct v4l2_captureparm
    {
       __u32             capability;
       __u32             capturemode;
       structv4l2_fract  timeperframe;
       __u32             extendedmode;
       __u32          readbuffers;
       __u32             reserved[4];
   }; 
timeperframe字段用于指定想要使用的帧频率，它又是一个结构体：
    struct v4l2_fract{
       __u32  numerator;
       __u32  denominator;
    };
```

numerator和denominator所描述的系数给出的是成功的帧之间的时间间隔。numerator 分子， denominator 分母。主要表达每次帧之间时间间隔。 numerator/ denominator秒一帧。

### 7、v4l2_exportbuffer

```c
struct v4l2_exportbuffer {
	__u32		type; /* enum v4l2_buf_type */
	__u32		index;
	__u32		plane;
	__u32		flags;
	__s32		fd;
	__u32		reserved[11];
};
```



# 六、应用程序代码分析

## 1、保存图像picture.yuv

见code中，camera_app_pic.c

```c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <linux/videodev2.h>
#include <sys/ioctl.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/time.h>
#include <unistd.h>
#include <string.h>

typedef struct VideoBuffer {
	void   *start;//帧缓存mmap映射后的首地址
	size_t  length;//缓存大小
} VideoBuffer;
VideoBuffer *buffers;//用来存放映射后的帧缓存区地址

int camera_device_open(void)
{
	int fd;
	//用阻塞模式打开摄像头设备
	fd = open("/dev/video0",O_RDWR,0);//设备节点
	if(fd < 0){
		perror("open /dev/video0 is fail.\n");
		exit(EXIT_FAILURE);
	}
	return fd;
}

int init_camera_attribute(int fd)
{
	int numBufs;//
	v4l2_std_id id;
	struct v4l2_format fmt;
	struct v4l2_requestbuffers  req;
	struct v4l2_buffer    buf;

	//检查当前视频设备支持的标准
	ioctl(fd,VIDIOC_QUERYSTD,&id);
	
	//设置视频捕获格式
	memset(&fmt,0,sizeof(fmt));
	fmt.type  = V4L2_BUF_TYPE_VIDEO_CAPTURE;//视频捕获模式
	fmt.fmt.pix.width = 640;//视频的宽
	fmt.fmt.pix.height = 480;//视频的高
	fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;//视频数据格式YUYV
//	fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YVU420;
	fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;

	if(ioctl(fd,VIDIOC_S_FMT,&fmt) == -1){
		perror("set VIDIOC_S_FMT is fail");
		exit(EXIT_FAILURE);
	}
	
	//分配内存，申请帧缓存，
	memset(&req,0,sizeof(req));
	req.count = 4;//帧缓存的个数，一般不大于5
	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	req.memory = V4L2_MEMORY_MMAP;//内存区的使用方式，mmap映射
	
	if(ioctl(fd,VIDIOC_REQBUFS,&req) == -1){
		perror("set VIDIOC_REQBUFS is fail");
		exit(EXIT_FAILURE);
	}

	//获取并记录缓存的物理空间
	buffers = calloc(req.count,sizeof(*buffers));
	for(numBufs = 0; numBufs < req.count; numBufs ++){
		memset(&buf,0,sizeof(buf));
		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
		buf.memory = V4L2_MEMORY_MMAP;
		buf.index = numBufs;//缓存编号，4帧缓存

		//读取缓存，查询帧缓冲区在内核空间中的长度和偏移量
		if(ioctl(fd,VIDIOC_QUERYBUF,&buf) == -1){
			perror("set VIDIOC_REQBUFS is fail");
			exit(EXIT_FAILURE);
		}
		 // 转换成相对地址，将申请到的帧缓冲映射到用户空间mmap
		buffers[numBufs].length = buf.length;
		buffers[numBufs].start  = mmap(NULL,buf.length,PROT_READ|PROT_WRITE,
				MAP_SHARED,fd,buf.m.offset);
		if(buffers[numBufs].start == MAP_FAILED){
			perror("mmap is fail");
			exit(EXIT_FAILURE);	
		}

		// 放入缓存队列
		if(ioctl(fd,VIDIOC_QBUF,&buf) == -1){
			perror("set VIDIOC_QBUF is fail");
			exit(EXIT_FAILURE);
		}
	}
	
	return 0;
}

int start_capturing(int fd)
{
	enum v4l2_buf_type type;

	//开始采集数据
	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	if(ioctl(fd,VIDIOC_STREAMON,&type) == -1){
		perror("start capturing is fail");
		exit(EXIT_FAILURE);
	}

	return 0;
}
//保存图片
int build_picture(void *addr,int length)
{
	FILE *fp;
	static int num=0;
	char picture_name[20];
	sprintf(picture_name,"picture%d.yuv",num++);
	
	fp = fopen(picture_name,"w");
	if(fp == NULL){
		perror("fail to open ");
		exit(EXIT_FAILURE);
	}

	fwrite(addr,1,length,fp);

	fclose(fp);

	return 0;
}

int read_image(int fd)
{
	struct v4l2_buffer buf;
	memset(&buf,0,sizeof(buf));
	buf.type=V4L2_BUF_TYPE_VIDEO_CAPTURE;
	buf.memory=V4L2_MEMORY_MMAP;
	buf.index=0;

	//读取缓存，出列以取得已采集数据的帧缓冲，取得原始数据
	if(ioctl(fd,VIDIOC_DQBUF,&buf) == -1){
		perror("set VIDIOC_DQBUF is fail");
		exit(EXIT_FAILURE);
	}

	//将数据存为图片
	build_picture(buffers[buf.index].start,buffers[buf.index].length);

	//重新放入缓存队列，处理完后，将该帧缓冲区重新入列,这样便可以循环采集数据，直到停止采集
	if(ioctl(fd,VIDIOC_QBUF,&buf) == -1){
		perror("reset VIDIOC_QBUF is fail");
		exit(EXIT_FAILURE);
	}

	return 0;

}

int when_to_read(int fd)
{
	int i=0;
	for(i=0;i<3;i++)//保存三张图片
	{
		fd_set rfds;//指定内核监测的文件描述符集合
		struct timeval tv;//设置超时时间
		int retval;

		FD_ZERO(&rfds);//清空集合
		FD_SET(fd, &rfds);//将fd添加到集合中

		tv.tv_sec = 2;
		tv.tv_usec = 0;
		//当有数据采集好在缓冲区准备好时，开始读取缓存数据
		retval = select(fd+1, &rfds, NULL, NULL, &tv);
		if(retval == -1){
			 perror("select()");
			 exit(EXIT_FAILURE);
		}else if(retval == 0){
			printf("select is timeout\n");
		}else{
			read_image(fd);
		}
	}

	return 0;
}

int stop_capturing(int fd)
{
	enum v4l2_buf_type type;

	//停止采集数据
	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
	if(ioctl(fd,VIDIOC_STREAMOFF,&type) == -1){
		perror("stop capturing is fail");
		exit(EXIT_FAILURE);
	}

	return 0;
}

int uninit_camera(int fd)
{
	int i;
	//释放申请的视频帧缓冲区
	for(i=0;i<4;i++){
		if(-1 == munmap(buffers[i].start,buffers[i].length))
		{
			perror("munmap is fail");
			exit(EXIT_FAILURE);
		}
	}
	free(buffers);
	//关闭视频设备文件
	close(fd);
	return 0;
}
int main(int argc, const char *argv[])
{
	int fd;
	fd = camera_device_open();	
	
	init_camera_attribute(fd);
	
	start_capturing(fd);
	
	when_to_read(fd);

	stop_capturing(fd);
	
	uninit_camera(fd);

	return 0;
}

```



## 2、保存视频video.yuv

见code中，camera_app_mp4.c

主要区别：fp = fopen(video_name,"a")，追加写的方式打开，进行采集

# 七、V4l2驱动框架

## 1、主要对象

### 1、video_device

```c
struct video_device
		{
			const struct v4l2_file_operations *fops; 
			//操作方法结构体
			struct cdev *cdev;	（file_opreations）	
			//字符设备驱动
			struct v4l2_device *v4l2_dev;	/* v4l2_device parent */
			char name[32]; 
			//驱动的名字
			int minor;
			//次设备号
			void (*release)(struct video_device *vdev);
			//释放资源的函数
			const struct v4l2_ioctl_ops *ioctl_ops;
			//ioctl的操作方法
		};
```

  一个字符设备，为用户空间提供设备节点(/dev/videox)，提供系统调用的相关操作(open、ioctl…) 

可以看到video_device中含有一个cdev还有v4l2_device，此外还有fops和ioctl_ops，从应用层进行系统调用会经过v4l2的核心层回调到这里 

#### v4l2_file_operations

```c
struct v4l2_file_operations {
	struct module *owner;
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	unsigned int (*poll) (struct file *, struct poll_table_struct *);
	long (*ioctl) (struct file *, unsigned int, unsigned long);
	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
	unsigned long (*get_unmapped_area) (struct file *, unsigned long,
				unsigned long, unsigned long, unsigned long);
	int (*mmap) (struct file *, struct vm_area_struct *);
	int (*open) (struct file *);
	int (*release) (struct file *);
};

```

#### v4l2_ioctl_ops

```c
struct v4l2_ioctl_ops {
	int (*vidioc_querycap)(struct file *file, void *fh, struct v4l2_capability *cap);
	/* Buffer handlers */
	int (*vidioc_reqbufs) (struct file *file, void *fh, struct v4l2_requestbuffers *b);
	int (*vidioc_querybuf)(struct file *file, void *fh, struct v4l2_buffer *b);
	int (*vidioc_qbuf)    (struct file *file, void *fh, struct v4l2_buffer *b);
	int (*vidioc_dqbuf)   (struct file *file, void *fh, struct v4l2_buffer *b);
    /* Stream on/off */
	int (*vidioc_streamon) (struct file *file, void *fh, enum v4l2_buf_type i);
	int (*vidioc_streamoff)(struct file *file, void *fh, enum v4l2_buf_type i);
   	...
};
```

 v4l2有很多ioctl操作，具体实现都在这里 

### 2、v4l2_device

```c
struct v4l2_device {
	/* used to keep track of the registered subdevs */
	struct list_head subdevs;
    ...
};
```

  嵌入到video_device中，表示一个v4l2设备的实例 

可以看到v4l2_device中有一个v4l2_subdev的链表，v4l2_device的主要目的时用来管理v4l2_subdev 

### 3、v4l2_subdev

```c
struct v4l2_subdev {
	struct list_head list;
	struct v4l2_device *v4l2_dev;
	const struct v4l2_subdev_ops *ops;
};
```

 依附在v4l2_device之下，并表示一个v4l2设备的子设备，一个v4l2_devide下可以有多个sub_device 

 v4l2_subdev中有一个v4l2_subdev_ops，实现了一系列的操作，供v4l2_device调用 

 **subdev的设计目的是为了多路复用，就是用一个v4l2_device可以服务多个v4l2_subdev** 

### 4、V4l2提供的注册接口

```c
int video_register_device(struct video_device *vdev, int type, int nr);//video_device注册
void video_unregister_device(struct video_device *vdev);//video_device注销
int v4l2_device_register(struct device *dev, struct v4l2_device *v4l2_dev);//v4l2_device注册
void v4l2_device_unregister(struct v4l2_device *v4l2_dev);//v4l2_device注销
int v4l2_device_register_subdev(struct v4l2_device *v4l2_dev,struct v4l2_subdev *sd);//v4l2_subdev注册
void v4l2_device_unregister_subdev(struct v4l2_subdev *sd);//v4l2_subdev注销

```



## 2、图示

<img src="1.png"  />

<img src="2.png"  />

<img src="3.png" style="zoom:80%;" />

## 3、主要框架

```c
#include <...>

static struct video_device* video_dev;
static struct v4l2_device v4l2_dev;

/* 实现各种系统调用 */
static const struct v4l2_file_operations video_dev_fops = {
	.owner		    = THIS_MODULE,
	.release        = vdev_close,
	.read           = vdev_read,
	.poll		    = vdev_poll,
	.ioctl          = video_ioctl2,
	.mmap           = vdev_mmap,
};

/* 实现各种系统调用 */
static const struct v4l2_ioctl_ops video_dev_ioctl_ops = {
	.vidioc_querycap      = vidioc_querycap,
	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
	.vidioc_reqbufs       = vidioc_reqbufs,
	.vidioc_querybuf      = vidioc_querybuf,
	.vidioc_qbuf          = vidioc_qbuf,
	.vidioc_dqbuf         = vidioc_dqbuf,
	.vidioc_enum_input    = vidioc_enum_input,
	.vidioc_g_input       = vidioc_g_input,
	.vidioc_s_input       = vidioc_s_input,
	.vidioc_streamon      = vidioc_streamon,
	.vidioc_streamoff     = vidioc_streamoff,
};

static int __init video_init(void)
{
    /* 分配并设置一个video_device */
    video_dev = video_device_alloc();
    video_dev->fops = &video_dev_fops;
    video_dev->ioctl_ops = &video_dev_ioctl_ops;
    video_dev->release = video_device_release;
    video_dev->tvnorms = V4L2_STD_525_60;
    video_dev->current_norm = V4L2_STD_NTSC_M;

    /* 注册一个v4l2_device */
    v4l2_device_register(video_dev->dev, &v4l2_dev);    
    video_dev->v4l2_dev = &video_dev;

    /* 注册一个video_device字符设备 */
    video_register_device(video_dev, VFL_TYPE_GRABBER, -1);

    return 0;
}

static void __exit video_exit(void)
{
    //注销
    video_unregister_device(video_dev);
    v4l2_device_unregister(&v4l2_dev);
    video_device_release(video_dev);
}

module_init(video_init);
module_exit(video_exit);
MODULE_LICENSE("GPL")
```

# 八、多路video输入分析

## 1、多路操作流程

```c
//1.设备初始化
_Init(){
    _open()｛
        fd[i] = open(dev_name[i], O_RDWR /* required */  | O_NONBLOCK, 0);
    ioctl(fd[i], VIDIOC_S_INPUT, &inp);//设置输入
    ioctl(fd[i], VIDIOC_S_PARM, &parms);//主要用来设置采集帧数
        ｝;//打开设备节点
    _Fmtset()｛
        ioctl(fd[i], VIDIOC_S_FMT, &fmt);//设置
        ioctl(fd[i], VIDIOC_G_FMT, &fmt);//查询，判断设置是否成功
        ｝;//设置视频捕获模式
    _BuffReq()｛
        ioctl(fd[i], VIDIOC_REQBUFS, &req);
        ioctl(fd[i], VIDIOC_QUERYBUF, &buf);
        ioctl(fd[i], VIDIOC_QBUF, &buf);
        ｝;//申请帧缓存，查询缓存转换地址，放入队列
    _ON{
        ioctl(fd[i], VIDIOC_STREAMON, &type);
    };//开启视频捕获
}
//2.创建多线程
pthread_create(&capture_pth, NULL,Video_Capture, NULL);
//3.采集数据
Video_Capture(){
    //用select监视文件描述符，等待采集，如果有准备好的
    select(fd[3] + 1, &fdr, NULL, NULL, &tv);//IO多路复用
    //当准备好时，采用互斥锁的方式，唤醒休眠的数据处理函数
    if( FD_ISSET(fd[0],&fdr) && FD_ISSET(fd[1],&fdr) && \
		FD_ISSET(fd[2],&fdr) && FD_ISSET(fd[3],&fdr))
		{
            _Queryaddr(){
                ioctl(fd[i], VIDIOC_DQBUF, &buf);//出列
                VideoPhyAddr[i] = buf.m.planes[0].m.mem_offset;
                ioctl(fd[i], VIDIOC_QBUF, &buf);//入列
            };
            pthread_mutex_lock(&VideoMutex);//上锁
            pthread_cond_signal(&VideoCond);//唤醒休眠
            pthread_mutex_unlock(&VideoMutex);//解锁
        }
};
//4.数据处理
_LoadVideoData(){
    pthread_mutex_lock(&VideoMutex);//上锁
	pthread_cond_wait(&VideoCond, &VideoMutex);//休眠
	pthread_mutex_unlock(&VideoMutex);//解锁
    //************************
    //***原始视频流数据处理***
    //************************
};
```

