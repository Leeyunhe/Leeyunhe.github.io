---
title: C基础
date: 2023-5-12 18:04:11
categories: 笔记
tags: 计算机
comments: false
description: 
typora-root-url: 001C基础
---

# C基础之Linux操作系统

## 一，操作系统介绍

### 	什么是操作系统？

​		操作系统是一套**计算机管理控制系统**，用来管理计算机硬件资源。

### 	操作系统的作用：

- 管理与配置内存；

- 决定系统资源供需的优先次序；

- 操作网络；

- 管理文件系统；

- 控制输入输出设备；

  <!--more-->

### 	为什么要用Linux操作系统做开发：

- 1，广泛的硬件支持；
- 2，内核高效稳定；
- 3，源码开放，软件丰富；
- 4，优秀的开发工具；
- 5，完善的网络通信和文件管理机制；

## 二，Linux

### 	什么是虚拟机？

​		VM		<==>		手游模拟器

### 	什么是Ubuntu？

​		以桌面应用为主的Linux操作系统。内核是Linux，具有Ubuntu特色的可视化界面。
​		Linux		<==>		Windows

### 	Linux的发行版本：

​		Ubuntu，Redhat，Centos，Debian
​		这些Linux的发行版本		<==>		WindowsXP、Windows7/8/10/11

### 	Linux内核的五大功能：

​		**文件管理：把文件转成二进制代码存储起来
​		内存管理：内存分配
​		设备管理：摄像头、鼠标硬件驱动的管理
​		进程管理：一个程序可以有多个进程
​		网络管理：上网**

### 	Linux文件系统结构：

​		Windows：分区
​		Linux：倒插树形结构。**一切皆文件**。

#### 	系统启动必须的：

​		/boot：存放的启动Linux时使用的内核文件，包括连接文件以及镜像文件。
​		/etc：存放所有的系统需要的配置文件和子目录列表，更改目录下的文件可能会导致系统不能启动。
​		/lib：存放基本代码库（比如C++库），其作用类似于Windows里得到DLL文件。几乎所有的应用程序都需要用到这些共享库。
​		/sys：这是Linux2.6内核的一个很大的变化。该目录下安装了安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息 的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中

#### 	指令集合：

​		/bin：存放最常用的程序和指令
​		/sbin：只有系统管理员能使用的程序和指令

#### 	外部文件管理：

​		/dev：Device设备的缩写，存放的是Linux的外部设备。注意：在Linux中访问设备和访问文件的方式是相同的。
​		/media：类Windows的其他设备，例如U盘、光驱等等，识别后Linux会把设备放到这个目录下。
​		/mnt：临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。

#### 	临时文件：

​		/run：是一个临时文件系统，存储启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上又/var/run目录，应该让它指向run。
​		/lost+found：一般情况下为空的，系统非法关机后，这里就存放一些文件。
​		/tmp：这个目录是用来存放一些临时文件的。

#### 	账户：

​		/root：系统管理员的用户主目录。
​		/home：用户的主目录，以用户的账号命名的。
​		/usr：用户的很多应用程序和文件都放在这个目录下，类似于Windows下的program files目录。
​		/usr/bin：系统用户使用的应用程序与指令。
​		/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。
​		/usr/src：内核源代码默认的放置目录。
​		/var：存放经常修改的数据，比如程序运行的日志文件（/var/log目录下）。
​		/proc：管理内存空间！虚拟的目录，是系统内存的映射，我们可以直接访问这个目录来，获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件来做修改。

#### 扩展用的：

​		/opt：默认是空的，我们安装额外软件可以放在这个里面。
​		/srv：存放服务启动后需要提取的数据（不用服务器就是空的）。

## 三、Linux系统命令（shell命令）



## 四、vim编辑器



# C基础之基础十四条

## 	1，C语言代码解析

```c
#include <stdio.h>
#include "myhead.h"

int main(int argc, const char *argv[])
{
    printf("hello world\n");//打印hello world
    return 0;
}
/*c语言最基本的代码结构*/
```

​		#：预处理标识符
​		#include：从标准库中调用头文件。/usr/include/
​		<	>：直接从库中查找.h文件
​		"	"：先从给定的路径查找头文件，如果没有路径，默认现在.c文件所处的当前目录下查找.h文件，如果有，则引用该头文件，如果没有，再进入include库中查找
​		int：函数的返回值类型（返回值的数据类型）。int---数据类型，整数类型。
​		main：函数名。main的含义代表这个函数是主函数。一个程序只能有一个主函数，**主函数是程序的入口**。
​		()：函数的参数列表，里面宝看了函数所需要的形式参数。
​		{}：大括号里面包含函数的主体内容，关于这个函数所需要的所有代码，都要写在{}中。
​		printf("")：是C语言的打印函数，这个函数是包含在stdio.h头文件中的。
​		hello world：作为printf()函数的参数，打印在终端上。
​		\n：转义字符---换行
​		；：语句结束的标识符
​		//打印xxxxxx：单行注释	//以及该行其后的所有内容只用于提示程序员一些必要的信息，对代码没有任何影响
​		return：返回标识。函数中遇到return，那么这个函数就会结束运行，并且将一个值返回，**如果是main函数中的return，那么这个程序就会结束**。
​		0：函数的返回值
​		/*	*/：多行注释，写在这对符号中的所有文字，都会被注释掉（与代码没有任何关系）。

## 	2，GCC编译器

​		用来编译你写的代码。

### 		（1）一步编译

```c
/*格式：
    gcc file.c文件名 默认会生成一个a.out的可执行文件
	./a.out 运行可执行文件
    
    gcc file.c文件名 -o file 自定义可执行文件的名字为file
	./file		*/
```

### 		（2）分步编译	-ESc	.iso

#### 			1)预处理

```c
gcc -E 1.c -o 1.i 对.c文件执行预处理操作，处理后的内容存放在 .i 文件中
				 如果没有-o，默认将处理后的内容打印在终端上
/*预处理的作用：
1.执行#预处理标识符的语句，例如：引用头文件 和 宏定义替
换。
2.删除注释。*/
```

#### 			2）编译

```c
gcc -S 1.i -o 1.s 对文件进行编译操作，生成 .s （汇编）文件
/*编译的作用：
1.将C语言转化为汇编语言。
2.检查语法正确性。如果有错，会报错。*/
```

#### 			3）汇编

```c
gcc -c 1.s -o 1.o 对汇编文件进行汇编操作，生成 .o 二进制文件
/*汇编的作用：
将汇编语言转化为二进制的机器语言。*/
```

#### 			4）链接

```c
gcc 1.o 将二进制文件链接为可执行文件，默认生成的文件名为a.out
gcc 1.o -o 1
/*链接的作用：
将二进制文件链接为可执行文件
运行文件 ./a.out.*/
```

## 	3，进制

| 二进制   | 八进制 | 十进制 | 十六进制 |
| -------- | ------ | ------ | -------- |
| （ 0b ） | ( 0 )  | ( 0 )  | ( 0x )   |
| 0,1      | 0~7    | 0~9    | 0~9,a~f  |

### 二进制转十进制： 

​		二进制--------------十进制 
​			 	1----------------------1 
​				10---------------------2 
​		  	100--------------------4 
​		    1000-------------------1*2^3 
​	     101100------------------2^5 + 2^3 + 2^2=44 

### 八进制转十进制： 

​			0407---------------------4**8^2 + 7*8^0=263 

### 十进制转二进制：（短除法） 

​		十进制---------------二进制 
​			15-------------------1111 
​		    123---------------1111011 

## 	4，计算机单位转换

​	最小的存储单位：byte 字节(B) 
​	最小的单位 ： bit 比特(位) 
​			每一位上存的都是 0 1 二进制数 
​							1byte = 8bit 
​	1024B = 1KB 		2^10B 
​	1024KB = 1MB 	2^20B 
​	1024MB = 1GB 	2^30B 
​	1024GB = 1TB 	2^40B 
​	....

## 	5，C基本数据类型

### （1）整数类型 	整型 

| int       | 整型   | 4byte = 32bit                                                |
| --------- | ------ | ------------------------------------------------------------ |
| short int | 短整型 | 2byte = 16bit                                                |
| long int  | 长整型 | 4byte = 32bit(32位操作系统) <br/>8byte = 64bit(64位操作系统) |
| long long | 长整型 | 8byte = 64bit                                                |

### （2）小数类型	 浮点型 

| float  | 单精度浮点型 | 4byte = 32bit |
| ------ | ------------ | ------------- |
| dobule | 双精度浮点型 | 8byte = 64bit |

### （3）字符类型 	字符型 

​		**char 					1byte = 8bit**

## 	6，常量

​	常量的值**一旦确定，就不可以再改变了。**

### 	（1）整型常量

​		0 		1 		-5		 123456 		0b11010		 0xabcd

### 	（2）浮点型常量

​		1.1 		-0.5		 3.1415

### 	（3）字符常量 

​		'a'		 '!' 		'5' 

​		说明：字符型数据 其实是特殊的 整型数据。因为按照ASCII码表的解释，每一个字符都有一个唯 一的整数与之对应。

```c
ascii码（输入命令man ascii，打开ascii码表，按q退出）： 
	'0'~'9'：48~57 
	'A'~'Z'：65~90 
	'a'~'z'：97~122
```

### 	（4）字符串常量 

​		"abc" 		"?!~" 		"123"		 "a" 

​		**常量的声明(定义)方式：**
​		1）#define 宏定义 
​		2）const 关键字

## 	7，宏定义

​		用来声明一个常量，宏定义将来只完成一个简单的、毫无逻辑的替换操作。 
​		**补充**： = 赋值号 
​		 == 等于号 

### 	（1）无参宏定义

​		格式： 
​				#define 	宏名	 替换列表 
​		例： 
​				#define 	M 	5 	//后期不可以修改M的值

### 	（2）带参宏定义

​		格式： 
​				#define 宏名(参数1，参数2...) 替换列表

​		例： 

```c
#include <stdio.h>
#define SUM(a,b) a+b 
int main(int argc, const char *argv[]) 
{
 printf("%d\n",SUM(3,4)); //将红色部分替换为a+b，同时，a被替换为3，b 被替换为4。结果为 3 + 4 ， 打印 7 
 return 0;
}
```

​		当出现如下情况时：

```c
#include <stdio.h>
#define JI(a,b) a*b //红色部分写法会导致编译器产生歧义
int main(int argc, const char *argv[])
{ 
 printf("%d\n",JI(3+2,4)); //运行代码后，得到的结果是 11 。而我们期望的结果是 5*4=20 。出现这个问题的原因是 运算符优先级 导致的。所以我们需要给宏定义中替换列表的参数括上括号，形如：（a）*（b）。
 return 0;
}
```

 	注意：
		1）在使用带参宏定义时，为了避免因运算符优先级的不同而导致的一些歧义，我们通常会在替换列表中给每个参数都加 ( ) 。
		 2）宏名和(参数列表)之间不可以有空格。严格按照格式书写。

​	注意：
​		1）#define 必须写在行首 。
​		2）宏定义是预处理语句，所以我们要把它写在程序的最前面，一般会写在引用头文件之后。 
​		3）宏名默认要大写 。
​		4）宏名和替换列表之间不可以有 = 。 
​		5）如果宏定义的内容较长，一行写不下，换行时需要用 反斜杠 \ 作为延续符延续到下一行。

## 	8，变量

​		变量在赋予一个值后，仍然可以随时被修改。
​		变量在声明时，会从内存中划分一定的空间来存储数据。

### 	（1）声明变量

​		格式： 
​						存储类型 数据类型 变量名； 

​		存储类型： 
​						**auto 自动（默认）** 
​						extern 引用其他文件的变量 
​						static 静态变量 
​						volatile 去内存中获取变量 
​						register 寄存器变量 

​		例：	 int a; //声明了一个整型变量a。 a被分配了4byte的空间。 
​					char c; //声明了一个字符型变量c。 c被分配了1byte的空间。 
​					double d; //声明了一个双精度浮点型变量d。 d被分配了8byte的空间。 

### 	（2）标识符命名规则 

​			1）由 数字、字母、下划线_ 组成 
​			2）数字不可以做开头 
​			3）严格区分大小写
​			4）不能与关键字重名

### 	（3）常用的修饰数据类型的关键字

#### 			1）signed 

​				**（默认）**有符号，区分正负。 只能用来修饰 **整型** 和 **字符型** 
​						**正 0** 
​						**负 1** 
​					int a; <==> signed int a; //变量a一共有32位，其中**最高位为符号位**。 

#### 			2）unsigned --- %u

​					无符号，全部是非负数 只能用来修饰 **整型** 和 **字符型** 
​					unsigned int a; //变量a一共有32位，全部用来存数据。 

​				例： 

```c
#include <stdio.h> 
int main(int argc, const char *argv[]) 
{ 
 unsigned int a = 5; //unsigned不可以赋值为负数 
 printf("%u\n",a); //用%u打印无符号整型数 
 return 0; 
}
```

### 	（4）取值范围 

#### 			1）char 

​				unsigned char 		[ 0，(2^8)-1 ]		 => [ 0，255 ] 
​				char 						[ -(2^7)，(2^7)-1 ] => [ -128，127 ]

##### 					原码、反码、补码：

```c
转换规则：
		正数的反码 补码 是原码本身；
		负数的反码 是 原码符号位不动，其余位取反，
			 补码 是 反码+1；
	原码：+0：0000 0000
		 -0：1000 0000
	反码：+0：0000 0000
		 -0：1111 1111
	补码：+0：0000 0000
		 -0：1 0000 0000
（计算机中存的是数据的补码形式）
//规定：原码的1000 0000代表-128
```

​		计算题： 

```
（1）53 + 18 
    原码：0011 0101
        0001 0010
    反码：0011 0101
         0001 0010
    补码：0011 0101
		 0001 0010
		+ 0100 0111 //补码相加得到补码，这道题的补码是正数，所原码和补码相同， 71
（2）45 - 21
（3）34 - 66
    原码：0010 0010
    	 1100 0010
    反码：0010 0010
    	 1011 1101
    补码：0010 0010
   		 1011 1110
  		 + 1110 0000
    反码：1101 1111
    原码：1010 0000 --- -32
```

#### 			2）整型

| unsigned int       | [ 0 , (2^32)-1 ]       |
| ------------------ | ---------------------- |
| int                | [ -(2^31) , (2^31)-1]  |
|                    |                        |
| unsigned short int | [ 0 , (2^16)-1 ]       |
| short int          | [ -(2^15) , (2^15)-1]  |
|                    |                        |
| unsigned long long | [ 0 , (2^64)-1 ]       |
| long long          | [ -(2^63) , (2^63)-1 ] |

#### 			3）浮点型 

```c
float --- 一共32位
        首位 ----符号位				1
        2~9位 ----整数位			 8
        10~32位 ----精度位（小数位）   23
取值范围：
   		 [ -(2^8) , (2^8)-1 ]
精度：
  		  6~7位小数，6位绝对精确
```

```c
double --- 一共64位
        首位 ----符号位 				1 
        2~12位 ----整数位			11
        13~64位 ----精度位（小数位）   52
    取值范围：
        [ -(2^11) , (2^11)-1 ]
    精度：
   		 15~16位小数，15位绝对精确
```

### 	（5）变量的初始化及赋值

​			初始化： 
​						int a = 2; //在声明变量的同时赋值 
​			赋值： 
​						int a; 
​						a = 2; 	//声明变量之后赋值 

### 	（6）强制类型转换

​				显式的强转 
​				格式： 
​							**(数据类型名)表达式**

​		例：

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int a = 5;
 printf("%f\n",(float)a); //将int型变量a，强制类型转换为float型
 return 0;
}
```

​		隐式的强转 
​		例：

```c
float a = 5.9;
 int b; 
 b = a; //隐式的强制类型转换
```

### 	（7）格式符（占位符）

​		

| **%d**   | **以有符号的十进制格式输出 int char**                        |
| -------- | ------------------------------------------------------------ |
| **%ld**  | **以有符号的十进制格式输出 long int**                        |
| %nd      | 按n个宽度，以有符号的十进制格式输出 int char。右对齐，不足宽度的部分用空格补齐，如果数据宽度大于n，按照原样输出 |
| %-nd     | 按n个宽度，以有符号的十进制格式输出 int char。左对齐，不足宽度的部分用空格补齐，如果数据宽度大于n，按照原样输出 |
| %0nd     | 按n个宽度，以有符号的十进制格式输出 int char。右对齐，不足宽度的部分用 0 补齐，如果数据宽度大于n，按照原样输出 |
| **%u**   | **以无符号的十进制格式输出 int char**                        |
| **%f**   | **以单精度浮点型输出小数 float 默认输出6位小数**             |
| **%.mf** | **保留m位小数，遵循四舍五入**                                |
| %n.mf    | 以n个宽度打印，且保留m位小数。右对齐，不足宽度的部分用空格补齐，如果数据宽度大于n，按照原样输出。 |
| %-n.mf   | 以n个宽度打印，且保留m位小数。左对齐，不足宽度的部分用空格补齐，如果数据宽度大于n，按照原样输出。 |
| **%lf**  | **以双精度浮点型输出小数 double 默认输出6位小数**            |
| %o       | 以八进制格式输出 int                                         |
| %x       | 以十六进制格式输出 int                                       |
| %e       | 以指数形式输出double                                         |
| %g       | 输出有效字符 double                                          |
| %p       | 打印地址                                                     |
| %c       | 打印字符 char                                                |
| %s       | 打印字符串                                                   |

### 	（8）转义字符

| **\n** | **换行，把光标移动到下一行**         |
| ------ | ------------------------------------ |
| \r     | 回车，把光标移动到当前行的第一个位置 |
| **\t** | **水平制表符**                       |
| \v     | 垂直制表符                           |
| \b     | 退格                                 |

## 	9，基本的输入输出函数

### （1）字符的输入输出

​		单个字符

#### 		1）字符的输入函数 getchar( )

​		格式： 
​					getchar();
​				从键盘向计算机中输入字符。

#### 		2）字符的输出函数 putchar()

​		格式： 
​					putchar(单个字符); 

​		例： 

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 char a;
 a = getchar(); //从终端输入一个字符，保存在字符型变量a的空间中
 putchar(a); //打印变量a的内容
 putchar('\n'); //打印转义字符 换行
 return 0;
}
```

### （2）格式化输入输出

#### 		1）格式化输出函数 printf() 

​			格式： 
​					**printf("格式控制字符串"，输出表项)；** 

​					其中，格式控制字符串 是用来控制输出表项的输出格式的。

​			例：  

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 char a = 'a';
 printf("%d\n%c\n",a,a);
 printf("hello world"); 
 return 0;
}
1）格式控制字符串中有几个格式符，那么输出表项就需要几个量来一一对应，每个量之间用逗
号隔开
2）“格式控制字符串”可以没有任何格式符，此时也就不需要输出表项了。那么会原样打印" 
"中的内容
```

#### 		2）格式化输入函数

​			格式： 
​						**scanf("格式控制字符串"，输入项地址列表);**

​			例： 

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 double a;
 scanf("%lf",&a);
 printf("%lf\n",a);
 return 0;
}
//使用scanf时，一定要记得给要赋值的变量取地址 &
```

​		**scanf的格式控制字符串中**不要写除了格式符以外的任何内容。

​		**练习**：从终端获取一个整数和一个字符，然后打印。 

### （3）处理垃圾字符

​		在C语言中，当使用字符变量进行连续输入操作时，会出现本意是结束当前输入的‘ 回车’ 被 当作字符存到了后面的%c中，导致我们无法正确输入一个字符。这个情况我们叫“遇到了圾 字符”。 

​		例如上面的练习题： 

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int a;
 char c;
 printf("请输入一个整数：");
 scanf("%d",&a);
 printf("请输入一个字符：");
 scanf("%c",&c);
 printf("%d %c\n",a,c);
 return 0;
}
```

#### 1）getchar函数 

```c
scanf("%d",&a); 
getchar(); //在输入流中，把垃圾字符'回车'吸收掉
scanf("%c",&c); 
```

#### 2）空格 

```c
scanf("%d %c",&a,&c); //在%c格式符前加一个空格 
//弊端：要求输入时必须输入 空格 ，降低了灵活性 
```

#### 3）\n 

```c
 scanf("%d\n%c",&a,&c); //在%c格式符前加一个'\n' 
//弊端：要求输入时必须输入 回车 ，降低了灵活性
```

#### 4）%*c 

```c
scanf("%d%*c%c",&a,&c); //%*c可以把整数后的一个任何输入都吸收掉，无论是空格还是回车
```

## 	10，运算符

​		运算符是一种告诉编译器执行特定的数学或逻辑操作的符号

### （1）算术运算符

```c
+ 	- 	* 	/ 	% 	++ 	--
    
a = 20 b = 30
    
/ 整除号(取整) 左右两边都是整数的时候才是整除，有一方为小数，结果就是小数（浮点型）
		例：5/2 结果是 2
			 5/2.0 结果是 2.5
% 取余号 左右两边必须都是整数才可以用取余号
         例：5/2 结果是 1
           	 5/2.0 报错
++ 自增 a++; => a = a + 1;
        在同一语句中，a++代表先使用a的值，用完之后再自增
        			 ++a代表先给a自增，然后再使用a的值
- - 自减 a--; => a = a - 1;
        在同一语句中，a--代表先使用a的值，用完之后再自减
        			 --a代表先给a自减，然后再使用a的值
```

### （2）赋值运算符

```c
= 	+= 	-= 	*= 	/= 	%=

= 赋值号 赋值号左边是被赋值的空间，右边是要赋值的数据。左右两边必须数据类型一致
		例：x = 5;
+= 		x+=3 	=> 	x=x+3 	8	
-= 
*= 		x*=2 	=> 	x=x*2 	10
/=
%=	 	x%=2 	=> 	x=x%2 	1
    
//题目：输入一个三位数，分别打印这个三位数的个位、十位、百位    
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int num,ge,shi,bai;
 scanf("%d",&num);//123
 ge = num%10;
 shi = num/10%10;
 bai = num/100;
 printf("%d %d %d\n",ge,shi,bai);
 return 0;
}
```

### （3）逻辑运算符 

```c
&& 		||		 ！

		真 成立 1
		假 不成立 0
&& 	逻辑与 	如果两个操作数都为真，结果就为真。有一方为假，结果就为假。
|| 	逻辑或 	如果两个操作数有一方为真，结果就为真。两方都是假，结果才是假。
！ 	逻辑非 	逆转操作数的逻辑状态
```

### （4）关系运算符

```c
== 	< 	>	 <=	 >= 	！=

关系运算符和逻辑运算符一般都用在条件语句中。
```

### （5）条件运算符

```c
		？：
            
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int a = 8,b = 5;
 printf("%d\n",a<b?a:b); //a小于b吗？如果小于(条件成立)，将a(冒号左边)的值 返 
 回 到结果中；如果不小于(条件不成立)，将b(冒号右边)
 的值 返回 到结果中
 return 0;
}
```

### （6）位运算符 

​		**作用于 位 ，逐位操作**

```c
& | ^ ~ << >>
    
& 	按位与 	两个操作数的位上都是1时，结果是1；有一个为0，结果就是0；
    	例：
    	 int a = 8,b = 9; //a = 1000 b = 1001
   						  //a&b = 1000 ---> 8
     	printf("%d\n",a&b); //打印 8
| 	按位或 	两个操作数的位上都是0时，结果是0；有一个为1，结果就是1；
^ 	按位异或 	两个操作数的位上相同时，结果是0；不同 时，结果就是1；
```

| q    | p    | q&p  | q\|p | q^p  |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 1    | 1    |
| 0    | 1    | 0    | 1    | 1    |
| 0    | 0    | 0    | 0    | 0    |
| 1    | 1    | 1    | 1    | 0    |

```c
~ 	按位取反 	0变1 ，1变0
<< 	按位左移 	将二进制数向左移动若干位，空出的部分补0
		例：8<<1 //将8的二进制数0000 1000向左移动一位变成了0001 0000---16
>> 	按位右移 	将将二进制数向右移动若干位，如果移动的是正数，左边补0
								如果移动的是负数，左边补1
    
#include <stdio.h>
int main(int argc, const char *argv[])
{
 unsigned int a = 8; //a = 1000 
//a>>2 = 0010 ---> 2
printf("%d\n",a>>2); //打印 2
printf("%d\n",a); //打印 8 （按位左右移并不会影响空间中数据的值）
 return 0;
}
```

### （7）sizeof运算符 

```c
计算操作数在内存中所占空间的大小，单位是 byte。将算好的数字作为返回值返回。
    64位操作系统会把返回值定义成 long int --- %ld
    32位操作系统会把返回值定义成 int --- %d
sizeof(变量名)；
sizeof(数据类型名)；
    
例：
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int a = 8; 
printf("%ld\n",sizeof(a)); // 打印 4
printf("%ld\n",sizeof(long int)); // 打印 8
 return 0;
}
```

## 	11，运算符优先级

​		不清楚优先级谁高谁低，那就加 （）。 

![](运算符优先级.png)

​		题目：终端输入两个数存在变量a,b中，把他们数据交换后再打印a,b。

## 	12，数据交换

### （1）中间变量

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int a,b,temp;
 scanf("%d%d",&a,&b); //a = 5;b = 6
    
 temp = a; // a = 5;b = 6;temp = 5
 a = b; // a = 6;b = 6;temp = 5
 b = temp; // a = 6;b = 5
 
 printf("%d %d\n",a,b);
 return 0;
}
```

### （2）数学方法

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int a,b,temp;
 scanf("%d%d",&a,&b);//a = 5;b = 6
 
 a = a+b; //a = 11;b = 6
 b = a-b; //a = 11;b = 5
 a = a-b; //a = 6;b = 5
    
 printf("%d %d\n",a,b);
 return 0;
}
```

### （3）异或 

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int a,b,temp;
 scanf("%d%d",&a,&b);//a = 5---0101 ; b = 6---0110
 
 a = a^b; //0101
         //0110 --- b
         //0011 --- a
 b = a^b; //0101 --- b
 a = a^b; //0110 --- a
    
 printf("%d %d\n",a,b);
 return 0;
}
```

## 	13，作用域

​		在任何一种编程语言中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C语言 中有三个地方可以声明变量： 

​		**函数内部，语句块内部** --- 局部变量 
​		**函数外部** --- 全局变量 
​		**在形式参数中声声明** --- 局部变量 

### （1）局部变量 

​		在某个函数 或 块 内部声明的变量。 
​		它们只能被**该函数 或 该代码块内部**使用（作用域）。局部变量在作用域外部是不可知的。 

### （2）全局变量 

​		全局变量是定义在函数外部的变量，一般写在所有函数的最前面。 
​		全局变量在整个程序的生命周期中都是有效的，在任意一个函数或者代码块中都可以访问到全局变量的空间(值)。 

### （3）形式参数 

​		函数的参数 叫做 形式参数。形式参数被当作局部变量，只是声明的地方不一样而已。用法和函数内部的局部变量相同。 

​		当全局变量和局部变量重名时，例如，全局变量int a；和局部变量 int a；在函数内部访问a时，**优先访问到局部变量**。 

​		当局部变量没有被赋值时，变量空间中存着的是随机的数据；但是当全局变量没有被赋值时，变量空间中会默认赋予一个值： 

| 数据类型 | 初始化默认值 |
| -------- | ------------ |
| int      | 0            |
| char     | 0--->NULL    |
| float    | 0.0          |
| double   | 0.0          |
| pointer  | NULL         |

## 	14，内存划分

![](内存划分.png)

# C基础之常用三语句

## 	一、C基础之条件语句

### 		1，基本if语句

![](if语句.png)

​		格式： 
​					if(表达式) 
​					{ 
​							语句块； 
​					}

​		例： 

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int a;
 scanf("%d",&a);
    
 if(a<10)
 {
 printf("a小于10\n");
 }
 printf("程序结束啦\n");
 
 return 0;
}
//如果表达式为真，就执行语句块
//如果表达式为假，就跳过语句块直接执行后面的语句。
```

### 		2，分支if-else语句

![](if-else语句.png)

​		格式： 
​						if(表达式) 
​						{ 
​								语句块1； 
​						} 
​						else 
​						{ 
​								语句块2； 
​						} 

​		例：

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int a;
 scanf("%d",&a);
 if(a<10)
 {
 printf("a小于10\n");
 }
 else
 {
 printf("a不小于10\n");
 }
 printf("程序结束啦\n");
 return 0;
}
//如果表达式为真，就执行语句块1
//如果表达式为假，就执行语句块2
//两个语句块一定是二选一去执行的，不可能两个都执行到
```

### 		3，嵌套if-else-if语句

![](嵌套if-else-if.png)

​		格式： 

​					if( 表达式1 ) 
​					{ 
​							语句块1； 
​					} 
​					else if( 表达式2 ) 
​					{ 
​							语句块2； 
​					} 
​					else if( 表达式3 ) 
​							... 
​					else 
​					{ 
​						语句块n； 
​					} 

​		例： 

```c
#include <stdio.h> 
int main(int argc, const char *argv[])
{ 
 int a;
 scanf("%d",&a);
 if(a<10)
 {
	 printf("a小于10\n");
 }
 else if(a<20)
 {
	 printf("a大于10小于20\n");
 }
 else if(a<30)
 {
	 printf("a大于20小于30\n");
 }
 else
 {
	 printf("a不小于30\n");
 }
    
 printf("程序结束啦\n");
 return 0;
}
//若干个语句块，只会执行符合条件的那一条。
//一旦某处符合条件，那么 条件语句 中后面的内容就不再执行了。
```

#### 		题目：

​		从外部输入一个学习成绩，范围为0 – 100，如果输入的成绩不在0~100之间，输出”输入有误“，否则，成绩大于等于90分，则输出A，成绩大于等于80，则输出B，成绩大于等于60，则输出C，小于60，则输出D。

```c
方法一： " 分支if-else " 中嵌套了第二层 " 嵌套if-else-if "
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int score;
     scanf("%d",&score);
     if(score<=100 && score>=0)
     {
         if(score>=90)
         {
            printf("A\n");
         }
         else if(score>=80)
         {
            printf("B\n");
         }
         else if(score>=60)
         {
            printf("C\n");
         }
         else
         {
            printf("D\n");
         }
     }
     else
     {
         printf("输入有误\n");
     }
     return 0;
}
方法二：只用"嵌套if-else-if"
#include <stdio.h> 
int main(int argc, const char *argv[])
{ 
     int score;
     scanf("%d",&score);
     if(score>=90&&score<=100)
     {
        printf("A\n");
     }
     else if(score<90&&score>=80)
     {
         printf("B\n");
     }
     else if(score<80&&score>=60)
     {
        printf("C\n");
     }
     else if(score<60&&score>=0)
     {
        printf("D\n");
     }
     else
     {
        printf("输入有误\n");
     }
     return 0;
}
```

#### 		题目：

​		输入一个年份，判断是闰年还是平年。

```c
#include <stdio.h> 
int main(int argc, const char *argv[])
{ 
     int year;
     scanf("%d",&year);
     if( (year%4==0 && year%100!=0) || year%400==0 )
     {
        printf("闰年\n");
     }
     else
     {
        printf("平年\n");
     }
     return 0;
}
```

### 		4，switch-case语句

​		格式： 
​					switch ( 表达式 ) 
​					{ 
​							case 常量表达式1：语句1； 
​							case 常量表达式2：语句2； 
​								... 
​							case 常量表达式n：语句n； 
​							default：语句n+1； 
​					} 

​		例： 

```c
include <stdio.h> 
int main(int argc, const char *argv[])
{
     int weekday;
     scanf("%d",&weekday);
     switch(weekday)
     {
     case 1:printf("你喜欢周一\n");break; //break; 辅助语句：跳出switch
     case 2:printf("你喜欢周二\n");break;
     case 3:printf("你喜欢周三\n");break;
     case 4:printf("你喜欢周四\n");break;
     case 5:printf("你喜欢周五\n");break;
     case 6:printf("你喜欢周六\n");break;
     case 7:printf("你喜欢周日\n");break;
     default:printf("你哪天都不喜欢\n");
     } 
        return 0;
}
注意：
  1）switch后面括号里的表达式必须是整数或字符类型，也可以是一个
常量。绝对不可以
 是小数。
 2）switch下面的case 和 default 必须用 { } 括起来
 3）当switch的表达式与case中的某个常量表达式相等时，就执行这
个case后面的语
 句。执行完之后，会把这个case后面所有的case的语句都执行一
遍，如果只想执行当
 前case的语句的话，我们需要在后面加一个辅助语句break; ，用来
跳出switch语句。
 4）default是默认的意思，当前面的case没有一个与表达式相匹配 
时，就执行default
 的语句.
 5）每个case后面的常量表达式都不可以相同，如果相同了，会发生
歧义。或者报错
 6）case里的常量表达式 只是一个标识的作用，并不是做判断。
 7）当语句中都有break时，各个case和default的出现次序不影响最
终结果，但是处于
 阅读方便的角度，我们通常按顺序去写，或者 按功能要求去写
 8）default 和 if-else-if中的最后一个else的功能一样，如果你的
default中不需要某些
 执行语句，可以不写default，但是，最好把default写上，后面别
写语句就好了。
 9）当default后面没有语句时，：和；一定不能少。
```

#### 		题目：

​		从外部输入一个学习成绩，范围为0 – 100，如果输入的成绩不在0~100之间， 输出”输入有误“，否则，成绩大于等于90分，则输出A，成绩大于等于80，则输出B， 成绩大于等于60，则输出C，小于60，则输出D。

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int score;
     scanf("%d",&score);
     switch(score/10)
     {
     case 10:if(score>100)
             {
                 printf("输入有误\n");
                 break;
             } 
     case 9:printf("A\n");break;
     case 8:printf("B\n");break;
     case 7:
     case 6:printf("C\n");break;
     case 5:
     case 4:
     case 3:
     case 2:
     case 1:
     case 0:if(score<0)
             {
                 printf("输入有误\n");
                 break;
             } 
    		 printf("不及格\n");break;
     default:printf("输入有误\n");
     }
     return 0;
}
```

####  		题目：

​		1.在终端输入一个字母，如果是大写字母，则输出小写字母，如果是小写字母， 则输出大写字母。 
​		2.输入年月日，打印出这个日子是这个年的第几天 

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int year,month,day,flag = 0,sum_day=0;
     scanf("%d%d%d",&year,&month,&day);
    
     if(month<1||month>12||day<1)
     {
         printf("输入不合法\n");
         return -1; //初步判断输入合法性
     }
    
     if((year%100!=0&&year%4==0)||year%400==0) //判断闰年还是平年
     {
     	flag = 1; //闰年标志变量
     }
    
     switch(month) //进一步判断输入合法性
     {
     case 1:
     case 3:
     case 5:
     case 7:
     case 8:
     case 10:
     case 12:if(day>31)
             {
                 printf("输入不合法\n");
                 return -1;
             }
     case 4:
     case 6:
     case 9:
     case 11:if(day>30)
             {
                 printf("输入不合法\n");
                 return -1;
             }
     case 2:if(day>28+flag)
             {
                 printf("输入不合法\n");
                 return -1;
             }
     }
    
     switch(month) //总天数算法
     {
     case 12:sum_day += 30;
     case 11:sum_day += 31;
     case 10:sum_day += 30;
     case 9:sum_day += 31;
     case 8:sum_day += 31;
     case 7:sum_day += 30;
     case 6:sum_day += 31;
     case 5:sum_day += 30;
     case 4:sum_day += 31;
     case 3:sum_day = sum_day + 28 + flag;
     case 2:sum_day = sum_day + 31;
     case 1:sum_day = sum_day + day;
     }
     printf("%d\n",sum_day);
     return 0;
}
```

​		3.用switch语句实现四则运算：例如：从终端输入 5+4 ，按下回车，打印9， 从终端输入 5*4 ，按下回车，打印 20. 

​		4.从终端随机输入三个整数分别一次赋值给变量a,b,c，按照从大到小的顺序给a,b,c重新赋值后打印  a,b,c的值。例如：输入 8 3 9 ，输出 9 8 3 。 

​		5.从外部输入一个学习成绩，范围为0 ~ 100，成绩100 ~ 90输出A，成绩89 ~  80输出B，成绩79 ~  70输出C，成绩69 ~ 60输出D，小于60，输出不及格。如果输入的成绩不在0 ~  100之间，输出” 输入有误“。 用两方法，一：switch嵌套在if-else中。二：if嵌套在switch中

​		6.编写程序计算身高： 

​		每个做父母的都关心自己孩子成人后的身高，据有关生理卫生知识与数理统 计分析表明， 影响小孩成人后身高的因素有遗传、饮食习惯与坚持体育锻炼等。小孩成人 后身高与其父 母身高和自身性别密切相关。 

​		设faHeight为其父身高，moHeight为其母身高，身高预测公式为：  男性成人时身高 = (faHeight + moHeight) * 0.54(cm)  女性成人时身高 = (faHeight * 0.923 + moHeight) / 2(cm)  此外，如果喜爱体育锻炼，那么可增加身高2% 如果有良好的卫生饮食习惯，那么可增加身高1.5% 

​		程序要求：父亲的身高与母亲的身高、小孩的性别、是否喜爱体育锻炼和是 否有良好的卫生饮食习惯也从键盘上输入，最终输出预测的身高。  

​		提示：小孩性别的输入方式，可在屏幕给出提示“请输入小孩的性别（男孩 输入M，女孩输入F）：”，然后通过if语句来判断从键盘输入的字符是M还 是F。是否喜爱体育锻炼也可以通过类似的方式实现。

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
     float faH,moH,kidH,kidH_sport=0,kidH_eat=0;
     char sex;
     char sports,eat;
     printf("请输入父亲的身高：");
     scanf("%f",&faH);
     printf("请输入母亲的身高：");
     scanf("%f",&moH);
     getchar();
     printf("请输入小孩的性别(m/f)：");
     scanf("%c",&sex);
     getchar();
     printf("小孩喜欢体育运动吗？(y/n)");
     scanf("%c",&sports);
     getchar();
     printf("小孩喜欢吃垃圾食品吗？(y/n)");
     scanf("%c",&eat);
    
     if(sex == 'm')
     { 
         kidH = (faH + moH) * 0.54;
         if(sports == 'y')
         {
         	kidH_sport = kidH * 0.02;
         }
         if(eat == 'n')
         {
         	kidH_eat = kidH * 0.015;
         }
         kidH = kidH + kidH_sport + kidH_eat;
     } 
     else
     { 
         kidH = (faH * 0.923 + moH) / 2;
         if(sports == 'y')
         {
         	kidH_sport = kidH * 0.02;
         }
         if(eat == 'n')
         {
         	kidH_eat = kidH * 0.015;
         }
         kidH = kidH + kidH_sport + kidH_eat;
     } 
     printf("%.f\n",kidH);

     return 0;
}
```

## 	二 、C基础之循环语句

​		根据条件，循环执行相同的一个代码块；
​		如果这个条件是永恒成立的，那程序就会进入死循环；
​		退出死循环的方式：ctrl + c;

### 		1，while语句

```c
/*格式：
        循环变量初始化；
        while( 循环条件 ) //循环条件为真，才能进入下面的大括号
        {
            循环语句；
            循环变量改变方式；
		}*/
例：
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int a = 0;
     while(a<=10)
     { 
     	printf("%d\n",a++);
     } 
     return 0;
}
运行步骤：
    1）先判断循环条件；
    2）如果条件成立，执行循环语句 和 循环变量改变语句。
    3）拿着改变后的循环变量再次判断循环条件；
    4）重复执行2）3）步，知道条件不成立时，结束循环语句(退出循环)，执行后面的代码
练手：1~10的累加。
```

### 		2，do-while语句

```c
/*格式：
        循环变量初始化；
        do{
            循环语句；
            循环变量改变语句；
        }while(循环条件);*/
例：
     int a = 10;
     do{
         printf("%d\n",a);
         a++;
     }while(a<=10);
运行步骤：
    1）先给循环变量初始化；
    2）第一次执行printf();语句 和 循环变量改变语句；
    3）拿着改变后的循环变量做判断
    4）如果条件成立，循环执行2）3）步，如果条件不成立，就结束do while语句，执行后面的语句。
    
while 和 do while 的区别是：
    while 语句，先判断条件。循环体有可能一次都执行不到；
    do while 语句，先执行一次循环体。循环体无论如何都至少会被执行一次。
```

### 		3，for语句

```c
/*格式：
    for( 循环变量初始化 ; 循环条件 ; 循环变量改变语句 )
    {
    	循环语句；
    }*/
例：
 for( a = 0 ; a<=10 ; a++ ) 
 {
 printf("%d\n",a);
 }
运行步骤：
    1）执行循环变量初始化（小括号中的第一部分，仅执行这一次）
    2）判断循环条件
    3）如果条件成立，执行循环语句
    4）执行循环变量改变语句
    5）重复执行2）3）4）步，直到条件不成立时，退出循环。
```

```c
	题目：一个猴子偷了一堆桃子，第一天吃了一半又多吃一个，第二天吃了剩下的一半又多吃了一个，之后的每天都这么吃，到第十天早上刚准备吃的时候，发现只剩下1个了，问：他偷了多少个桃子？
	题目：打印图形：
			*
		   ***
 		  *****
 		 *******
   		*********
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int i,j,k;
     for(i=1;i<=5;i++)
     {
         for( j=i ; j<5 ; j++ )
         {
         	printf(" ");
         }
         for( k=0 ; k<2*i-1 ; k++ ) 
         {
         	printf("*");
         }
         printf("\n");
     }
     return 0;
}
	/*对于嵌套循环，我们通常的做法是：大循环控制行数，小循环控制每行输出的内容。

		但凡是可以用循环去做的操作，肯定是有规律的。
		但凡是有规律的事情，肯定可以用循环来做。
		所以我们要做的事情就是：找规律，用表达式把规律表达出来。*/	
	题目：打印图形：
|*|*|*|*	
 |*|*|*|*
  |*|*|*|*
   |*|*|*|*
	题目：打印100-1000以内的所有的水仙花数水仙花数：是指一个三位数的每一位的立方和还等于这个数，则这个数称之为水仙花数
#include <stdio.h>
#include <math.h>
int main(int argc, const char *argv[])
{
     int ge,shi,bai,num;
     for(num=100;num<1000;num++)
     {
         ge = num % 10;
         shi = num/10%10;
         bai = num/100;
         if(pow(ge,3)+pow(shi,3)+pow(bai,3) == num)
         {
        	 printf("%d\n",num);
         }
     }
     return 0;
}
//注意：pow( , ); 函数的功能是完成指数形式的运算，需要调用math.h头文件
//在ubuntu中，如果代码是用了math.h中的数学函数，在gcc编译时，需要加参数 -lm
```

## 	三、C基础之辅助语句

### 		1，break语句

​		（1）跳出switch语句； 
​		（2）跳出循环； 
​		（3）break 只能用在switch和循环语句中；

### 		2，continue语句

​		（1）只能用在循环语句中 
​		（2）强制结束本次循环，开始下一次循环； 

​		注意：当continue用在while或do while 中时，一定要记得把循环变量改变语句写在 continue前面，  否则continue会导致你的循环变量始终不发生改变，进入死循环。例入下错误代码： 

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int a=0;
     while(a<10)
     { 
         printf("%d\n",a);
         if(a==8)
         { 
             printf("哈哈\n");
             continue;
         } 
         a++; //a++ 写在了continue后面，导致了死循环
     } 
     return 0;
}
```

```c
作业：1.打印图形：
F
_FE
__FED
___FEDC
____FEDCB
_____FEDCBA
2.打印图形：
_ABCDEF
__BCDEF
___CDEF
____DEF
_____EF
______F
3.九九乘法表
4.打印边长为五的菱形  
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int i,j,k;
     for(i=1;i<=5;i++)
     {
         for(j=0;j<5-i;j++)
         {
         	printf(" ");
         }
         printf("/");
         for(k=0;k<2*i-2;k++)
         {
         	printf(" ");
         }
         printf("\\");
         printf("\n");
     }
     for(i=0;i<5;i++)
     {
         for(j=0;j<i;j++)
         {
         	printf(" ");
         }
         printf("\\");
         for(k=0;k<8-2*i;k++)
         {
         	printf(" ");
         }
         printf("/");
         printf("\n");
     }
     return 0;
}
5.求1000以内的所有完数
	完数：完美的数，一个数的所有因子，除掉它本身相加还等于这个数，则这个数称之为完数
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int i,j,sum;
     for(i=1;i<=1000;i++)//循环被除数
     {
         sum = 0;
         for(j=1;j<i;j++)//循环除数
         {
             if(i%j==0)
             {
                sum = sum + j;
             }
         }
         if(sum == i)
         {
         	printf("%d\n",i);
         }
     } 
     return 0;
}
6.求1000以内所有的质数
	质数：只能够1和它本身整除
```

# C基础之数组

​		数组是用来存一组数据类型相同的数据的，而且数组中每个数据的存储空间的地址是连续的。 数据类型相同，地址连续。 

​		数组有多维度： 
​					一维数组：arr[ 3 ]; 
​					二维数组：arr[ 3 ] [ 4 ]; 
​					...

## 	一，一维数组

### 		1，声明数组

```c
格式：
	数据类型 数组名[ 数组容量 ]；
例：
int arr[ 5 ]; //声明了一个整型数组arr，容量为5（能存5个整型数据）。
char brr[ 3 ]; //声明了一个字符数组brr，容量为3（能存3个字符型数据）。
注意：数组容量 只能是整型常量。
	数组中每一个数据都叫数组的 元素 。
```

### 		2，数组初始化

```c
1）int arr[3] = {5,6,7}; //每个元素分别初始化
2）int arr[3] = {5,6}; //给前面的元素初始化，未初始化部分默认用0赋值
   int arr[3] = { , ,5}; //错误的，不可以省略前面部分
3）int arr[3] = {0}; //默认给所有元素都初始化为0
4）int arr[ ] = {1,2,3}; //缺省了数组容量，但是编译器会根据初始化的内容给一个最小的合适的空间(容量)，本例为 3 
  int arr[ ]; //错误的，编译无法得知数组需要多大的内存空间
```

### 		3，数组内存大小的计算

```c
	sizeof(数组名)；
例：
    int arr[ 3 ]; //sizeof(arr); 的结果是 12； 3*4
    char brr[20]; //sizeof(brr); 的结果是 20； 20*1
    double crr[ 9 ]; //sizeof(crr); 的结果是 72； 9*8
```

### 		4，数组元素的访问

```c
元素访问方式：
        数组名 + 下标
        形如：arr[ 0 ]
下标的取值范围：
		0 ~ 数组容量-1 
例：
     int arr[3] = {5,6,7};
     printf("第一个元素为：%d\n",arr[0]); // 5
     printf("第二个元素为：%d\n",arr[1]); // 6
     printf("第三个元素为：%d\n",arr[2]); // 7
```

### 		5，数组的遍历

```c
	当数组在声明时没有被初始化，在声明之后如果要对数组的空间中存入数据，就只
能分别给每个元素去赋值。当数组容量很小的时候，我们可以通过访问到每个元素
然后分别赋值，例如：
         int arr[3];
         arr[0] = 5;
         arr[1] = 6;
         arr[2] = 7;
	但是，如果数组容量很大了，上述方法就不太实际了，此时我们需要遍历数组。
	
	遍历数组：循环执行数组中的每一个元素。
例如：
         int a,i;
         int arr[3];
         arr[0] = 5;
         arr[1] = 6;
         arr[2] = 7; //数组元素分别赋值
         for(i=0;i<=3-1;i++) //数组的遍历,此时i代表了数组的下标
         {
             arr[i] = 5+i;
         }
```

```c
题目：声明两个整型数组arr[5],brr[5]，给arr中每个元素赋值，然后通过遍历，让
brr和arr相同，打印brr。
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int arr[5],brr[5];
     int i;
     for(i=0;i<5;i++)
     {
        scanf("%d",&arr[i]);
         brr[i] = arr[i];
     }
     for(i=0;i<5;i++)
     {
    	 printf("brr数组第%d个元素：%d\n",i+1,brr[i]);
     } 
     return 0;
}
```

### 		6，随机数---

```c
32位系统中：
    包含随机数函数的头文件：
			#include <stdlib.h>
    随机数函数原型：
			int rand(void);
			void srand(unsigned int seed); //随机数时间种子
如果 rand() 和 srand() 用在64位操作系统中，需要额外调用头文件<time.h>
例：
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main(int argc, const char *argv[])
{
     srand(time(0));
     int a;
     a = rand()%100; //取100以内的随机数
     printf("%d\n",a);
     return 0;
}
```

```c
题目：给一个容量为5的数组存100以内的随机数，打印这个数组，并且打印最大值。
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main(int argc, const char *argv[])
{ 
     srand(time(0));
     int arr[5],i,max;
     for(i=0;i<5;i++)
     {
         arr[i] = rand()%100; //给每个元素赋随机值
         printf("%d ",arr[i]); //打印每个元素
     }
     putchar('\n');
     max = arr[0]; //默认最大值为首元素的值
     for(i=1;i<=4;i++)
     {
     	if(max < arr[i]) //如果有比当前max大的元素，就替换掉max中的值
         {
         	max = arr[i];
         }
     }
     printf("%d\n",max);
     return 0;
}
题目：从终端输入一串字符，以'\n'作为结束标志，然后计算这一串字符中有几个小写字母。
#include <stdio.h>
int main(int argc, const char *argv[])
{ 
     char arr[30];
     int i,count=0,j;
     for(i=0;i<30;i++)
     {
         scanf("%c",&arr[i]);
         if(arr[i]=='\n')
         break;
         printf("%c",arr[i]);
     }
     putchar('\n');
     for(j=0;j<i;j++)
     {
         if(arr[j]>='a'&&arr[j]<='z')
         count++;
     }
     printf("%d\n",count);
     return 0;
}
```

## 	二，二维数组

### 		1，声明格式

```c
格式：
		数据类型 数组名[行数][列数];
例： int arr[3][4]; //声明了一个三行四列的整型二维数组。占48个字节。3*4*4
	char brr[4][5]; //声明了一个四行五列的字符型二维数组。占20个字节。4*5*1
```

### 		2，二维数组初的始化

```c
1）int arr[2][3] = {{1,2,3},{4,5,6}}; //数组整体全部初始化
 int arr[2][3] = {1,2,3,4,5,6}; 
2）int arr[2][3] = {1,2,3}; //初始化前面部分，未初始化部分默认置为0
3）int arr[2][3] = {0}; //全部初始化为0
4）int arr[2][3] = {{5},{6}}; //给第一行和第二行前面部分初始化
5）int arr[][3] = {1,2,3,4,5,6,7}; //缺省行数，根据初始化的内容，给一个默认最小的行数，3
 int arr[2][] = {1,2,3,4,5,6,7}; //缺省列数，错误写法。
```

### 		3，二维数组的访问

```c
		//数组名+行号+列号
            行号：0 ~ 行数-1
            列号：0 ~ 列数-1
例：
    int arr[2][2] = {1,2,3,4};
    arr[0][0] == 1;
    arr[0][1] == 2;
    ...
```

### 		4，二维数组的遍历

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main(int argc, const char *argv[])
{
     srand(time(0));
     int arr[2][3],i,j;
     for(i=0;i<2;i++)
     { 
        for(j=0;j<3;j++)
         { 
             arr[i][j] = rand()%100;
             printf("%d",arr[i][j]);
         } 
         printf("\n");
     } 
     return 0;
}
```

```c
题目：给一个3*3的二维数组赋随机值，打印其中的最大数及行号和列号。
 max = arr[0][0];
 for(i=0;i<3;i++)
 { 
     for(j=0;j<3;j++)
     { 
         if(max < arr[i][j])
         { 
             max = arr[i][j];
             h = i;
             l = j;
         }
     }
 }
 printf("%d %d %d\n",max,h,l);
```

# C基础之排序算法

## 	一，冒泡排序

![](冒泡排序.png)

```c
90 21 132 6 34			 从小到大排序 一共5个数字 （n）
（1）第一轮 					  做了四轮比较 （n-1） i
①因为90>21，所以换位置 			 每轮比较（n-i）次
		21 90 132 6 34
②因为90<132，所以不动
③因为132>6，所以换位置
		21 90 6 132 34
④因为132>34，所以换位置
		21 90 6 34 132
（2）第二轮
①因为21<90，所以不动
②因为90>6，所以换位置
		21 6 90 34 132
③因为90>34，所以换位置
		21 6 34 90 132
（3）第三轮
①因为21>6，所以换位置
		6 21 34 90 132
②因为21<34，所以不动
		6 21 34 90 132
（4）第四轮
①因为6<21，所以不动
		6 21 34 90 132
```



```c
代码：
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int arr[10]={90,75,92,15,62,34,18,99,5,42};
     int temp,i,j;
     for(i=1;i<10;i++)
     { 
         for(j=1;j<=10-i;j++)
         { 
             if(arr[j-1] > arr[j])
             { 
                 temp = arr[j-1];
                 arr[j-1] = arr[j];
                 arr[j] = temp;
             } 
         } 
     } 
     for(i=0;i<10;i++)
     { 
     	printf("%d ",arr[i]);
     } 
     putchar('\n');
     return 0;
}
```



## 	二，选择排序

![](选择排序.png)

```c
90 21 132 6 34 				从小到大排序 一共5个数 n
								比较了n-1轮 i
（1）第一轮 							每轮比较 n-i 次
将未排序数列中的第一个数90当作是最小数。
①因为90>21，所心中的最小数变为21
②因为21<132，所以心中的最小数不变
③因为21>6，所以心中的最小数变为6
④因为6<34，所以心中的最小数不变
将心中的最小数和未排序数列的首位 数据交换
						6 21 132 90 34
（2）第二轮
将未排序数列中的第一个数21当作是最小数。
①因为21<132，所以心中的最小数不变
②因为21<90，所以心中的最小数不变
③因为21<34，所以心中的最小数不变
将心中的最小数和未排序数列的首位 数据交换
						6 21 132 90 34
（3）第三轮
将未排序数列中的第一个数132当作是最小数。
①因为132>90，所以中的最小数变为90
②因为90>34，所以中的最小数变为34
将心中的最小数和未排序数列的首位 数据交换
						6 21 34 90 132
（4）第四轮
将未排序数列中的第一个数90当作是最小数。
①因为90<132，所以心中的最小数不变
将心中的最小数和未排序数列的首位 数据交换
						6 21 34 90 132
```



```c
代码：
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int arr[10] = {19,61,72,13,42,99,62,15,84,35};
     int min,i,j,temp;
     for(i=0;i<10-1;i++)
     { 
         min = i; //min接收的是数组的下标
         for(j=i+1;j<10;j++)
         { 
             if(arr[min] > arr[j])
             { 
             	min = j; //用数组下标给min重新赋值
             } 
         } 
         temp = arr[min];
         arr[min] = arr[i];
         arr[i] = temp;
     } 
     for(i=0;i<10;i++)
     { 
     	printf("%d ",arr[i]);
     } 
     putchar('\n');
     return 0;
}
```

```c
作业：1.给定一个数组arr[ ]={52,13,45,9,61,72,84};，按从大到小排序并打印排序后的结果。
（两种排序算法各做一遍）。
2----> 使用容量为100的数组存斐波那契数列，然后从终端输入一个不大于100的数n，
打印斐波那契数列的前n项， 斐波那契数列：1 1 2 3 5 8 13…
3---->给一个容量为10的数组填充100以内的随机数，打印数组。
然后再输入一个数，判断这个数是否存在于数组中。打印判断结果。
4.从终端输入一个英文句子，以 . 作为结束输入的标志。在终端打印出这个句子，并且
计算出句子中有几个单词，几个字母。例如：输入 i love you. 输出 i love you. 
有三个单词，八个字母
5.从终端输入一串字符，以'\n'作为结束输入的标志。倒置存储后，再正向打印数组。例
如：
输入 asdfghjkl回车
输出 lkjhgfdsa
#include <stdio.h>
int main(int argc, const char *argv[])
{
     char arr[30];
     int i=0,j,temp;
     do{ 
         scanf("%c",&arr[i]);
         i++;
     }while(arr[i-1]!='\n');

     for(j=1;j<=(i-1)/2;j++)
     {
         //arr[j-1] --- arr[i-j-1] 数据交换
         temp = arr[j-1];
         arr[j-1] = arr[i-j-1];
         arr[i-j-1] = temp;
     }
     for(j=0;j<i-1;j++)
     { 
     	printf("%c",arr[j]);
     } 
     return 0;
}
6.从终端输入数据到一个容量为5的整型数组中，打印第二大的数。
 for(i=1;i<5;i++)
 {
     if(arr[i]<arr[0]) //从大到小排序后，遍历数组找到比arr[0]小的元素
     {
         printf("%d\n",arr[i]);
         break;
     }
 }
```

# C基础之字符串

​		字符串（string）一定是**以 '\0' 结尾**的字符数组。 

​		普通字符数组：char crr[10] = {'a','b','c','d'}; 
​		字符串： char crr[10] = {'a','b','c','d','\0'}; 
​		字符串常量： char crr[10] = "abcd"; ---> 隐藏了一个'\0'

## 	1，字符串的初始化

​		C语言中没有专门存放字符串的数据类型，所以我们只能把字符串放在**字符数组**中， 
​		以**'\0'**结尾。 

​				char crr[10] = {'h','e','l','l','o','\0'}; //字符数组的方式初始化 
​				char crr[10] = "hello"; //常量字符串的方式初始化 
​				char crr[] = "hello"; //数组容量为6 

## 	2，字符数组的大小

​		sizeof(字符数组名)；

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
     char crr[] = "hello";
     char drr[30] = "hello";
     printf("%ld\n",sizeof(crr)); //打印6
     printf("%ld\n",sizeof(drr)); //打印30
     return 0;
}
```

## 	3，字符串的输入输出函数

### （1）格式化输入输出函数 scanf printf

​			格式符：%s 

```c
例：
#include <stdio.h>
int main(int argc, const char *argv[])
{
     char crr[30];
     scanf("%s",crr); //不需要加 & 。因为数组名也可以代表 数组的首地址
     printf("%s\n",crr);
     return 0;
}
注意：
    1）scanf输入字符串时不需要给数组名取地址
 	2）scanf 输入字符串时 只能识别到空格、tab、回车之前的内容。
```

### （2）字符串输入输出函数 puts gets

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
     char crr[30];

     gets(crr);
     puts(crr);
     return 0;
}
//gets函数没有越界保护，所以我们在使用时一定要注意输入的字符串不要超过字符数组的数组容量。
//gets可以将空格、tab作为字符输入到字符串中。
```

```c
题目：从终端输入一个字符串，打印字符串的长度。
#include <stdio.h>
int main(int argc, const char *argv[])
{
     char crr[30];
     int i;
     gets(crr);
     for(i=0 ; crr[i]!='\0' ;i++); //注意：这里我用了; 结尾，代表这个循环语句没有循环体，只循环执行i++和条件判断
     printf("%d\n",i);
     return 0;
}

题目：从终端输入一个字符串存在数组arr中，将arr复制到brr中，打印brr
#include <stdio.h>
int main(int argc, const char *argv[])
{
     char crr[30],brr[30];
     int i;
     gets(crr);
     for(i=0;crr[i]!='\0';i++)
     {
     	brr[i] = crr[i];
     }
     brr[i]='\0'; //前面遍历没有把crr中的'\0'复制过来，所以为了能成功打印字符串，所以要再brr后面补一个'\0'
     printf("%s\n",brr);
     return 0;
} 

题目：从终端输入两个字符串，将第二个字符串拼接在第一个字符串后面并打印拼接后
的字符串
#include <stdio.h>
int main(int argc, const char *argv[])
{
     char crr[30],brr[30];
     int i,j;
     gets(crr);
     gets(brr);
     for(i=0;crr[i]!='\0';i++);
     for(j=0;brr[j]!='\0';i++,j++)
     {
    	 crr[i]=brr[j];
     }
     crr[i]='\0';
     puts(crr);
     return 0;
}
```

## 	4，string函数族

- strcpy() --- 字符串的复制 

- strcat() --- 字符串的拼接 

- strlen() --- 字符串求长度 

- strcmp() --- 字符串比大小 

### （1）strlen()函数

```c
//计算字符串的长度（不包括'\0'）
#include <stdio.h>
#include <string.h>
int main(int argc, const char *argv[])
{
     char crr[30]="hello world";
     printf("%ld\n",strlen(crr)); //打印 11
     return 0;
}
```

### （2）strcpy()函数 

```c
函数原型：
 		char *strcpy(char *dest, const char *src);
	将src指向的字符串复制到dest指向的空间中。
#include <stdio.h>
#include <string.h>
int main(int argc, const char *argv[])
{
 char arr[30]="china";
 char crr[30]="hello world";
 strcpy(crr,arr);
 printf("%s\n",crr); //打印 china
 return 0;
}
```

srtncpy()函数 

```c
函数原型：
		char *strncpy(char *dest, const char *src, size_t n);
	将src字符串中的前n个字符复制到dest字符串中。
#include <stdio.h>
#include <string.h>
int main(int argc, const char *argv[])
{
     char arr[30]="china";
     char crr[30]="hello world";

     strncpy(crr,arr,5);

     printf("%s\n",crr); //打印 "china world"
     return 0;
}
```

### （3）strcat()函数

```c
函数原型：
		char *strcat(char *dest, const char *src);
	将src字符串拼接在dest字符串后面（覆盖掉dest末尾的'\0'）
#include <stdio.h>
#include <string.h>
int main(int argc, const char *argv[])
{
     char arr[30]="china";
     char crr[30]="hello world";
     strcat(crr,arr);

     printf("%s\n",crr);
     return 0;
}
```

### （4）strcmp()函数 

```c
函数原型：
		int strcmp(const char *s1, const char *s2);
	比较s1字符串和s2字符串的大小，如果s1大，返回正数，如果s1等于s2，返回0，如果s1小，返回负数。
#include <stdio.h>
#include <string.h>
int main(int argc, const char *argv[])
{
     char arr[30]="hcina";
     char crr[30]="hello world";
     printf("%d\n",strcmp(arr,crr));
     return 0;
}
```

```c
题目：输入一个英文句子，删除空格后打印字符串。
方法一：用了另外一个辅助数组
#include <stdio.h>
#include <string.h>
int main(int argc, const char *argv[])
{
     int i,j;
     char arr[30],brr[30];
     gets(arr);
    // for(i=0;i<strlen(arr);i++)
     for(i=0,j=0;arr[i]!='\0';i++)
     {
         if(arr[i]!=' ')
         {
         	brr[j++] = arr[i];
         }
     }
     brr[j]='\0';
     printf("%s\n",brr);
     return 0;
}
方法二：只用一个字符数组
#include <stdio.h>
#include <string.h>
int main(int argc, const char *argv[])
{ 
     int i,j;
     char arr[30];
     gets(arr);
     for(i=0,j=0;arr[i]!='\0';i++)
     { 
         if(arr[i]!=' ')
         { 
             arr[j] = arr[i];
             j++;
         }
         printf("%d:%s\n\n",i,arr); //检验
     }
     arr[j]='\0';
     puts(arr);
     return 0;
}

题目：不用strcmp，自己写一个功能相同的字符串比较。
#include <stdio.h>
#include <string.h>
int main(int argc, const char *argv[])
{ 
     char arr[30]="hello",brr[30]="hello9";
     int i;
     for(i=0;arr[i]!='\0'||brr[i]!='\0';i++)
     {
         if(arr[i]-brr[i]!=0)
         {
             printf("%d\n",arr[i]-brr[i]);
             return 0;
         }
     }
     if(arr[i]-brr[i]!=0)
    	 printf("%d\n",arr[i]-brr[i]);
     else
     	printf("0\n");
     return 0;
}

作业：
1.自己在终端输入一个字符串，然后再输入一个字符，计算这个字符串中有几个这样的
字符；
2.输入一个字符串，再输入一个字符，用%s打印 字符串中的 第一个这个字符 之前的
字符们。如果字符串s中没有这个字符c，打印 %c不在字符串中。 用字符串的方式打
印。
3.输入一个字符串，再输入两个数n,m，要求把字符串中从第n个数开始，向后数m个
数，生成一个新的字符串并输出；如果数完m个之后超出了字符串的长度，只需要输出
原长度就好；如果n或m的值不合法，要输出提示语。
方法一：
#include <stdio.h>
#include <string.h>
int main(int argc, const char *argv[])
{
     char arr[30];
     char brr[30];
     int n,m,i,j;
    
     gets(arr);
     scanf("%d%d",&n,&m);
    
     if(n<=0||n>strlen(arr)||m<0)
     {
     	printf("输入不合法\n");
     }
     else
     {
         if(n+m>strlen(arr))
         {
             for(j=0,i=n-1;arr[i]!='\0';i++,j++)
             {
                brr[j] = arr[i];
             }
             brr[j] = '\0';
         }
         else
         {
             for(j=0,i=n-1;i<=n+m-1;i++,j++) 
             {
             	brr[j] = arr[i];
             }
             brr[j] = '\0';
         }
         printf("%s\n",brr);
     }
     return 0;
}
方法二：
#include <stdio.h>
#include <string.h>
#define N 30
int main(int argc, const char *argv[])
{
     char arr[N];
     char brr[N];
     int n,m,i,j;
    
     gets(arr);
     scanf("%d%d",&n,&m);

     if(n<=0||n>strlen(arr)||m<0||m>N-2)
     {
     	printf("输入不合法\n");
     }
     else
     {
         for(j=0,i=n-1;i<=n+m-1;i++,j++)
         {
         	brr[j] = arr[i];
         }
         brr[j] = '\0';
         printf("%s\n",brr);
     }
     return 0;
}

4.输出一个十行的杨辉三角
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1
1 9 36 84 126 126 84 36 9 1
方法一：
#include <stdio.h>
#define N 10 
int main(int argc, const char *argv[])
{
     int arr[N][N]={0};
     int i,j;

     for(i=0;i<N;i++)
     {
     	arr[i][0] = 1;
     }
    
     for(i=1;i<N;i++)
     {
         for(j=1;j<=i;j++)
         {
         	arr[i][j]=arr[i-1][j-1]+arr[i-1][j];
         } 
     } 

     for(i=0;i<N;i++)
     {
         for(j=0;j<=i;j++)
         	printf("%d\t",arr[i][j]);
         printf("\n");
     } 
     return 0;
} 
方法二：
#include <stdio.h>
#define N 10
int main(int argc, const char *argv[])
{
     int arr[N][N];
     int i,j;
    
     for(i=0;i<N;i++)
     {
         for(j=0;j<=i;j++)
         {
             if(i==j||j==0)
             {
                arr[i][j] = 1;
             }
             else
                arr[i][j]=arr[i-1][j-1]+arr[i-1][j];
         } 
     } 

     for(i=0;i<N;i++)
     {
         for(j=0;j<=i;j++)
         	printf("%d\t",arr[i][j]);
         printf("\n");
     } 
     return 0;
}
5.给一个3*3的二维数组手动赋值，打印其中的第二大数及行号和列号。
6.做string函数族的四个函数的功能
7.输入一个英文句子，删除空格后打印字符串，不允许使用辅助数组。
```

# C基础之指针

​		**指针**是C语言的灵魂。 学不会指针 == C语言白学 

​		C语言可以通过指针直接操作计算机硬件，因为指针可以访问到内存地址。 

​		对于每个变量来说，又可以用 & 取地址符 来获取它的地址。 
​				每个字节都有地址，**变量的地址用它首字节的地址表示** 
​												**数组的地址用它首元素的地址表示** 

​		**指针 就是用来 存地址 的**

## 	1，声明指针变量

```c
	注意：指针也是一种数据类型，对于指针变量名来说，他的数据类型是 基类型 *
/*格式：
		数据类型 *指针变量名；
数据类型：它是指针变量的基类型，必须是一个合法的C语言类型。
	 * ：用来说明你现在声明的这个标识符是 指针变量的名字。
指针变量名：遵循标识符命名规则。*/
        
口语：
    指针 --- 指针变量
    地址 --- 内存地址
书面语言：
    指针 --- 内存地址
    指针变量 --- 指针变量
例：
     int *p; //声明了一个整型指针变量p。
     char *pc; //声明了一个字符型指针变量pc
注意：
 1）指针变量 指的是 那个名字，不包括 * 。我们会说"p","pc"是指针量，"*p","*pc"不是指针变量。
 2）所有的数据类型，不管是int char float，都不会影响指针变量存的内容是十六进制的地址。
 3）虽然指针变量的数据类型可能不同，但是他们打印的内容都是等长的。特定基类型的指针变量只能存放特定数据类型的空间的地址。
```

## 	2，指针的赋值

```c
//赋值号两边的数据类型必须一致，所以 = 左边是指针变量名 右边必须是一个地址
 #include <stdio.h>
 int main(int argc, const char *argv[])
 {
     int a;
     char c;
     
     int *p; 
     char *pc = &c; //指针的初始化，&c赋值的对象是 pc，而不是*pc
     p = &a; //指针的赋值
     
     printf("%p\n",p);
     printf("%p\n",&a);
     printf("%p\n",pc);
     printf("%p\n",&c);
     return 0;
}
```

## 	3，指针的大小计算

```c
sizeof(变量名)；
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int *p; //声明了一个整型指针变量p。
     char *pc; //声明了一个字符型指针变量pc
    
     int a;
     char c;
    
     p = &a; 
     pc = &c;
    
     printf("%d\n",sizeof(p)); //在32位操作系统中打印 4，64位操作系统中打印 8
     printf("%d\n",sizeof(pc)); //在32位操作系统中打印 4，64位操作系统中打印 8

     return 0;
}
不管指针变量的数据类型是什么，它里面永恒存着的数据是一个十六进制的地址，所以指针变量占用的内存大小是固定的：32位系统----4Byte 64位系统----8Byte
```

## 	4，指针变量的作用

```c
#include <stdio.h> 
int main(int argc, const char *argv[])
{ 
     int a = 5;
     char c = '?';
    
     int *p;
     char *pc = &c; 

     p = &a;
    
     printf("%p\n",p);
     printf("%p\n",pc);
    
     printf("%d\n",*p);
     printf("%c\n",*pc);
     return 0;
}
在指针名前面加 * （节引用符），可以访问到指针所指向的空间中的数据。
    p --> &a
    *p --> a
我们一般把节引用符理解为 ”从地址中取值“ 。
注意：这个 * 和声明指针变量时的星号含义完全不同
```

## 	5，野指针

```c
	没有合法指向的指针叫野指针。
	因为野指针在没有被明确赋值之前指向的都是内存中随机的地址，所以我们不应该对野指针做读写操作，防止无意中修改了某个重要空间中的数据，轻则导致别的程序错误，重则导致系统崩溃。
----------------------------------------------------------------------------
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int *p; //声明了一个整型指针p，没有合法指向，所以p是野指针
 printf("%p\n",*p); //错误！不能对野指针做读操作
 *p = 5; //错误！不能对野指针做写操作
 return 0;
}
```

## 	6，NULL指针

```c
	当你提前预知到需要使用指针，但目前又没有一个合适的地址可以给到指针变量中，我们就需要给指针变量赋一个NULL值，此时，指针就指向了一个0x0 或 null 的地址。这个指针就暂时称之为NULL指针
	NULL指针是不可以进行读写操作的。
#include <stdio.h>
int main(int argc, const char *argv[])
{
     int a;
     int *p=NULL; //p为NULL指针 
     printf("%p\n",p); //打印为 (nil)
     *p = 5; //错误，不可以对NULL指针赋值
     return 0;
}
```

## 	7，数组中的指针

```c
----------------------------------------------------------------------------
一维数组名的两个含义：
    1）代表数组首元素的地址
    2）代表数组本身
----------------------------------------------------------------------------
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int arr[10];
 int *p=arr; //将数组的首地址 赋值给 整型指针变量p。此处用到"数组名"的第一个含义
 printf("%p\n",p); //打印指针变量p的值
 printf("%p\n",arr); //打印数组的首地址。此处用到"数组名"的第一个含义
 printf("%p\n",&arr); //打印数组的首地址。此处用到"数组名"的第二个含义
 return 0;
}
----------------------------------------------------------------------------
指针的运算
+ - ++ --
----------------------------------------------------------------------------
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int arr[5];
 int *p=arr; //arr数组名代表 数组首元素的地址
 printf("%p\n",p);
 printf("%p\n",p+1); //按照元素大小的字节去"跳转"
 printf("----------------\n");
 printf("%p\n",arr);
 printf("%p\n",arr+1); //按照元素大小的字节去"跳转"
 printf("----------------\n");
 printf("%p\n",&arr); //给数组名取地址，代表整个数组的地址
 printf("%p\n",(&arr)+1); //按照数组大小的字节去"跳转"
 return 0;
}
```

```c
题目：给一个容量为5的整型数组初始化后，用指针的形式来打印每个元素
#include <stdio.h> 
int main(int argc, const char *argv[])
{ 
     int arr[5] = {1,2,3,4,5};
     int *p=arr,i;
     for(i=0;i<5;i++)
     {
     	printf("%d\n",*(p+i));
     }
     return 0;
}
题目：输入一个英文句子，删除空格后打印字符串，只在同一个数组中操作
#include <stdio.h>
int main(int argc, const char *argv[])
{
     char arr[30];
     gets(arr);
     char *pa = arr;
     char *pa_copy = arr;
     for( ; *pa!='\0' ; pa++ )
     {
         if(*pa!=' ')
         {
             *pa_copy = *pa;
             pa_copy++;
         }
     }
     *pa_copy = '\0';
      puts(arr);
     return 0;
}
题目：用指针的形式实现字符串拼接的功能。
```

## 	8，数组指针和指针数组

### （1）数组指针

![](数组指针.png)

```c
/*--------------------------------------------------------------------------
数组指针 本质是个 指针，指向的是一个 数组整体的地址。
格式：
	数据类型 (*指针变量名)[ 数组容量 ]；
--------------------------------------------------------------------------*/
例：
    int (*p1)[5]; //声明了一个指针变量p1，指向容量为5的整型数组的地址
    char (*p2)[6]; //声明了一个指针变量p2，指向容量为6的字符型数组的地址
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int (*p1)[5];
 char (*p2)[6]; 
 
 int arr[5];
 char brr[6];
 
 p1 = &arr; //用 数组指针 来接收 数组整体的地址
 p2 = &brr;
 printf("%p\n",p1);
 printf("%p\n",p1+1); //p1的格局是20byte，所以+1就跳转20byte
 return 0;
}
```

### （2）指针数组

![](指针数组.png)

```c
/*--------------------------------------------------------------------------
指针数组 本质是 数组。每个元素都是指针。
格式：
	数据类型 *数组名[ 数组容量 ]；
--------------------------------------------------------------------------*/
例：
 int *arr[5]; //声明了一个容量为5的数组，每个元素都是一个整型指针，每个元素
都会指向一个整型空间的地址
 char *brr[6]; //声明了一个容量为6的数组，每个元素都是一个字符型指针，每个元素都会指向一个字符型空间的地址
```

## 	9，二维数组中的地址

```c
--------------------------------------------------------------------------
1）* 不叫取值符号，我们为了好理解，就叫他"降维符"，或"降级符"。
2）数组名并不是代表元素的地址，而是代表数组最大概念的地址。
    int a[3][5];
     	行，列，数
    a //数组名，这个维度的数组中最大概念的地址；
    *a //星号+数组名， *（降级符）可以把星号后面表示的概念降一级；
    *（*a） //对于二维数组来说，这个操作是将行降级到列再降级到数据；
在二维数组中	
    a+i //表示的是二维数组每一行的首地址
    *(a+i) //表示的是二维数组中第 i 行的第 0 列的地址
    *(a+i)+j //表示的是二维数组中第 i 行的第 j 列元素的地址
    *(*(a+i)+j) //表示的是二维数组中第 i 行的第 j 列元素的数据
--------------------------------------------------------------------------

```

![](二维数组中的地址.png)

```c
作业：
 1）用指针编写strlen函数的功能
 2）用指针编写strcmp函数的功能
 3）用指针编写strcpy函数的功能
 4）用指针编写strcat函数的功能；
 5）从键盘输入一个字符串，然后再输入一个字符，用指针遍历字符串，打印有几个这样的字符。
复习作业：
 6）复习运算符：给出一个 32 位的有符号整数，从终端输入，你需要将这个整数中每位上的数字进行反转。
    例如： 输入：123 输出 321
 	输入：-123 输出 -321 
#include <stdio.h>
int main(int argc, const char *argv[])
{
 int num,new=0,i,j,k,m;
 int arr[15];
 scanf("%d",&num);
 if(num<0)
 {
     printf("-");
     num = num * (-1);
 }
 for( i=0 ; num != 0 ; i++ )
 {
     arr[i] = num%10;
     num = num/10;
 }
    
 i--;
    
 for(j=0;j<=i ;j++ )
 {
     for(k=0;k<i-j;k++ )
     	arr[j] = arr[j]*10;
 }
 for(j=0;j<=i;j++)
 {
 	new = new + arr[j];
 }
 printf("%d\n",new);
 return 0;
}
7）复习数组：给定一个容量为10的整数数组 nums 存放10以内的随机数 和 一个目标值target，请你在该数组中找出 和为目标值的那 两个 整数，并返回他们的数组下标。每两个数只能相加一次。
    例如：
         给定 nums[10] = {2, 7, 11, 15}, target = 9
         因为 nums[0] + nums[1] = 2 + 7 = 9 
         所以打印下标 0和1
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main(int argc, const char *argv[])
{
 int arr[10],target;
 int i,j,flag=0;
 srand(time(0));
 for(i=0;i<10;i++)
 {
     arr[i] = rand()%10;
     printf("%d ",arr[i]);
 }
 printf("\n");
 scanf("%d",&target);
 for(i=0;i<9;i++)
 {
     for(j=i+1;j<10;j++)
     {
         if(arr[i]+arr[j]==target)
         {
             printf("%d %d\n",i,j);
             flag = 1;
         }
     }
 }
 if(flag==0)
 { 
	 printf("无满足情况\n");
 }
 return 0;
}
```

# C基础之函数

​		函数 是一组一起执行一个任务的语句。每个C程序都至少有一个函数，即主函数main( )，所 有简单的程序都可以定义其他额外的函数。 

​		可以把代码块划分到不同的函数中。如何划分是由你自己决定的，但在逻辑上，划分的 依据通常是完成一个特定功能的完整的语句块。 

​		C标准库中定义了大量的函数实现许多比较常用的功能，是我们在编程中可以直接使用。 例如：printf()/scanf()，string函数族中的各种函数，随机数函数rand( )等。

## 	1，定义函数

```c
格式：
    返回类型 函数名( 形式参数 ) //函数头
    {
    	函数体；
    }

函数由两部分组成：函数头 和 函数体 。
	返回类型：函数返回值的数据类型，有的函数不需要返回值，那么返回类型就是void。如果有返回值，那么在函数中需要用return将值返回。
	函数名：遵循标识符命名规则
	形式参数（参数列表）：当函数被调用时，为了让函数成功实现指定功能，我们有时需要提前给函数一些必要的辅助数据( 参数 )，形式参数的写法和声明变量的写法一样，而且属于局部变量。 形式参数要求和实际参数能够一一对应，即形式参数中参数的个数、数据类型、顺序都必须和传入参数时实际参数的个数、数据类型、顺序保持一致。如果函数不需要参数，我们就在( )里写void。
	函数体：函数的主体。实现函数功能的语句都写在这里。
	函数结束的标志：return关键字和大括号的后一半。
例：特别简单的分函数写法，实现打印两数相加
#include <stdio.h>
int add(int ,int ); //函数声明
int main(int argc, const char *argv[])
{
     int a,b,sum;
     scanf("%d%d",&a,&b);
     sum = add(a,b); //调用add函数并且传参
     printf("%d\n",sum);
     return 0;
}
int add(int a,int b) //定义add函数，写明需要的参数和返回类型
{
 	return a+b;
}
方法二：
#include <stdio.h>
void add(void);
int main(int argc, const char *argv[])
{
     add();
     return 0;
}
void add(void)
{
     int a,b;
     scanf("%d%d",&a,&b);
     printf("%d\n",a+b);
}
```



## 	2，函数声明

```c
	函数声明 是把函数头写在程序的最前面，后面再加个分号。其中，参数列表中的
变量名可以不写。
	函数声明是为了提前告诉编译器“我的代码里有这个函数啦，你在主函数中遇到调
用这个函数的时候有个心理准备”。
	形如前面的例子中，引用头文件后就是函数声明。
```



## 	3，调用函数

```c
	创建C函数时，会定义函数实现什么功能，然后通过调用函数来完成任务。
	当程序调用函数时，程序的控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行，或执行到函数的 } 括号时，程序的控制权会重新交换给调用它的函数。
#include <stdio.h> //1，引用头文件
int add(int ,int ); //2，识别到add函数（心里有数了）
int main(int argc, const char *argv[])//3，程序开始执行
{
     int a,b,sum; //4，从栈区中划分三个4byte的空间
     scanf("%d%d",&a,&b); //5，往a和b的空间中写入数据
     sum = add(a,b); //6，先调用add函数，并且将a,b的值作为实参传入
     //9，将返回值赋值给sum 
     printf("%d\n",sum); //10，打印sum的值
     return 0; //11，程序结束
}
int add(int a,int b) //7，add函数开始运行，把主函数中a,b的值给到add函数的形参a,b中
{
 	return a+b; //8，计算a+b，并将结果返回到调用add函数的地方
}
如果被调用的函数需要接收参数，我们就得在调用函数时将特定的参数作为实际参
数传入。
    具体写法就是：例如：add(a,b);
```

```c
练习：从终端输入两个数，打印其中的最大值
练习：从终端输入一个数n，打印n*n 的*图形。
#include <stdio.h>
void tuxing(int n);
int main(int argc, const char *argv[])
{
     int n;
     scanf("%d",&n);
     tuxing(n);
     return 0;
}
void tuxing(int n)
{
     int i,j;
     for(i=0;i<n;i++)
     {
         for(j=0;j<n;j++)
         {
             printf("*");
         }
         printf("\n");
     }
}
```

## 	4，函数参数

```c
	思考：在主函数中从终端输入两个数a,b，分函数实现数据交换，在主函数中打印交换后a,b的值。
	如果函数需要使用参数，则必须声明接收参数的变量，这个变量我们称为形式参数。
	形式参数就是局部变量，在函数开始时空间被分配，函数结束时空间被释放。

C语言中有两种传递参数的方式：
    值传递
    地址传递
```

### （1）值传递 

```c
#include <stdio.h>
void change(int a,int b);
int main(int argc, const char *argv[])
{
 int a,b;
 scanf("%d%d",&a,&b);
 change(a,b); //将变量a,b的值作为参数传入到函数中
 printf("%d %d\n",a,b); //实参中的数据并没有发生变动，所以打印的结果并没有发生交换
 return 0;
}
void change(int a,int b) //接收传来的 值
{
 int temp;
 temp = a;
 a = b;
 b = temp;
 printf("%d %d\n",a,b); //数据交换交换的是形参中的数据，所这里打印的结果就是交换后的结果
}
	值传递使用变量、常量、数组元素作为函数参数，实际是将实参的值复制到形参的内存空间中，即 形参 和 实参 拥有不同的存储空间。
	值传递是单向传递，在形参中做的任何操作都不会直接影响到实参的值。
```

### （2）地址传递

```c
#include <stdio.h>
void change(int *,int *);
int main(int argc, const char *argv[])
{
     int a,b;
     scanf("%d%d",&a,&b);
     change(&a,&b); //将变量a,b的地址作为参数传入到函数中
     printf("%d %d\n",a,b); //将被通过地址进行数据交换的a,b打印出来
     return 0;
}
void change(int *pa,int *pb) //用指针接收传来的地址
{
     int temp;
     temp = *pa; //在指针前加*可以把地址中的值拿出来做数据交换
     *pa = *pb;
     *pb = temp;
}
	只要形参接收的是地址，那么对形参做的任何操作都会在调用它的地方反映
出来。
```

## 	5，指针函数

```c
返回值是一个指针的函数。通常情况下，这个指针是数组的地址或结构体的地址。
		格式：
			数据类型 * 函数名(形参列表)；
思考：在主函数中给一个容量为10的整型数组填充随机数，分函数求出最大值及其下标，在主函数中打印最大值和下标
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int *max(int *p);
int main(int argc, const char *argv[])
{
     int arr[10];
     int i,*q,*p=arr;
     srand(time(0));
     for(i=0;i<10;i++)
     {
         arr[i] = rand()%1000;
         printf("%d ",arr[i]);
     }
     putchar('\n');
     q = max(p);
     printf("%d %d\n",*q,*(q+1));
     return 0;
}
 
int * max(int *p)
{
     static int arr[2];
     int i,*q=arr;
     arr[0] = *p;
     for(i=0;i<10;i++,p++)
     {
         if(arr[0]<*p)
         {
             arr[0] = *p; //接收最大值
             arr[1] = i; //接收下标
         }
 	}
 return q;
}
```

```c
练习：主函数中输入字符串，分函数求字符串长度，主函数中打印。
练习：主函数中输入两个字符串，分函数拼接，将拼接后的字符串在主函数中打印出来。
#include <stdio.h>
void my_strcat(char *pa,char *pb);
int main(int argc, const char *argv[])
{
     char arr[30],brr[30];
     gets(arr);
     gets(brr);
     my_strcat(arr,brr);
     printf("%s\n",arr);
     return 0;
}
void my_strcat(char *pa,char *pb)
{
     for(;*pa!=0;pa++);
     for(;*pb!=0;pb++,pa++)
     {
     	*pa=*pb;
     }
     *pa = '\0';
 }
作业：分函数写！
1.在终端输入1~3中的任意一个数，用switch case语句完成下面逻辑：
当输入1时，调用function1函数，输入一个数n，打印输出n×n的 * 矩阵；
当输入2时，调用function2函数，输入一个数n，打印输出斐波那契数列的前n项；
当输入3时，调用function3函数，输入两个数x,y，交换数据后输出新的x,y的值；
斐波那契数列：1 1 2 3 5 8 13 21 34 55…..
2.输入一个字符串，输出字符串中有几个空格。
3.主函数中输入十个数字存到数组中，然后在另外一个函数中用冒泡排序从大到小排
序，并输出排序后的数列。
4.用指针编写strcmp函数的功能
5.用指针编写strcpy函数的功能
6.位运算。从终端输入一个无符号整型数，打印这个整型数在计算机存储中的二进制数
中有几个1。
```

